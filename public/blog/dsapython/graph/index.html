<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DSA in Python - Graph | Atharva Shah</title>
<meta name="keywords" content="DSA-Python">
<meta name="description" content="Implement Graph Implement Weighted Graph Implement BFS algorithm Implement DFS Algo Detect Cycle in Directed Graph using BFS/DFS Algo Detect Cycle in UnDirected Graph using BFS/DFS Algo Minimum Step by Knight flood fill algo Clone a graph Making wired Connections word Ladder Dijkstra algo Implement Topological Sort Minimum time taken by each job to be completed given by a Directed Acyclic Graph Find whether it is possible to finish all tasks or not from given dependencies Find the no.">
<meta name="author" content="">
<link rel="canonical" href="https://atharvashah.netlify.app/blog/dsapython/graph/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.061a8952013664c99bacf079b6effc1f4b8dcc97ae88ed4456398d0f7830bf89.css" integrity="sha256-BhqJUgE2ZMmbrPB5tu/8H0uNzJeuiO1EVjmND3gwv4k=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://atharvashah.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://atharvashah.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://atharvashah.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://atharvashah.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://atharvashah.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9913536001930134" crossorigin="anonymous"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="DSA in Python - Graph" />
<meta property="og:description" content="Implement Graph Implement Weighted Graph Implement BFS algorithm Implement DFS Algo Detect Cycle in Directed Graph using BFS/DFS Algo Detect Cycle in UnDirected Graph using BFS/DFS Algo Minimum Step by Knight flood fill algo Clone a graph Making wired Connections word Ladder Dijkstra algo Implement Topological Sort Minimum time taken by each job to be completed given by a Directed Acyclic Graph Find whether it is possible to finish all tasks or not from given dependencies Find the no." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://atharvashah.netlify.app/blog/dsapython/graph/" />
<meta property="og:image" content="https://atharvashah.netlify.app/blog/dsa/graph.jpg" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-07-09T13:14:34+05:30" />
<meta property="article:modified_time" content="2022-07-09T13:14:34+05:30" /><meta property="og:site_name" content="Atharva Shah" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://atharvashah.netlify.app/blog/dsa/graph.jpg" />
<meta name="twitter:title" content="DSA in Python - Graph"/>
<meta name="twitter:description" content="Implement Graph Implement Weighted Graph Implement BFS algorithm Implement DFS Algo Detect Cycle in Directed Graph using BFS/DFS Algo Detect Cycle in UnDirected Graph using BFS/DFS Algo Minimum Step by Knight flood fill algo Clone a graph Making wired Connections word Ladder Dijkstra algo Implement Topological Sort Minimum time taken by each job to be completed given by a Directed Acyclic Graph Find whether it is possible to finish all tasks or not from given dependencies Find the no."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://atharvashah.netlify.app/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "DSA in Python - Graph",
      "item": "https://atharvashah.netlify.app/blog/dsapython/graph/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DSA in Python - Graph",
  "name": "DSA in Python - Graph",
  "description": "Implement Graph Implement Weighted Graph Implement BFS algorithm Implement DFS Algo Detect Cycle in Directed Graph using BFS/DFS Algo Detect Cycle in UnDirected Graph using BFS/DFS Algo Minimum Step by Knight flood fill algo Clone a graph Making wired Connections word Ladder Dijkstra algo Implement Topological Sort Minimum time taken by each job to be completed given by a Directed Acyclic Graph Find whether it is possible to finish all tasks or not from given dependencies Find the no.",
  "keywords": [
    "DSA-Python"
  ],
  "articleBody": " Implement Graph Implement Weighted Graph Implement BFS algorithm Implement DFS Algo Detect Cycle in Directed Graph using BFS/DFS Algo Detect Cycle in UnDirected Graph using BFS/DFS Algo Minimum Step by Knight flood fill algo Clone a graph Making wired Connections word Ladder Dijkstra algo Implement Topological Sort Minimum time taken by each job to be completed given by a Directed Acyclic Graph Find whether it is possible to finish all tasks or not from given dependencies Find the no. of Islands Given a sorted Dictionary of an Alien Language, find order of characters Implement Kruksal’sAlgorithm Implement Prim’s Algorithm Total no. of Spanning tree in a graph Implement Bellman Ford Algorithm Implement Floyd warshallAlgorithm Travelling Salesman Problem Graph ColouringProblem Snake and Ladders Problem Find bridge in a graph Count Strongly connected Components(Kosaraju Algo) Check whether a graph is Bipartite or Not Longest path in a Directed Acyclic Graph Journey to the Moon Cheapest Flights Within K Stops Oliver and the Game Water Jug problem using BFS Find if there is a path of more thank length from a source Minimum edges to reverse o make path from source to destination Paths to travel each nodes using each edge(Seven Bridges) Vertex Cover Problem Chinese Postman or Route Inspection Number of Triangles in a Directed and Undirected Graph Minimise the cashflow among a given set of friends who have borrowed money from each other Two Clique Problem Implement Graph class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) def printGraph(graph): for src in range(len(graph.adjList)): for dest in graph.adjList[src]: print(f'({src} —\u003e {dest}) ', end='') print() edges = [(0, 1), (1, 2), (2, 0), (2, 1), (3, 2), (4, 5), (5, 4)] n = 6 graph = Graph(edges, n) printGraph(graph) Implement Weighted Graph class Graph: def __init__(self, edges, n): self.adjList = [None] * n for i in range(n): self.adjList[i] = [] for (src, dest, weight) in edges: self.adjList[src].append((dest, weight)) def printGraph(graph): for src in range(len(graph.adjList)): for (dest, weight) in graph.adjList[src]: print(f'({src} —\u003e {dest}, {weight}) ', end='') print() # Input: Edges in a weighted digraph (as per the above diagram) # Edge (x, y, w) represents an edge from `x` to `y` having weight `w` edges = [(0, 1, 6), (1, 2, 7), (2, 0, 5), (2, 1, 4), (3, 2, 10), (4, 5, 1), (5, 4, 3)] n = 6 graph = Graph(edges, n) printGraph(graph) Implement BFS algorithm from collections import deque class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) self.adjList[dest].append(src) def BFS(graph, v, discovered): q = deque() discovered[v] = True q.append(v) while q: v = q.popleft() print(v, end=' ') for u in graph.adjList[v]: if not discovered[u]: discovered[u] = True q.append(u) edges = [ (1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (5, 9), (5, 10), (4, 7), (4, 8), (7, 11), (7, 12) # vertex 0, 13, and 14 are single nodes ] n = 15 graph = Graph(edges, n) discovered = [False] * n for i in range(n): if not discovered[i]: BFS(graph, i, discovered) Implement DFS Algo from collections import deque class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) self.adjList[dest].append(src) def iterativeDFS(graph, v, discovered): stack = deque() stack.append(v) while stack: v = stack.pop() if discovered[v]: continue discovered[v] = True print(v, end=' ') adjList = graph.adjList[v] for i in reversed(range(len(adjList))): u = adjList[i] if not discovered[u]: stack.append(u) edges = [ # Notice that node 0 is unconnected (1, 2), (1, 7), (1, 8), (2, 3), (2, 6), (3, 4), (3, 5), (8, 9), (8, 12), (9, 10), (9, 11) # (6, 9) introduces a cycle ] n = 13 graph = Graph(edges, n) discovered = [False] * n for i in range(n): if not discovered[i]: iterativeDFS(graph, i, discovered) Detect Cycle in Directed Graph using BFS/DFS Algo class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) # Perform DFS on the graph and set the departure time of all vertices of the graph def DFS(graph, v, discovered, departure, time): # mark the current node as discovered discovered[v] = True # do for every edge (v, u) for u in graph.adjList[v]: # if `u` is not yet discovered if not discovered[u]: time = DFS(graph, u, discovered, departure, time) # ready to backtrack set departure time of vertex `v` departure[v] = time time = time + 1 return time # Returns true if the given directed graph is DAG def isDAG(graph, n): # keep track of whether a vertex is discovered or not discovered = [False] * n # keep track of the departure time of a vertex in DFS departure = [None] * n time = 0 # Perform DFS traversal from all undiscovered vertices to visit all connected components of a graph for i in range(n): if not discovered[i]: time = DFS(graph, i, discovered, departure, time) # check if the given directed graph is DAG or not for u in range(n): # check if (u, v) forms a back-edge. for v in graph.adjList[u]: # If the departure time of vertex `v` is greater than equal # to the departure time of `u`, they form a back edge. # Note that `departure[u]` will be equal to `departure[v]` # only if `u = v`, i.e., vertex contain an edge to itself if departure[u] \u003c= departure[v]: return False # no back edges return True # List of graph edges as per the above diagram edges = [(0, 1), (0, 3), (1, 2), (1, 3), (3, 2), (3, 4), (3, 0), (5, 6), (6, 3)] # total number of nodes in the graph (labelled from 0 to 6) n = 7 graph = Graph(edges, n) if isDAG(graph, n): print('Does not contain a Cycle') else: print('Contains a Cycle') Detect Cycle in UnDirected Graph using BFS/DFS Algo class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) self.adjList[dest].append(src) # Function to perform DFS traversal on the graph on a graph def DFS(graph, v, discovered, parent=-1): # mark the current node as discovered discovered[v] = True # do for every edge (v, w) for w in graph.adjList[v]: # if `w` is not discovered if not discovered[w]: if DFS(graph, w, discovered, v): return True # if `w` is discovered, and `w` is not a parent elif w != parent: # we found a back-edge (cycle) return True # No back-edges were found in the graph return False edges = [ (0, 1), (0, 6), (0, 7), (1, 2), (1, 5), (2, 3), (2, 4), (7, 8), (7, 11), (8, 9), (8, 10), (10, 11) # edge (10, 11) introduces a cycle in the graph ] # total number of nodes in the graph (0 to 11) n = 12 graph = Graph(edges, n) discovered = [False] * n if DFS(graph, 0, discovered): print('The graph contains a cycle') else: print('The graph doesn\\'t contain any cycle') Minimum Step by Knight \"\"\"Given a chessboard, find the shortest distance (minimum number of steps) taken by a knight to reach a given destination from a given source. For example, Input: N = 8 (8 × 8 board) Source = (7, 0) Destination = (0, 7) Output: Minimum number of steps required is 6 \"\"\" import sys from collections import deque class Node: # (x, y) represents chessboard coordinates `dist` represents its minimum distance from the source def __init__(self, x, y, dist=0): self.x = x self.y = y self.dist = dist # As we are using `Node` as a key in a dictionary, we need to override the `__hash__()` and `__eq__()` function def __hash__(self): return hash((self.x, self.y, self.dist)) def __eq__(self, other): return (self.x, self.y, self.dist) == (other.x, other.y, other.dist) # Below lists detail all eight possible movements for a knight row = [2, 2, -2, -2, 1, 1, -1, -1] col = [-1, 1, 1, -1, 2, -2, 2, -2] # Check if (x, y) is valid chessboard coordinates. # Note that a knight cannot go out of the chessboard def isValid(x, y, N): return x \u003e= 0 and y \u003e= 0 and x \u003c N and y \u003c N # Find the minimum number of steps taken by the knight # from the source to reach the destination using BFS def findShortestDistance(src, dest, N): # set to check if the matrix cell is visited before or not visited = set() # create a queue and enqueue the first node q = deque() q.append(src) # loop till queue is empty while q: # dequeue front node and process it node = q.popleft() x = node.x y = node.y dist = node.dist # if the destination is reached, return distance if x == dest.x and y == dest.y: return dist # skip if the location is visited before if node not in visited: # mark the current node as visited visited.add(node) # check for all eight possible movements for a knight # and enqueue each valid movement for i in range(len(row)): # get the knight's valid position from the current position on # the chessboard and enqueue it with +1 distance x1 = x + row[i] y1 = y + col[i] if isValid(x1, y1, N): q.append(Node(x1, y1, dist + 1)) # return infinity if the path is not possible return sys.maxsize N = 8 # N x N matrix src = Node(0, 7) # source coordinates dest = Node(7, 0) # destination coordinates print(\"The minimum number of steps required is\",findShortestDistance(src, dest, N)) flood fill algo \"\"\"Flood fill (also known as seed fill) is an algorithm that determines the area connected to a given node in a multi-dimensional array. \"\"\" # Below lists detail all eight possible movements row = [-1, -1, -1, 0, 0, 1, 1, 1] col = [-1, 0, 1, -1, 1, -1, 0, 1] # check if it is possible to go to pixel (x, y) from the # current pixel. The function returns false if the pixel # has a different color, or it's not a valid pixel def isSafe(mat, x, y, target): return 0 \u003c= x \u003c len(mat) and 0 \u003c= y \u003c len(mat[0]) and mat[x][y] == target # Flood fill using DFS def floodfill(mat, x, y, replacement): # base case if not mat or not len(mat): return # get the target color target = mat[x][y] # target color is same as replacement if target == replacement: return # replace the current pixel color with that of replacement mat[x][y] = replacement # process all eight adjacent pixels of the current pixel and # recur for each valid pixel for k in range(len(row)): # if the adjacent pixel at position (x + row[k], y + col[k]) is # a valid pixel and has the same color as that of the current pixel if isSafe(mat, x + row[k], y + col[k], target): floodfill(mat, x + row[k], y + col[k], replacement) mat = [ ['Y', 'Y', 'Y', 'G', 'G', 'G', 'G', 'G', 'G', 'G'], ['Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'G', 'X', 'X', 'X'], ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'X', 'X', 'X'], ['W', 'W', 'W', 'W', 'W', 'G', 'G', 'G', 'G', 'X'], ['W', 'R', 'R', 'R', 'R', 'R', 'G', 'X', 'X', 'X'], ['W', 'W', 'W', 'R', 'R', 'G', 'G', 'X', 'X', 'X'], ['W', 'B', 'W', 'R', 'R', 'R', 'R', 'R', 'R', 'X'], ['W', 'B', 'B', 'B', 'B', 'R', 'R', 'X', 'X', 'X'], ['W', 'B', 'B', 'X', 'B', 'B', 'B', 'B', 'X', 'X'], ['W', 'B', 'B', 'X', 'X', 'X', 'X', 'X', 'X', 'X'] ] # start node x, y = (3, 9) # having a target color `X` # replacement color replacement = 'C' # replace the target color with a replacement color using DFS floodfill(mat, x, y, replacement) # print the colors after replacement for r in mat: print(r) Clone a graph TODO Making wired Connections \"\"\"There are n computers numbered from 0 to n-1 connected by ethernet cables connections forming a network where connections[i] = [a, b] represents a connection between computers a and b. Any computer can reach any other computer directly or indirectly through the network. Given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the minimum number of times you need to do this in order to make all the computers connected. If it’s not possible, return -1. Example 1: Input: n = 4, connections = [[0,1],[0,2],[1,2]] Output: 1 Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3. Example 2: Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] Output: 2 Example 3: Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] Output: -1 Explanation: There are not enough cables. Example 4: Input: n = 5, connections = [[0,1],[0,2],[3,4],[2,3]] Output: 0 \"\"\" def makeConnected(n, connections): uf = {i: i for i in range(n)} def find(x): uf.setdefault(x, x) if uf[x] != x: uf[x] = find(uf[x]) return uf[x] def union(a, b): uf[find(a)] = find(b) if len(connections) \u003c n - 1: return -1 for a, b in connections: union(a, b) islands = len({find(x) for x in uf}) return islands - 1 n = 4 connections = [[0,1],[0,2],[1,2]] print(makeConnected(n, connections)) word Ladder \"\"\" Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that: (i) Only one letter can be changed at a time, and (ii) each transformed word must exist in the word list. Note that beginWord is not a transformed word. EXAMPLES beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] -\u003e 5 (because \"hit\" -\u003e \"hot\" -\u003e \"dot\" -\u003e \"dog\" -\u003e \"cog\") \"\"\" from collections import deque def ladderLength(beginWord, endWord, wordList): \"\"\" :type beginWord: str :type endWord: str :type wordList: Set[str] :rtype: int \"\"\" queue = deque() queue.append((beginWord, [beginWord])) while queue: node, path = queue.popleft() for next in next_nodes(node, wordList) - set(path): if next == endWord: return len(path) + 1 else: queue.append((next, path + [next])) return 0 def next_nodes(word, word_list): to_return = set() for w in word_list: mismatch_count, w_length = 0, len(w) for i in range(w_length): if w[i] != word[i]: mismatch_count += 1 if mismatch_count == 1: to_return.add(w) return to_return beginWord = \"hit\" endWord = \"cog\" wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"] print(ladderLength(beginWord, endWord, wordList)) Dijkstra algo \"\"\" Given a source vertex s from a set of vertices V in a weighted digraph where all its edge weights w(u, v) are non-negative, find the shortest path weights d(s, v) from source s for all vertices v present in the graph \"\"\" import sys from heapq import heappop, heappush class Node: def __init__(self, vertex, weight=0): self.vertex = vertex self.weight = weight # Override the __lt__() function to make `Node` class work with a min-heap def __lt__(self, other): return self.weight \u003c other.weight class Graph: def __init__(self, edges, n): # allocate memory for the adjacency list self.adjList = [[] for _ in range(n)] # add edges to the directed graph for (source, dest, weight) in edges: self.adjList[source].append((dest, weight)) def get_route(prev, i, route): if i \u003e= 0: get_route(prev, prev[i], route) route.append(i) def findShortestPaths(graph, source, n): # create a min-heap and push source node having distance 0 pq = [] heappush(pq, Node(source)) # set initial distance from the source to `v` as infinity dist = [sys.maxsize] * n # distance from the source to itself is zero dist[source] = 0 # list to track vertices for which minimum cost is already found done = [False] * n done[source] = True # stores predecessor of a vertex (to a print path) prev = [-1] * n # run till min-heap is empty while pq: node = heappop(pq) # Remove and return the best vertex u = node.vertex # get the vertex number # do for each neighbor `v` of `u` for (v, weight) in graph.adjList[u]: if not done[v] and (dist[u] + weight) \u003c dist[v]: # Relaxation step dist[v] = dist[u] + weight prev[v] = u heappush(pq, Node(v, dist[v])) # mark vertex `u` as done so it will not get picked up again done[u] = True route = [] for i in range(n): if i != source and dist[i] != sys.maxsize: get_route(prev, i, route) print(f'Path ({source} —\u003e {i}): Minimum cost = {dist[i]}, Route = {route}') route.clear() # initialize edges as per the above diagram (u, v, w) represent edge from vertex `u` to vertex `v` having weight `w` edges = [(0, 1, 10), (0, 4, 3), (1, 2, 2), (1, 4, 4), (2, 3, 9), (3, 2, 7), (4, 1, 1), (4, 2, 8), (4, 3, 2)] # total number of nodes in the graph (labelled from 0 to 4) n = 5 graph = Graph(edges, n) for source in range(n): findShortestPaths(graph, source, n) Implement Topological Sort \"\"\" Given a Directed Acyclic Graph (DAG), print it in topological order using topological sort algorithm. If the graph has more than one topological ordering, output any of them. Assume valid Directed Acyclic Graph (DAG). A Topological sort or Topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. A topological ordering is possible if and only if the graph has no directed cycles, i.e. if the graph is DAG. \"\"\" # A class to represent a graph object class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) # Perform DFS on the graph and set the departure time of all vertices of the graph def DFS(graph, v, discovered, departure, time): discovered[v] = True time = time + 1 for u in graph.adjList[v]: if not discovered[u]: time = DFS(graph, u, discovered, departure, time) departure[time] = v time = time + 1 return time # Function to perform a topological sort on a given DAG def doTopologicalSort(graph, n): # departure[] stores the vertex number using departure time as an index departure = [-1] * 2 * n ''' If we had done it the other way around, i.e., fill the array with departure time using vertex number as an index, we would need to sort it later ''' # to keep track of whether a vertex is discovered or not discovered = [False] * n time = 0 # perform DFS on all undiscovered vertices for i in range(n): if not discovered[i]: time = DFS(graph, i, discovered, departure, time) # Print the vertices in order of their decreasing # departure time in DFS, i.e., in topological order for i in reversed(range(2*n)): if departure[i] != -1: print(departure[i], end=' ') # List of graph edges as per the above diagram edges = [(0, 6), (1, 2), (1, 4), (1, 6), (3, 0), (3, 4), (5, 1), (7, 0), (7, 1)] # total number of nodes in the graph (labelled from 0 to 7) n = 8 graph = Graph(edges, n) doTopologicalSort(graph, n) Minimum time taken by each job to be completed given by a Directed Acyclic Graph \"\"\" Given a Directed Acyclic Graph having V vertices and E edges, where each edge {U, V} represents the Jobs U and V such that Job V can only be started only after completion of Job U. The task is to determine the minimum time taken by each job to be completed where each Job takes unit time to get completed. \"\"\" from collections import defaultdict class Graph: def __init__(self, vertices, edges): self.graph = defaultdict(list) self.n = vertices self.m = edges # Function to add an edge to graph def addEdge(self, u, v): self.graph[u].append(v) # Function to find the minimum time needed by each node to get the task def printOrder(self, n, m): # Create a vector to store indegrees of all vertices. Initialize all indegrees as 0. indegree = [0] * (self.n + 1) # Traverse adjacency lists to fill indegrees of vertices. This step takes O(V + E) time for i in self.graph: for j in self.graph[i]: indegree[j] += 1 # Array to store the time in which the job i can be done job = [0] * (self.n + 1) # Create an queue and enqueue all vertices with indegree 0 q = [] # Update the time of the jobs who don't require any job to be completed before this job for i in range(1, self.n + 1): if indegree[i] == 0: q.append(i) job[i] = 1 # Iterate until queue is empty while q: # Get front element of queue cur = q.pop(0) for adj in self.graph[cur]: # Decrease in-degree of the current node indegree[adj] -= 1 # Push its adjacent elements if (indegree[adj] == 0): job[adj] = 1 + job[cur] q.append(adj) # Print the time to complete the job for i in range(1, n + 1): print(job[i], end = \" \") print() # Given Nodes N and edges M n = 10 m = 13 g = Graph(n, m) g.addEdge(1, 3) g.addEdge(1, 4) g.addEdge(1, 5) g.addEdge(2, 3) g.addEdge(2, 8) g.addEdge(2, 9) g.addEdge(3, 6) g.addEdge(4, 6) g.addEdge(4, 8) g.addEdge(5, 8) g.addEdge(6, 7) g.addEdge(7, 8) g.addEdge(8, 10) g.printOrder(n, m) Find whether it is possible to finish all tasks or not from given dependencies \"\"\" There are a total of n tasks you have to pick, labelled from 0 to n-1. Some tasks may have prerequisites, for example to pick task 0 you have to first pick task 1, which is expressed as a pair: [0, 1] Given the total number of tasks and a list of prerequisite pairs, is it possible for you to finish all tasks? Examples: Input: 2, [[1, 0]] Output: true Explanation: There are a total of 2 tasks to pick. To pick task 1 you should have finished task 0. So it is possible. Input: 2, [[1, 0], [0, 1]] Output: false Explanation: There are a total of 2 tasks to pick. To pick task 1 you should have finished task 0, and to pick task 0 you should also have finished task 1. So it is impossible. Input: 3, [[1, 0], [2, 1], [3, 2]] Output: true Explanation: There are a total of 3 tasks to pick. To pick tasks 1 you should have finished task 0, and to pick task 2 you should have finished task 1 and to pick task 3 you should have finished task 2. So it is possible. \"\"\" class Solution: arr = [] # parameterized constructor def __init__(self,n): # Initially, everyone is their own child self.arr = list(range(n)) def makeParent(self,a, b): # find parent of b and make it a's parent self.arr[a] = self.findParent(b) def findParent(self,c): # when an independent task is found return c if (c == self.arr) else self.findParent(self.arr) def isPossible(self,N , prerequisites): # traverse through pre-requisites array for i in range(len(prerequisites)): # check whether given pre-requisite pair already have a common pre-requisite(parent) if (self.findParent(prerequisites[i][0]) == self.findParent(prerequisites[i][1])): # tasks cannot be completed because there was a cyclic condition in the tasks return False # make parent-child relation between pre-requisite task and the task dependent on it self.makeParent(prerequisites[i][0], prerequisites[i][1]) # if there was no cycle found, tasks can be completed return True prerequisites = [[1, 0], [2, 1], [3, 2]] ob = Solution(4) if ob.isPossible(4,prerequisites ): print(\"Yes\") else: print(\"No\") Find the no. of Islands \"\"\" Given a boolean 2D matrix, find the number of islands. A group of connected 1s forms an island. For example, the below matrix contains 5 islands Example: Input : mat[][] = {{1, 1, 0, 0, 0}, {0, 1, 0, 0, 1}, {1, 0, 0, 1, 1}, {0, 0, 0, 0, 0}, {1, 0, 1, 0, 1}} Output : 5 \"\"\" # Program to count islands in boolean 2D matrix class Graph: def __init__(self, row, col, graph): self.ROW = row self.COL = col self.graph = graph # A utility function to do DFS for a 2D boolean matrix. It only considers the 8 neighbours as adjacent vertices def DFS(self, i, j): if i \u003c 0 or i \u003e= len(self.graph) or j \u003c 0 or j \u003e= len(self.graph[0]) or self.graph[i][j] != 1: return # mark it as visited self.graph[i][j] = -1 # Recur for 8 neighbours self.DFS(i - 1, j - 1) self.DFS(i - 1, j) self.DFS(i - 1, j + 1) self.DFS(i, j - 1) self.DFS(i, j + 1) self.DFS(i + 1, j - 1) self.DFS(i + 1, j) self.DFS(i + 1, j + 1) # The main function that returns count of islands in a given boolean 2D matrix def countIslands(self): # Initialize count as 0 and traverse through the all cells of given matrix count = 0 for i in range(self.ROW): for j in range(self.COL): # If a cell with value 1 is not visited yet, then new island found if self.graph[i][j] == 1: # Visit all cells in this island and increment island count self.DFS(i, j) count += 1 return count graph = [ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ] row = len(graph) col = len(graph[0]) g = Graph(row, col, graph) print(\"Number of islands is:\", g.countIslands()) Given a sorted Dictionary of an Alien Language, find order of characters \"\"\" Given a dictionary of ancient origin where the words are arranged alphabetically, find the correct order of alphabets in the ancient language. For example, Input: Ancient dictionary { ¥€±, €±€, €±‰ð, ðß, ±±ð, ±ßß } Output: The correct order of alphabets in the ancient language is {¥ € ‰ ð ± ß}. Since the input is small, more than one ordering is possible. Another such ordering is {¥ € ð ± ß ‰}. Input: Ancient dictionary { ÿ€±š, €€€ß, €€‰ð, ðß, ±ß¥š } Output: The correct order of alphabets in the ancient language is {ÿ € ‰ ð ±}. The alphabets {š, ß, ¥} are not included in the order as they are not properly defined. \"\"\" class Graph: def __init__(self, N): self.adj = [[] for _ in range(N)] def DFS(graph, v, discovered, departure, time): discovered[v] = True time = time + 1 for u in graph.adj[v]: if not discovered[u]: time = DFS(graph, u, discovered, departure, time) departure[time] = v return time + 1 # Utility function to performs topological sort on a given DAG def doTopologicalSort(graph, d): # `departure[]` stores the vertex number using departure time as an index departure = [-1] * (2 * N) ''' If we had done it the other way around, i.e., fill the array with departure time using vertex number as an index, we would need to sort it later ''' # to keep track of whether a vertex is discovered or not discovered = [False] * N time = 0 # perform DFS on all undiscovered connected vertices for i in range(N): if not discovered[i] and len(graph.adj[i]): time = DFS(graph, i, discovered, departure, time) print('\\nThe correct order of alphabets in the ancient language is', end=' ') # Print the vertices in order of their decreasing # departure time in DFS, i.e., in topological order for i in reversed(range(2*N)): if departure[i] != -1: print(d[departure[i]], end=' ') # Utility function to print adjacency list representation of a graph def printGraph(graph, d): for i in range(N): # ignore vertices with no outgoing edges if graph.adj[i]: # print current vertex and all neighboring vertices of a vertex `i` print(d[i], '—\u003e', [d[v] for v in graph.adj[i]]) # Function to find the correct order of alphabets in a given dictionary of # ancient origin. This function assumes that the input is correct. def findAlphabetsOrder(dictionary): # create a dictionary to map each non-ASCII character present in the given dictionary with a unique integer d = {} k = 0 # do for each word for word in dictionary: # do for each non-ASCII character of the word for s in word: # if the current character is not present in the dictionary, insert it d.setdefault(s, k) k = k + 1 # create a graph containing `N` nodes graph = Graph(N) # iterate through the complete dictionary and compare adjacent words for character mismatch for i in range(1, len(dictionary)): # previous word in the dictionary prev = dictionary[i - 1] # current word in the dictionary curr = dictionary[i] # iterate through both `prev` and `curr` simultaneously and find the first mismatching character j = 0 while j \u003c len(prev) and j \u003c len(curr): # mismatch found if prev[j] is not curr[j]: # add an edge from the current character of `prev` to the # current character of `curr` in the graph graph.adj[d[prev[j]]].append(d[curr[j]]) break j += 1 # create a reverse dict reverse = {v: k for k, v in d.items()} printGraph(graph, reverse) # perform a topological sort on the above graph doTopologicalSort(graph, reverse) # define the maximum number of alphabets in the ancient dictionary N = 100 dictionary = [ [\"¥\", \"€\", \"±\"], [\"€\", \"±\", \"€\"], [\"€\", \"±\", \"‰\", \"ð\"], [\"ð\", \"ß\"], [\"±\", \"±\", \"ð\"], [\"±\", \"ß\", \"ß\"] ] findAlphabetsOrder(dictionary) Implement Kruksal’sAlgorithm \"\"\" Below are the steps for finding MST using Kruskal’s algorithm 1. Sort all the edges in non-decreasing order of their weight. 2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it. 3. Repeat step#2 until there are (V-1) edges in the spanning tree. \"\"\" from collections import defaultdict class Graph: def __init__(self, vertices): self.V = vertices # No. of vertices self.graph = [] # default dictionary # to store graph # function to add an edge to graph def addEdge(self, u, v, w): self.graph.append([u, v, w]) # A utility function to find set of an element i (uses path compression technique) def find(self, parent, i): return i if parent[i] == i else self.find(parent, parent[i]) # A function that does union of two sets of x and y (uses union by rank) def union(self, parent, rank, x, y): xroot = self.find(parent, x) yroot = self.find(parent, y) # Attach smaller rank tree under root of high rank tree (Union by Rank) if rank[xroot] \u003c rank[yroot]: parent[xroot] = yroot elif rank[xroot] \u003e rank[yroot]: parent[yroot] = xroot # If ranks are same, then make one as root and increment its rank by one else: parent[yroot] = xroot rank[xroot] += 1 # The main function to construct MST using Kruskal's algorithm def KruskalMST(self): result = [] # This will store the resultant MST i = 0 # An index variable, used for sorted edges e = 0 # An index variable, used for result[] # Step 1: Sort all the edges in non-decreasing order of their # weight. If we are not allowed to change the given graph, we can create a copy of graph self.graph = sorted(self.graph, key=lambda item: item[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(self.V): parent.append(node) rank.append(0) # Number of edges to be taken is equal to V-1 while e \u003c self.V - 1: # Step 2: Pick the smallest edge and increment the index for next iteration u, v, w = self.graph[i] i = i + 1 x = self.find(parent, u) y = self.find(parent, v) # If including this edge doesn't cause cycle, include it in result and increment the indexof # result for next edge if x != y: e += 1 result.append([u, v, w]) self.union(parent, rank, x, y) # Else discard the edge minimumCost = 0 print (\"Edges in the constructed MST\") for u, v, weight in result: minimumCost += weight print(\"%d -- %d == %d\" % (u, v, weight)) print(\"Minimum Spanning Tree\" , minimumCost) g = Graph(4) g.addEdge(0, 1, 10) g.addEdge(0, 2, 6) g.addEdge(0, 3, 5) g.addEdge(1, 3, 15) g.addEdge(2, 3, 4) g.KruskalMST() Implement Prim’s Algorithm # A Python program for Prim's Minimum Spanning Tree (MST) algorithm. # The program is for adjacency matrix representation of the graph import sys # Library for INT_MAX class Graph(): def __init__(self, vertices): self.V = vertices self.graph = [[0 for column in range(vertices)] for row in range(vertices)] # A utility function to print the constructed MST stored in parent[] def printMST(self, parent): print (\"Edge \\tWeight\") for i in range(1, self.V): print (parent[i], \"-\", i, \"\\t\", self.graph[i][parent[i]]) # A utility function to find the vertex with minimum distance value, from the set of vertices not yet included in shortest path tree def minKey(self, key, mstSet): # Initialize minValue value minValue = sys.maxsize for v in range(self.V): if key[v] \u003c minValue and mstSet[v] == False: minValue = key[v] min_index = v return min_index # Function to construct and print MST for a graph represented using adjacency matrix representation def primMST(self): # Key values used to pick minimum weight edge in cut key = [sys.maxsize] * self.V parent = [None] * self.V # Array to store constructed MST # Make key 0 so that this vertex is picked as first vertex key[0] = 0 mstSet = [False] * self.V parent[0] = -1 # First node is always the root of for cout in range(self.V): # Pick the minimum distance vertex from the set of vertices not yet processed. u is always equal to src in first iteration u = self.minKey(key, mstSet) # Put the minimum distance vertex in the shortest path tree mstSet[u] = True # Update dist value of the adjacent vertices of the picked vertex only if the current # distance is greater than new distance and the vertex in not in the shortest path tree for v in range(self.V): # graph[u][v] is non zero only for adjacent vertices of m mstSet[v] is false for vertices not yet included in MST # Update the key only if graph[u][v] is smaller than key[v] if self.graph[u][v] \u003e 0 and mstSet[v] == False and key[v] \u003e self.graph[u][v]: key[v] = self.graph[u][v] parent[v] = u self.printMST(parent) g = Graph(5) g.graph = [ [0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0]] g.primMST(); Total no. of Spanning tree in a graph TODO Implement Bellman Ford Algorithm \"\"\" We are given a directed graph. We need to compute whether the graph has a negative cycle or not. A negative cycle is one in which the overall sum of the cycle becomes negative. \"\"\" # a structure to represent a weighted edge in graph class Edge: def __init__(self): self.src = 0 self.dest = 0 self.weight = 0 # a structure to represent a connected, directed and weighted graph class Graph: def __init__(self): # V. Number of vertices, E. Number of edges self.V = 0 self.E = 0 # graph is represented as an array of edges. self.edge = None # Creates a graph with V vertices and E edges def createGraph(V, E): graph = Graph() graph.V = V; graph.E = E; graph.edge = [Edge() for _ in range(graph.E)] return graph; # The main function that finds shortest distances from src to all other vertices using Bellman- Ford algorithm. The function also detects negative weight cycle def isNegCycleBellmanFord(graph, src): V = graph.V; E = graph.E; dist = [1000000 for _ in range(V)]; dist[src] = 0; # Step 2: Relax all edges |V| - 1 times. # A simple shortest path from src to any other vertex can have at-most |V| - 1 edges for _ in range(1, V): for j in range(E): u = graph.edge[j].src; v = graph.edge[j].dest; weight = graph.edge[j].weight; if (dist[u] != 1000000 and dist[u] + weight \u003c dist[v]): dist[v] = dist[u] + weight; # Step 3: check for negative-weight cycles. # The above step guarantees shortest distances if graph doesn't contain negative weight cycle. # If we get a shorter path, then there is a cycle. for i in range(E): u = graph.edge[i].src; v = graph.edge[i].dest; weight = graph.edge[i].weight; if (dist[u] != 1000000 and dist[u] + weight \u003c dist[v]): return True; return False; # Let us create the graph given in above example V = 5; # Number of vertices in graph E = 8; # Number of edges in graph graph = createGraph(V, E) source= [0,0,1,1,1,3,3,4] destination= [1,2,2,3,4,2,1,3] weight=[-1,4,3,2,2,5,1,-3] for i in range(E): graph.edge[i].src=source[i] graph.edge[i].dest=destination[i] graph.edge[i].weight=weight[i] if (isNegCycleBellmanFord(graph, 0)): print(\"Yes\") else: print(\"No\") Implement Floyd warshallAlgorithm \"\"\" The Floyd Warshall Algorithm is for solving the All Pairs Shortest Path problem. The problem is to find shortest distances between every pair of vertices in a given edge weighted directed Graph. Example: Input: graph[][] = { {0, 5, INF, 10}, {INF, 0, 3, INF}, {INF, INF, 0, 1}, {INF, INF, INF, 0} } which represents the following graph 10 (0)-------\u003e(3) | /|\\ 5 | | | | 1 \\|/ | (1)-------\u003e(2) 3 Note that the value of graph[i][j] is 0 if i is equal to j And graph[i][j] is INF (infinite) if there is no edge from vertex i to j. Output: Shortest distance matrix 0 5 8 9 INF 0 3 4 INF INF 0 1 INF INF INF 0 \"\"\" def floydWarshall(graph): dist = list(map(lambda i: list(map(lambda j: j, i)), graph)) for k in range(V): # pick all vertices as source one by one for i in range(V): # Pick all vertices as destination for the above picked source for j in range(V): # If vertex k is on the shortest path from i to j, then update the value of dist[i][j] dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]) printSolution(dist) # A utility function to print the solution def printSolution(dist): print (\"Following matrix shows the shortest distances\\ between every pair of vertices\") for i in range(V): for j in range(V): if(dist[i][j] == INF): print (\"%7s\" % (\"INF\"),end=\" \") else: print (\"%7d\\t\" % (dist[i][j]),end=' ') if j == V-1: print () # Let us create the following weighted graph \"\"\" 10 (0)-------\u003e(3) |\t/|\\ 5 |\t| |\t| 1 \\|/\t| (1)-------\u003e(2) 3\t\"\"\" # Number of vertices in the graph V = 4 INF = 99999 graph = [[0, 5, INF, 10], [INF, 0, 3, INF], [INF, INF, 0, 1], [INF, INF, INF, 0] ] floydWarshall(graph) Travelling Salesman Problem \"\"\" Travelling Salesman Problem (TSP): Given a set of cities and the distance between every pair of cities, the problem is to find the shortest possible route that visits every city exactly once and returns to the starting point. \"\"\" n = 4 # there are four nodes in example graph (graph is 1-based) # dist[i][j] represents shortest distance to go from i to this matrix can be calculated for any given graph usin all-pair shortest path algorithms dist = [[0, 0, 0, 0, 0], [0, 0, 10, 15, 20], [ 0, 10, 0, 25, 25], [0, 15, 25, 0, 30], [0, 20, 25, 30, 0]] # memoization for top down recursion memo = [[-1]*(1 \u003c\u003c (n+1)) for _ in range(n+1)] def fun(i, mask): # base case # if only ith bit and 1st bit is set in our mask, it implies we have visited all other nodes already if mask == ((1 \u003c\u003c i) | 3): return dist[1][i] # memoization if memo[i][mask] != -1: return memo[i][mask] res = 10**9 # result of this sub-problem # we have to travel all nodes j in mask and end the path at ith node so for every node j in mask, recursively calculate cost of travelling all nodes in mask except i and then travel back from node j to node i taking # the shortest path take the minimum of all possible j nodes for j in range(1, n+1): if (mask \u0026 (1 \u003c\u003c j)) != 0 and j != i and j != 1: res = min(res, fun(j, mask \u0026 (~(1 \u003c\u003c i))) + dist[j][i]) memo[i][mask] = res # storing the minimum value return res ans = 10**9 for i in range(1, n+1): # try to go from node 1 visiting all nodes in between to i then return from i taking the shortest route to 1 ans = min(ans, fun(i, (1 \u003c\u003c (n+1))-1) + dist[i][1]) print(f\"The cost of most efficient tour = {str(ans)}\") Graph ColouringProblem TODO Snake and Ladders Problem \"\"\" On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: You start on square 1 of the board (which is always in the last row and first column). Each move, starting from square x, consists of the following: You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is \u003c= N*N. (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.) If S has a snake or ladder, you move to the destination of that snake or ladder. Otherwise, you move to S. A board square on row r and column c has a “snake or ladder” if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving. (For example, if the board is [[4,-1],[-1,3]], and on the first move your destination square is 2, then you finish your first move at 3, because you do not continue moving to 4.) Return the least number of moves required to reach square N*N. If it is not possible, return -1. \"\"\" import collections def snakesAndLadders(board): rows = len(board) total_square = rows*rows def next_square(step): quot, rem = divmod(step-1, rows) row = (rows - 1) - quot col = rem if row%2 != rows%2 else (rows - 1) - rem return row, col dist = {1: 0}#square and step queue = collections.deque([1]) while queue: square = queue.popleft() if square == total_square: return dist[square] for new_square in range(square+1, min(square+6, total_square) + 1): r, c = next_square(new_square) if board[r][c] != -1: new_square = board[r][c] if new_square not in dist: dist[new_square] = dist[square] + 1 queue.append(new_square) board=[ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] print(snakesAndLadders(board)) Find bridge in a graph from collections import defaultdict #This class represents an undirected graph using adjacency list representation class Graph: def __init__(self,vertices): self.V= vertices #No. of vertices self.graph = defaultdict(list) # default dictionary to store graph self.Time = 0 # function to add an edge to graph def addEdge(self,u,v): self.graph[u].append(v) self.graph[v].append(u) ''' A recursive function that finds and prints bridges using DFS traversal u --\u003e The vertex to be visited next visited[] --\u003e keeps track of visited vertices disc[] --\u003e Stores discovery times of visited vertices parent[] --\u003e Stores parent vertices in DFS tree ''' def bridgeUtil(self, u, visited, parent, low, disc): # Mark the current node as visited and print it visited[u]= True # Initialize discovery time and low value disc[u] = self.Time low[u] = self.Time self.Time += 1 #Recur for all the vertices adjacent to this vertex for v in self.graph[u]: # If v is not visited yet, then make it a child of u in DFS tree and recur for it if visited[v] == False : parent[v] = u self.bridgeUtil(v, visited, parent, low, disc) # Check if the subtree rooted with v has a connection to one of the ancestors of u low[u] = min(low[u], low[v]) ''' If the lowest vertex reachable from subtree under v is below u in DFS tree, then u-v is a bridge''' if low[v] \u003e disc[u]: print (\"%d %d\" %(u,v)) elif v != parent[u]: # Update low value of u for parent function calls. low[u] = min(low[u], disc[v]) # DFS based function to find all bridges. It uses recursive function bridgeUtil() def bridge(self): # Mark all the vertices as not visited and Initialize parent and visited, and ap(articulation point) arrays visited = [False] * (self.V) disc = [float(\"Inf\")] * (self.V) low = [float(\"Inf\")] * (self.V) parent = [-1] * (self.V) # Call the recursive helper function to find bridges in DFS tree rooted with vertex 'i' for i in range(self.V): if visited[i] == False: self.bridgeUtil(i, visited, parent, low, disc) g1 = Graph(5) g1.addEdge(1, 0) g1.addEdge(0, 2) g1.addEdge(2, 1) g1.addEdge(0, 3) g1.addEdge(3, 4) print (\"Bridges in first graph \") g1.bridge() g2 = Graph(4) g2.addEdge(0, 1) g2.addEdge(1, 2) g2.addEdge(2, 3) print (\"\\nBridges in second graph \") g2.bridge() g3 = Graph (7) g3.addEdge(0, 1) g3.addEdge(1, 2) g3.addEdge(2, 0) g3.addEdge(1, 3) g3.addEdge(1, 4) g3.addEdge(1, 6) g3.addEdge(3, 5) g3.addEdge(4, 5) print (\"\\nBridges in third graph \") g3.bridge() Count Strongly connected Components(Kosaraju Algo) from collections import defaultdict class Graph: def __init__(self,vertices): self.V= vertices self.graph = defaultdict(list) def addEdge(self,u,v): self.graph[u].append(v) # A function used by DFS def DFSUtil(self,v,visited): # Mark the current node as visited and print it visited[v]= True print (v) #Recur for all the vertices adjacent to this vertex for i in self.graph[v]: if visited[i]==False: self.DFSUtil(i,visited) def fillOrder(self,v,visited, stack): # Mark the current node as visited visited[v]= True #Recur for all the vertices adjacent to this vertex for i in self.graph[v]: if visited[i]==False: self.fillOrder(i, visited, stack) stack = stack.append(v) # Function that returns reverse (or transpose) of this graph def getTranspose(self): g = Graph(self.V) # Recur for all the vertices adjacent to this vertex for i in self.graph: for j in self.graph[i]: g.addEdge(j,i) return g # The main function that finds and prints all strongly connected components def printSCCs(self): stack = [] # Mark all the vertices as not visited (For first DFS) visited =[False]*(self.V) # Fill vertices in stack according to their finishing times for i in range(self.V): if visited[i]==False: self.fillOrder(i, visited, stack) # Create a reversed graph gr = self.getTranspose() # Mark all the vertices as not visited (For second DFS) visited =[False]*(self.V) # Now process all vertices in order defined by Stack while stack: i = stack.pop() if visited[i]==False: gr.DFSUtil(i, visited) print() # Create a graph given in the above diagram g = Graph(5) g.addEdge(1, 0) g.addEdge(0, 2) g.addEdge(2, 1) g.addEdge(0, 3) g.addEdge(3, 4) print (\"Following are strongly connected components \" + \"in given graph\") g.printSCCs() Check whether a graph is Bipartite or Not V = 4 def colorGraph(G, color, pos, c): if color[pos] not in [-1, c]: return False # color this pos as c and all its neighbours and 1-c color[pos] = c ans = True for i in range(V): if G[pos][i]: if color[i] == -1: ans \u0026= colorGraph(G, color, i, 1-c) if color[i] not in [-1, 1 - c]: return False if not ans: return False return True def isBipartite(G): color = [-1] * V #start is vertex 0 pos = 0 # two colors 1 and 0 return colorGraph(G, color, pos, 1) G = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]] if isBipartite(G): print(\"Yes\") else: print(\"No\") Longest path in a Directed Acyclic Graph def topologicalSortUtil(v): global Stack, visited, adj visited[v] = True for i in adj[v]: if (not visited[i[0]]): topologicalSortUtil(i[0]) Stack.append(v) # The function to find longest distances from a given vertex. It uses recursive topologicalSortUtil() to get topological sorting. def longestPath(s): global Stack, visited, adj, V dist = [-10**9 for _ in range(V)] # Call the recursive helper function to store Topological Sort starting from all vertices one by one for i in range(V): if (visited[i] == False): topologicalSortUtil(i) # Initialize distances to all vertices as infinite and distance to source as 0 dist[s] = 0 # Process vertices in topological order while (len(Stack) \u003e 0): # Get the next vertex from topological order u = Stack[-1] del Stack[-1] # Update distances of all adjacent vertices if (dist[u] != 10**9): for i in adj[u]: if (dist[i[0]] \u003c dist[u] + i[1]): dist[i[0]] = dist[u] + i[1] # Print calculated longest distances print(dist) for i in range(V): print(\"INF \",end=\"\") if (dist[i] == -10**9) else print(dist[i],end=\" \") V, Stack, visited = 6, [], [False for _ in range(7)] adj = [[] for _ in range(7)] # Create a graph given in the above diagram. # Here vertex numbers are 0, 1, 2, 3, 4, 5 with following mappings: # 0=r, 1=s, 2=t, 3=x, 4=y, 5=z adj[0].append([1, 5]) adj[0].append([2, 3]) adj[1].append([3, 6]) adj[1].append([2, 2]) adj[2].append([4, 4]) adj[2].append([5, 2]) adj[2].append([3, 7]) adj[3].append([5, 1]) adj[3].append([4, -1]) adj[4].append([5, -2]) s = 1 print(\"Following are longest distances from source vertex \",s) longestPath(s) Journey to the Moon TODO Cheapest Flights Within K Stops TODO Oliver and the Game TODO Water Jug problem using BFS \"\"\" You are given an m liter jug and a n liter jug. Both the jugs are initially empty. The jugs don’t have markings to allow measuring smaller quantities. You have to use the jugs to measure d liters of water where d is less than n. (X, Y) corresponds to a state where X refers to the amount of water in Jug1 and Y refers to the amount of water in Jug2 Determine the path from the initial state (xi, yi) to the final state (xf, yf), where (xi, yi) is (0, 0) which indicates both Jugs are initially empty and (xf, yf) indicates a state which could be (0, d) or (d, 0). The operations you can perform are: Empty a Jug, (X, Y)-\u003e(0, Y) Empty Jug 1 Fill a Jug, (0, 0)-\u003e(X, 0) Fill Jug 1 Pour water from one jug to the other until one of the jugs is either empty or full, (X, Y) -\u003e (X-d, Y+d) Examples: Input : 4 3 2 Output : {(0, 0), (0, 3), (3, 0), (3, 3), (4, 2), (0, 2)} \"\"\" from collections import deque def BFS(a, b, target): # Map is used to store the states, every state is hashed to binary value to indicate either that state is visited before or not m = {} isSolvable = False path = [] # Queue to maintain states q = deque() # Initialing with initial state q.append((0, 0)) while (len(q) \u003e 0): # Current state u = q.popleft() #q.pop() #pop off used state # If this state is already visited if ((u[0], u[1]) in m): continue # Doesn't met jug constraints if ((u[0] \u003e a or u[1] \u003e b or u[0] \u003c 0 or u[1] \u003c 0)): continue # Filling the vector for constructing the solution path path.append([u[0], u[1]]) # Marking current state as visited m[(u[0], u[1])] = 1 # If we reach solution state, put ans=1 if (u[0] == target or u[1] == target): isSolvable = True if (u[0] == target): if (u[1] != 0): # Fill final state path.append([u[0], 0]) else: if (u[0] != 0): # Fill final state path.append([0, u[1]]) # Print the solution path sz = len(path) for i in range(sz): print(\"(\", path[i][0], \",\", path[i][1], \")\") break # If we have not reached final state then, start developing intermediate states to reach solution state q.append([u[0], b]) # Fill Jug2 q.append([a, u[1]]) # Fill Jug1 for ap in range(max(a, b) + 1): # Pour amount ap from Jug2 to Jug1 c = u[0] + ap d = u[1] - ap # Check if this state is possible or not if (c == a or (d == 0 and d \u003e= 0)): q.append([c, d]) # Pour amount ap from Jug 1 to Jug2 c = u[0] - ap d = u[1] + ap # Check if this state is possible or not if ((c == 0 and c \u003e= 0) or d == b): q.append([c, d]) # Empty Jug2 q.append([a, 0]) # Empty Jug1 q.append([0, b]) # No, solution exists if ans=0 if (not isSolvable): print (\"No solution\") Jug1, Jug2, target = 4, 3, 2 print(\"Path from initial state to solution state ::\") BFS(Jug1, Jug2, target) Find if there is a path of more thank length from a source \"\"\" Given a graph, a source vertex in the graph and a number k, find if there is a simple path (without any cycle) starting from given source and ending at any other vertex such that the distance from source to that vertex is atleast ‘k’ length. Example: Input : Source s = 0, k = 58 Output : True There exists a simple path 0 -\u003e 7 -\u003e 1 -\u003e 2 -\u003e 8 -\u003e 6 -\u003e 5 -\u003e 3 -\u003e 4 Which has a total distance of 60 km which is more than 58. Input : Source s = 0, k = 62 Output : False In the above graph, the longest simple path has distance 61 (0 -\u003e 7 -\u003e 1-\u003e 2 -\u003e 3 -\u003e 4 -\u003e 5-\u003e 6 -\u003e 8, so output should be false for any input greater than 61. \"\"\" # Program to find if there is a simple path with # weight more than k # This class represents a dipathted graph using # adjacency list representation class Graph: # Allocates memory for adjacency list def __init__(self, V): self.V = V self.adj = [[] for _ in range(V)] # Returns true if graph has path more than k length def pathMoreThanK(self,src, k): # Create a path array with nothing included in path path = [False]*self.V # Add source vertex to path path[src] = 1 return self.pathMoreThanKUtil(src, k, path) # Prints shortest paths from src to all other vertices def pathMoreThanKUtil(self,src, k, path): # If k is 0 or negative, return true if (k \u003c= 0): return True # Get all adjacent vertices of source vertex src and recursively explore all paths from src. i = 0 while i != len(self.adj[src]): # Get adjacent vertex and weight of edge v = self.adj[src][i][0] w = self.adj[src][i][1] i += 1 # If vertex v is already there in path, then there is a cycle (we ignore this edge) if (path[v] == True): continue # If weight of is more than k, return true if (w \u003e= k): return True # Else add this vertex to path path[v] = True # If this adjacent can provide a path longer than k, return true. if (self.pathMoreThanKUtil(v, k-w, path)): return True # Backtrack path[v] = False # If no adjacent could produce longer path, return false return False # Utility function to an edge (u, v) of weight w def addEdge(self,u, v, w): self.adj[u].append([v, w]) self.adj[v].append([u, w]) # create the graph given in above figure V = 9 g = Graph(V) # making above shown graph g.addEdge(0, 1, 4) g.addEdge(0, 7, 8) g.addEdge(1, 2, 8) g.addEdge(1, 7, 11) g.addEdge(2, 3, 7) g.addEdge(2, 8, 2) g.addEdge(2, 5, 4) g.addEdge(3, 4, 9) g.addEdge(3, 5, 14) g.addEdge(4, 5, 10) g.addEdge(5, 6, 2) g.addEdge(6, 7, 1) g.addEdge(6, 8, 6) g.addEdge(7, 8, 7) src = 0 k = 62 if g.pathMoreThanK(src, k): print(\"Yes\") else: print(\"No\") k = 60 if g.pathMoreThanK(src, k): print(\"Yes\") else: print(\"No\") Minimum edges to reverse o make path from source to destination \"\"\" Given a directed graph and a source node and destination node, we need to find how many edges we need to reverse in order to make at least 1 path from the source node to the destination node. \"\"\" def addEdge(u, v, w): global adj adj[u].append((v, w)) def shortestPath(src): # Create a set to store vertices that are being preprocessed setds = {} # Create a vector for distances and initialize all distances as infinite (INF) dist = [10**18 for _ in range(V)] # Insert source itself in Set and initialize its global adj setds[(0, src)] = 1 dist[src] = 0 while setds: # The first vertex in Set is the minimum distance vertex, extract it from set. tmp = list(setds.keys())[0] del setds[tmp] # vertex label is stored in second of pair (it has to be done this way to keep the vertices sorted distance (distance must be first item in pair) u = tmp[1] # 'i' is used to get all adjacent vertices of a vertex # list\u003c pair \u003e::iterator i; for i in adj[u]: # Get vertex label and weight of current adjacent # of u. v = i[0]; weight = i[1] # If there is shorter path to v through u. if (dist[v] \u003e dist[u] + weight): # /* If distance of v is not INF then it must be in #\tour set, so removing it and inserting again #\twith updated less distance. #\tNote : We extract only those vertices from Set #\tfor which distance is finalized. So for them, #\twe would never reach here. */ if (dist[v] != 10**18): del setds[(dist[v], v)] # Updating distance of v dist[v] = dist[u] + weight setds[(dist[v], v)] = 1 return dist # method adds reverse edge of each original edge in the graph. It gives reverse edge a weight = 1 and all original edges a weight of 0. Now, the length of the shortest path will give us the answer. If shortest path is p: it means we used p reverse edges in the shortest path. def modelGraphWithEdgeWeight(edge, E, V): global adj for i in range(E): addEdge(edge[i][0], edge[i][1], 0) # original edge : weight 0 addEdge(edge[i][1], edge[i][0], 1) # reverse edge : weight 1 # Method returns minimum number of edges to be reversed to reach from src to dest def getMinEdgeReversal(edge, E, V,src, dest): # get modified graph with edge weight modelGraphWithEdgeWeight(edge, E, V) # get shortes path vector dist = shortestPath(src) # If distance of destination is still INF, not possible return -1 if (dist[dest] == 10**18) else dist[dest] V = 7 edge = [[0, 1], [2, 1], [2, 3], [5, 1],[4, 5], [6, 4], [6, 3]] E, adj = len(edge), [[] for _ in range(V + 1)] minEdgeToReverse = getMinEdgeReversal(edge, E, V, 0, 6) if (minEdgeToReverse != -1): print(minEdgeToReverse) else: print(\"Not possible\") Paths to travel each nodes using each edge(Seven Bridges) TODO Vertex Cover Problem \"\"\" There are n nodes and m bridges in between these nodes. Print the possible path through each node using each edges (if possible), traveling through each edges only once. \"\"\" from collections import defaultdict class Graph: def __init__(self, vertices): self.V = vertices self.graph = defaultdict(list) def addEdge(self, u, v): self.graph[u].append(v) def printVertexCover(self): # Initialize all vertices as not visited. visited = [False] * (self.V) # Consider all edges one by one for u in range(self.V): # An edge is only picked when both visited[u] and visited[v] are false if not visited[u]: # Go through all adjacents of u and pick the first not yet visited # vertex (We are basically picking an edge (u, v) from remaining edges. for v in self.graph[u]: if not visited[v]: # Add the vertices (u, v) to the # result set. We make the vertex u and v visited so that all # edges from/to them would be ignored visited[v] = True visited[u] = True break # Print the vertex cover for j in range(self.V): if visited[j]: print(j, end = ' ') print() g = Graph(7) g.addEdge(0, 1) g.addEdge(0, 2) g.addEdge(1, 3) g.addEdge(3, 4) g.addEdge(4, 5) g.addEdge(5, 6) g.printVertexCover() Chinese Postman or Route Inspection TODO Number of Triangles in a Directed and Undirected Graph \"\"\" Given a Graph, count number of triangles in it. The graph is can be directed or undirected. Example: Input: digraph[V][V] = { {0, 0, 1, 0}, {1, 0, 0, 1}, {0, 1, 0, 0}, {0, 0, 1, 0} }; Output: 2 Give adjacency matrix represents following directed graph. \"\"\" # function to calculate the number of triangles in a simple directed/undirected graph. # isDirected is true if the graph is directed, its false otherwise def countTriangle(g, isDirected): nodes = len(g) count_Triangle = 0 # Consider every possible triplet of edges in graph for i in range(nodes): for j in range(nodes): for k in range(nodes): # check the triplet if it satisfies the condition if(i != j and i != k and j != k and g[i][j] and g[j][k] and g[k][i]): count_Triangle += 1 # If graph is directed , division is done by 3 else division by 6 is done if isDirected: return (count_Triangle//3) else: return (count_Triangle//6) # Create adjacency matrix of an undirected graph graph = [[0, 1, 1, 0], [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 1, 0]] # Create adjacency matrix of a directed graph digraph = [[0, 0, 1, 0], [1, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0]] print(\"The Number of triangles in undirected graph : %d\" % countTriangle(graph, False)) print(\"The Number of triangles in directed graph : %d\" % countTriangle(digraph, True)) Minimise the cashflow among a given set of friends who have borrowed money from each other \"\"\" Given a number of friends who have to give or take some amount of money from one another. Design an algorithm by which the total cash flow among all the friends is minimized. \"\"\" # Number of persons(or vertices in graph) N = 3 # A utility function that returns index of minimum value in arr[] def getMin(arr): minInd = 0 for i in range(1, N): if (arr[i] \u003c arr[minInd]): minInd = i return minInd # A utility function that returns index of maximum value in arr[] def getMax(arr): maxInd = 0 for i in range(1, N): if (arr[i] \u003e arr[maxInd]): maxInd = i return maxInd def minOf2(x, y): return x if x \u003c y else y # amount[p] indicates the net amount to be credited/debited to/from person 'p' If amount[p] is positive, then i'th person will amount[i] If amount[p] is negative, then i'th person will give -amount[i] def minCashFlowRec(amount): # Find the indexes of minimum and maximum values in amount[] amount[mxCredit] indicates the maximum amount to be given(or credited) to any person. And amount[mxDebit] indicates the maximum amount to be taken (or debited) from any person. So if there is a positive value in amount[], then there must be a negative value mxCredit = getMax(amount) mxDebit = getMin(amount) # If both amounts are 0, then all amounts are settled if (amount[mxCredit] == 0 and amount[mxDebit] == 0): return 0 # Find the minimum of two amounts min = minOf2(-amount[mxDebit], amount[mxCredit]) amount[mxCredit] -=min amount[mxDebit] += min # If minimum is the maximum amount to be print(\"Person \" , mxDebit , \" pays \" , min , \" to \" , \"Person \" , mxCredit) # Recur for the amount array. Note that it is guaranteed that the recursion would terminate as either amount[mxCredit] or amount[mxDebit] becomes 0 minCashFlowRec(amount) # Given a set of persons as graph[] where graph[i][j] indicates the amount that person i needs to pay person j, this function finds and prints the minimum cash flow to settle all debts. def minCashFlow(graph): # Create an array amount[], initialize all value in it as 0. amount = [0 for _ in range(N)] # Calculate the net amount to be paid to person 'p', and stores it in amount[p]. The value of amount[p] can be calculated by subtracting debts of 'p' from credits of 'p' for p in range(N): for i in range(N): amount[p] += (graph[i][p] - graph[p][i]) minCashFlowRec(amount) # graph[i][j] indicates the amount that person i needs to pay person j graph = [ [0, 1000, 2000], [0, 0, 5000], [0, 0, 0] ] minCashFlow(graph) Two Clique Problem \"\"\" A Clique is a subgraph of graph such that all vertices in subgraph are completely connected with each other. Given a Graph, find if it can be divided into two Cliques. Examples: Input : G[][] = {{0, 1, 1, 0, 0}, {1, 0, 1, 1, 0}, {1, 1, 0, 0, 0}, {0, 1, 0, 0, 1}, {0, 0, 0, 1, 0}}; Output : Yes \"\"\" from queue import Queue # This function returns true if subgraph reachable from src is Bipartite or not. def isBipartiteUtil(G, src, colorArr): global V colorArr[src] = 1 # Create a queue (FIFO) of vertex numbers and enqueue source vertex for BFS traversal q = Queue() q.put(src) # Run while there are vertices in queue (Similar to BFS) while (not q.empty()): # Dequeue a vertex from queue u = q.get() # Find all non-colored adjacent vertices for v in range(V): # An edge from u to v exists and destination v is not colored if (G[u][v] and colorArr[v] == -1): # Assign alternate color to this adjacent v of u colorArr[v] = 1 - colorArr[u] q.put(v) # An edge from u to v exists and destination v is colored with same color as u elif (G[u][v] and colorArr[v] == colorArr[u]): return False # If we reach here, then all adjacent vertices can be colored with alternate color return True # Returns true if a Graph G[][] is Bipartite or Note that G may not be connected. def isBipartite(G): global V # Create a color array to store colors assigned to all vertices. Vertex number is used as index in this array. The value '-1' of colorArr[i] is used to indicate that no color is assigned to vertex 'i'. The value 1 is used to indicate first color is assigned and value 0 indicates second color is assigned. colorArr = [-1] * V # One by one check all not yet colored vertices. for i in range(V): if (colorArr[i] == -1): if (isBipartiteUtil(G, i, colorArr) == False): return False return True # Returns true if G can be divided into # two Cliques, else false. def canBeDividedinTwoCliques(G): global V # Find complement of G[][] All values are complemented except diagonal ones GC = [[None] * V for _ in range(V)] for i in range(V): for j in range(V): GC[i][j] = not G[i][j] if i != j else 0 # Return true if complement is Bipartite else false. return isBipartite(GC) V = 5 G = [[0, 1, 1, 1, 0], [1, 0, 1, 0, 0], [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 0]] if canBeDividedinTwoCliques(G): print(\"Yes\") else: print(\"No\") ",
  "wordCount" : "10878",
  "inLanguage": "en",
  "image":"https://atharvashah.netlify.app/blog/dsa/graph.jpg","datePublished": "2022-07-09T13:14:34+05:30",
  "dateModified": "2022-07-09T13:14:34+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://atharvashah.netlify.app/blog/dsapython/graph/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Atharva Shah",
    "logo": {
      "@type": "ImageObject",
      "url": "https://atharvashah.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://atharvashah.netlify.app/" accesskey="h" title="Atharva Shah (Alt + H)">
                <img src="https://atharvashah.netlify.app/profile/header_button.gif" alt="" aria-label="logo"
                    height="30">Atharva Shah</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://atharvashah.netlify.app/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://atharvashah.netlify.app/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://atharvashah.netlify.app/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://atharvashah.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://atharvashah.netlify.app/blog/">Blogs</a></div>
    <h1 class="post-title">
      DSA in Python - Graph
    </h1>
    <div class="post-meta"><span title='2022-07-09 13:14:34 +0530 IST'>July 9, 2022</span>&nbsp;·&nbsp;52 min&nbsp;·&nbsp;10878 words

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://atharvashah.netlify.app/blog/dsa/graph.jpg" alt="Graph">
        <p>Learn Graph Algorithms in Python</p>
</figure>
  <div class="post-content"><ul>
<li><a href="#implement-graph">Implement Graph</a></li>
<li><a href="#implement-weighted-graph">Implement Weighted Graph</a></li>
<li><a href="#implement-bfs-algorithm">Implement BFS algorithm</a></li>
<li><a href="#implement-dfs-algo">Implement DFS Algo</a></li>
<li><a href="#detect-cycle-in-directed-graph-using-bfsdfs-algo">Detect Cycle in Directed Graph using BFS/DFS Algo</a></li>
<li><a href="#detect-cycle-in-undirected-graph-using-bfsdfs-algo">Detect Cycle in UnDirected Graph using BFS/DFS Algo</a></li>
<li><a href="#minimum-step-by-knight">Minimum Step by Knight</a></li>
<li><a href="#flood-fill-algo">flood fill algo</a></li>
<li><a href="#clone-a-graph">Clone a graph</a></li>
<li><a href="#making-wired-connections">Making wired Connections</a></li>
<li><a href="#word-ladder">word Ladder</a></li>
<li><a href="#dijkstra-algo">Dijkstra algo</a></li>
<li><a href="#implement-topological-sort">Implement Topological Sort</a></li>
<li><a href="#minimum-time-taken-by-each-job-to-be-completed-given-by-a-directed-acyclic-graph">Minimum time taken by each job to be completed given by a Directed Acyclic Graph</a></li>
<li><a href="#find-whether-it-is-possible-to-finish-all-tasks-or-not-from-given-dependencies">Find whether it is possible to finish all tasks or not from given dependencies</a></li>
<li><a href="#find-the-no-of-islands">Find the no. of Islands</a></li>
<li><a href="#given-a-sorted-dictionary-of-an-alien-language-find-order-of-characters">Given a sorted Dictionary of an Alien Language, find order of characters</a></li>
<li><a href="#implement-kruksalsalgorithm">Implement Kruksal’sAlgorithm</a></li>
<li><a href="#implement-prims-algorithm">Implement Prim’s Algorithm</a></li>
<li><a href="#total-no-of-spanning-tree-in-a-graph">Total no. of Spanning tree in a graph</a></li>
<li><a href="#implement-bellman-ford-algorithm">Implement Bellman Ford Algorithm</a></li>
<li><a href="#implement-floyd-warshallalgorithm">Implement Floyd warshallAlgorithm</a></li>
<li><a href="#travelling-salesman-problem">Travelling Salesman Problem</a></li>
<li><a href="#graph-colouringproblem">Graph ColouringProblem</a></li>
<li><a href="#snake-and-ladders-problem">Snake and Ladders Problem</a></li>
<li><a href="#find-bridge-in-a-graph">Find bridge in a graph</a></li>
<li><a href="#count-strongly-connected-componentskosaraju-algo">Count Strongly connected Components(Kosaraju Algo)</a></li>
<li><a href="#check-whether-a-graph-is-bipartite-or-not">Check whether a graph is Bipartite or Not</a></li>
<li><a href="#longest-path-in-a-directed-acyclic-graph">Longest path in a Directed Acyclic Graph</a></li>
<li><a href="#journey-to-the-moon">Journey to the Moon</a></li>
<li><a href="#cheapest-flights-within-k-stops">Cheapest Flights Within K Stops</a></li>
<li><a href="#oliver-and-the-game">Oliver and the Game</a></li>
<li><a href="#water-jug-problem-using-bfs">Water Jug problem using BFS</a></li>
<li><a href="#find-if-there-is-a-path-of-more-thank-length-from-a-source">Find if there is a path of more thank length from a source</a></li>
<li><a href="#minimum-edges-to-reverse-o-make-path-from-source-to-destination">Minimum edges to reverse o make path from source to destination</a></li>
<li><a href="#paths-to-travel-each-nodes-using-each-edgeseven-bridges">Paths to travel each nodes using each edge(Seven Bridges)</a></li>
<li><a href="#vertex-cover-problem">Vertex Cover Problem</a></li>
<li><a href="#chinese-postman-or-route-inspection">Chinese Postman or Route Inspection</a></li>
<li><a href="#number-of-triangles-in-a-directed-and-undirected-graph">Number of Triangles in a Directed and Undirected Graph</a></li>
<li><a href="#minimise-the-cashflow-among-a-given-set-of-friends-who-have-borrowed-money-from-each-other">Minimise the cashflow among a given set of friends who have borrowed money from each other</a></li>
<li><a href="#two-clique-problem">Two Clique Problem</a></li>
</ul>
<h2 id="implement-graph">Implement Graph<a hidden class="anchor" aria-hidden="true" href="#implement-graph">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, edges, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>adjList <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (src, dest) <span style="color:#f92672">in</span> edges:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[src]<span style="color:#f92672">.</span>append(dest)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printGraph</span>(graph):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> src <span style="color:#f92672">in</span> range(len(graph<span style="color:#f92672">.</span>adjList)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> dest <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adjList[src]:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;(</span><span style="color:#e6db74">{</span>src<span style="color:#e6db74">}</span><span style="color:#e6db74"> —&gt; </span><span style="color:#e6db74">{</span>dest<span style="color:#e6db74">}</span><span style="color:#e6db74">) &#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>        print()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>edges <span style="color:#f92672">=</span> [(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>), (<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>)]
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> Graph(edges, n)
</span></span><span style="display:flex;"><span>printGraph(graph)
</span></span></code></pre></div><h2 id="implement-weighted-graph">Implement Weighted Graph<a hidden class="anchor" aria-hidden="true" href="#implement-weighted-graph">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, edges, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>adjList <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[i] <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (src, dest, weight) <span style="color:#f92672">in</span> edges:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[src]<span style="color:#f92672">.</span>append((dest, weight))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printGraph</span>(graph):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> src <span style="color:#f92672">in</span> range(len(graph<span style="color:#f92672">.</span>adjList)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (dest, weight) <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adjList[src]:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;(</span><span style="color:#e6db74">{</span>src<span style="color:#e6db74">}</span><span style="color:#e6db74"> —&gt; </span><span style="color:#e6db74">{</span>dest<span style="color:#e6db74">}</span><span style="color:#e6db74">, </span><span style="color:#e6db74">{</span>weight<span style="color:#e6db74">}</span><span style="color:#e6db74">) &#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>        print()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Input: Edges in a weighted digraph (as per the above diagram)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Edge (x, y, w) represents an edge from `x` to `y` having weight `w`</span>
</span></span><span style="display:flex;"><span>edges <span style="color:#f92672">=</span> [(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>),
</span></span><span style="display:flex;"><span>        (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>), (<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>)]
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> Graph(edges, n)
</span></span><span style="display:flex;"><span>printGraph(graph)
</span></span></code></pre></div><h2 id="implement-bfs-algorithm">Implement BFS algorithm<a hidden class="anchor" aria-hidden="true" href="#implement-bfs-algorithm">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, edges, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>adjList <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (src, dest) <span style="color:#f92672">in</span> edges:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[src]<span style="color:#f92672">.</span>append(dest)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[dest]<span style="color:#f92672">.</span>append(src)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">BFS</span>(graph, v, discovered):
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> deque()
</span></span><span style="display:flex;"><span>    discovered[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    q<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> q:
</span></span><span style="display:flex;"><span>        v <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>        print(v, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> u <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adjList[v]:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[u]:
</span></span><span style="display:flex;"><span>                discovered[u] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>                q<span style="color:#f92672">.</span>append(u)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>edges <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>), (<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">9</span>),
</span></span><span style="display:flex;"><span>    (<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>), (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>), (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>), (<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>), (<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># vertex 0, 13, and 14 are single nodes</span>
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> Graph(edges, n)
</span></span><span style="display:flex;"><span>discovered <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[i]:
</span></span><span style="display:flex;"><span>        BFS(graph, i, discovered)
</span></span></code></pre></div><h2 id="implement-dfs-algo">Implement DFS Algo<a hidden class="anchor" aria-hidden="true" href="#implement-dfs-algo">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, edges, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>adjList <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (src, dest) <span style="color:#f92672">in</span> edges:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[src]<span style="color:#f92672">.</span>append(dest)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[dest]<span style="color:#f92672">.</span>append(src)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">iterativeDFS</span>(graph, v, discovered):
</span></span><span style="display:flex;"><span>    stack <span style="color:#f92672">=</span> deque()
</span></span><span style="display:flex;"><span>    stack<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> stack:
</span></span><span style="display:flex;"><span>        v <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> discovered[v]:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        discovered[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        print(v, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>        adjList <span style="color:#f92672">=</span> graph<span style="color:#f92672">.</span>adjList[v]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> reversed(range(len(adjList))):
</span></span><span style="display:flex;"><span>            u <span style="color:#f92672">=</span> adjList[i]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[u]:
</span></span><span style="display:flex;"><span>                stack<span style="color:#f92672">.</span>append(u)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>edges <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Notice that node 0 is unconnected</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>),
</span></span><span style="display:flex;"><span>    (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>), (<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>), (<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>), (<span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">10</span>), (<span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">11</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># (6, 9) introduces a cycle</span>
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> Graph(edges, n)
</span></span><span style="display:flex;"><span>discovered <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[i]:
</span></span><span style="display:flex;"><span>        iterativeDFS(graph, i, discovered)
</span></span></code></pre></div><h2 id="detect-cycle-in-directed-graph-using-bfsdfs-algo">Detect Cycle in Directed Graph using BFS/DFS Algo<a hidden class="anchor" aria-hidden="true" href="#detect-cycle-in-directed-graph-using-bfsdfs-algo">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, edges, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>adjList <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (src, dest) <span style="color:#f92672">in</span> edges:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[src]<span style="color:#f92672">.</span>append(dest)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Perform DFS on the graph and set the departure time of all vertices of the graph</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">DFS</span>(graph, v, discovered, departure, time):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># mark the current node as discovered</span>
</span></span><span style="display:flex;"><span>    discovered[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># do for every edge (v, u)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> u <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adjList[v]:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if `u` is not yet discovered</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[u]:
</span></span><span style="display:flex;"><span>            time <span style="color:#f92672">=</span> DFS(graph, u, discovered, departure, time)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ready to backtrack set departure time of vertex `v`</span>
</span></span><span style="display:flex;"><span>    departure[v] <span style="color:#f92672">=</span> time
</span></span><span style="display:flex;"><span>    time <span style="color:#f92672">=</span> time <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> time
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Returns true if the given directed graph is DAG</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isDAG</span>(graph, n):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># keep track of whether a vertex is discovered or not</span>
</span></span><span style="display:flex;"><span>    discovered <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># keep track of the departure time of a vertex in DFS</span>
</span></span><span style="display:flex;"><span>    departure <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Perform DFS traversal from all undiscovered vertices to visit all connected components of a graph</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[i]:
</span></span><span style="display:flex;"><span>            time <span style="color:#f92672">=</span> DFS(graph, i, discovered, departure, time)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># check if the given directed graph is DAG or not</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> u <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># check if (u, v) forms a back-edge.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adjList[u]:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># If the departure time of vertex `v` is greater than equal</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># to the departure time of `u`, they form a back edge.</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Note that `departure[u]` will be equal to `departure[v]`</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># only if `u = v`, i.e., vertex contain an edge to itself</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> departure[u] <span style="color:#f92672">&lt;=</span> departure[v]:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># no back edges</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># List of graph edges as per the above diagram</span>
</span></span><span style="display:flex;"><span>edges <span style="color:#f92672">=</span> [(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>), (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>), (<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>), (<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>)]
</span></span><span style="display:flex;"><span><span style="color:#75715e"># total number of nodes in the graph (labelled from 0 to 6)</span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> Graph(edges, n)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> isDAG(graph, n):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Does not contain a Cycle&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Contains a Cycle&#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span></code></pre></div><h2 id="detect-cycle-in-undirected-graph-using-bfsdfs-algo">Detect Cycle in UnDirected Graph using BFS/DFS Algo<a hidden class="anchor" aria-hidden="true" href="#detect-cycle-in-undirected-graph-using-bfsdfs-algo">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, edges, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>adjList <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (src, dest) <span style="color:#f92672">in</span> edges:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[src]<span style="color:#f92672">.</span>append(dest)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[dest]<span style="color:#f92672">.</span>append(src)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to perform DFS traversal on the graph on a graph</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">DFS</span>(graph, v, discovered, parent<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># mark the current node as discovered</span>
</span></span><span style="display:flex;"><span>    discovered[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># do for every edge (v, w)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adjList[v]:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if `w` is not discovered</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[w]:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> DFS(graph, w, discovered, v):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if `w` is discovered, and `w` is not a parent</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> w <span style="color:#f92672">!=</span> parent:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># we found a back-edge (cycle)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># No back-edges were found in the graph</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>edges <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>), (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>), (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>),
</span></span><span style="display:flex;"><span>    (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>), (<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>), (<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>), (<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">10</span>), (<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># edge (10, 11) introduces a cycle in the graph</span>
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># total number of nodes in the graph (0 to 11)</span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> Graph(edges, n)
</span></span><span style="display:flex;"><span>discovered <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> DFS(graph, <span style="color:#ae81ff">0</span>, discovered):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;The graph contains a cycle&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;The graph doesn</span><span style="color:#ae81ff">\&#39;</span><span style="color:#e6db74">t contain any cycle&#39;</span>)
</span></span></code></pre></div><h2 id="minimum-step-by-knight">Minimum Step by Knight<a hidden class="anchor" aria-hidden="true" href="#minimum-step-by-knight">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;Given a chessboard, find the shortest distance (minimum number of steps) taken by a knight to reach a given destination from a given source.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">For example,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">N = 8 (8 × 8 board)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Source = (7, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Destination = (0, 7)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: Minimum number of steps required is 6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># (x, y) represents chessboard coordinates `dist` represents its minimum distance from the source</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, x, y, dist<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> x
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> y
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>dist <span style="color:#f92672">=</span> dist
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># As we are using `Node` as a key in a dictionary, we need to override the `__hash__()` and `__eq__()` function</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __hash__(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> hash((self<span style="color:#f92672">.</span>x, self<span style="color:#f92672">.</span>y, self<span style="color:#f92672">.</span>dist))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __eq__(self, other):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (self<span style="color:#f92672">.</span>x, self<span style="color:#f92672">.</span>y, self<span style="color:#f92672">.</span>dist) <span style="color:#f92672">==</span> (other<span style="color:#f92672">.</span>x, other<span style="color:#f92672">.</span>y, other<span style="color:#f92672">.</span>dist)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Below lists detail all eight possible movements for a knight</span>
</span></span><span style="display:flex;"><span>row <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>col <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Check if (x, y) is valid chessboard coordinates.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Note that a knight cannot go out of the chessboard</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isValid</span>(x, y, N):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> y <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> x <span style="color:#f92672">&lt;</span> N <span style="color:#f92672">and</span> y <span style="color:#f92672">&lt;</span> N
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Find the minimum number of steps taken by the knight</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># from the source to reach the destination using BFS</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findShortestDistance</span>(src, dest, N):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># set to check if the matrix cell is visited before or not</span>
</span></span><span style="display:flex;"><span>    visited <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create a queue and enqueue the first node</span>
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> deque()
</span></span><span style="display:flex;"><span>    q<span style="color:#f92672">.</span>append(src)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># loop till queue is empty</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> q:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># dequeue front node and process it</span>
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>x
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>y
</span></span><span style="display:flex;"><span>        dist <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>dist
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if the destination is reached, return distance</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> x <span style="color:#f92672">==</span> dest<span style="color:#f92672">.</span>x <span style="color:#f92672">and</span> y <span style="color:#f92672">==</span> dest<span style="color:#f92672">.</span>y:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> dist
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># skip if the location is visited before</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> node <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> visited:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># mark the current node as visited</span>
</span></span><span style="display:flex;"><span>            visited<span style="color:#f92672">.</span>add(node)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># check for all eight possible movements for a knight</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># and enqueue each valid movement</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(row)):
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># get the knight&#39;s valid position from the current position on</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># the chessboard and enqueue it with +1 distance</span>
</span></span><span style="display:flex;"><span>                x1 <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> row[i]
</span></span><span style="display:flex;"><span>                y1 <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> col[i]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> isValid(x1, y1, N):
</span></span><span style="display:flex;"><span>                    q<span style="color:#f92672">.</span>append(Node(x1, y1, dist <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return infinity if the path is not possible</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sys<span style="color:#f92672">.</span>maxsize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>               <span style="color:#75715e"># N x N matrix</span>
</span></span><span style="display:flex;"><span>src <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>)    <span style="color:#75715e"># source coordinates</span>
</span></span><span style="display:flex;"><span>dest <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>)   <span style="color:#75715e"># destination coordinates</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;The minimum number of steps required is&#34;</span>,findShortestDistance(src, dest, N))
</span></span><span style="display:flex;"><span> 
</span></span></code></pre></div><h2 id="flood-fill-algo">flood fill algo<a hidden class="anchor" aria-hidden="true" href="#flood-fill-algo">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;Flood fill (also known as seed fill) is an algorithm that determines the area connected to a given node in a multi-dimensional array.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Below lists detail all eight possible movements</span>
</span></span><span style="display:flex;"><span>row <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>col <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># check if it is possible to go to pixel (x, y) from the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># current pixel. The function returns false if the pixel</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># has a different color, or it&#39;s not a valid pixel</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isSafe</span>(mat, x, y, target):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&lt;</span> len(mat) <span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> y <span style="color:#f92672">&lt;</span> len(mat[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">and</span> mat[x][y] <span style="color:#f92672">==</span> target
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Flood fill using DFS</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">floodfill</span>(mat, x, y, replacement):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> mat <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> len(mat):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># get the target color</span>
</span></span><span style="display:flex;"><span>    target <span style="color:#f92672">=</span> mat[x][y]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># target color is same as replacement</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> target <span style="color:#f92672">==</span> replacement:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># replace the current pixel color with that of replacement</span>
</span></span><span style="display:flex;"><span>    mat[x][y] <span style="color:#f92672">=</span> replacement
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># process all eight adjacent pixels of the current pixel and</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for each valid pixel</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(len(row)):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if the adjacent pixel at position (x + row[k], y + col[k]) is</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># a valid pixel and has the same color as that of the current pixel</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> isSafe(mat, x <span style="color:#f92672">+</span> row[k], y <span style="color:#f92672">+</span> col[k], target):
</span></span><span style="display:flex;"><span>            floodfill(mat, x <span style="color:#f92672">+</span> row[k], y <span style="color:#f92672">+</span> col[k], replacement)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mat <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;Y&#39;</span>, <span style="color:#e6db74">&#39;Y&#39;</span>, <span style="color:#e6db74">&#39;Y&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;Y&#39;</span>, <span style="color:#e6db74">&#39;Y&#39;</span>, <span style="color:#e6db74">&#39;Y&#39;</span>, <span style="color:#e6db74">&#39;Y&#39;</span>, <span style="color:#e6db74">&#39;Y&#39;</span>, <span style="color:#e6db74">&#39;Y&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;R&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#e6db74">&#39;W&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>, <span style="color:#e6db74">&#39;X&#39;</span>]
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># start node</span>
</span></span><span style="display:flex;"><span>x, y <span style="color:#f92672">=</span> (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">9</span>)   <span style="color:#75715e"># having a target color `X`</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># replacement color</span>
</span></span><span style="display:flex;"><span>replacement <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;C&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># replace the target color with a replacement color using DFS</span>
</span></span><span style="display:flex;"><span>floodfill(mat, x, y, replacement)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print the colors after replacement</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> mat:
</span></span><span style="display:flex;"><span>    print(r)
</span></span></code></pre></div><h2 id="clone-a-graph">Clone a graph<a hidden class="anchor" aria-hidden="true" href="#clone-a-graph">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TODO
</span></span></code></pre></div><h2 id="making-wired-connections">Making wired Connections<a hidden class="anchor" aria-hidden="true" href="#making-wired-connections">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;There are n computers numbered from 0 to n-1 connected by ethernet cables connections forming a network where connections[i] = [a, b] represents a connection between computers a and b. Any computer can reach any other computer directly or indirectly through the network.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the minimum number of times you need to do this in order to make all the computers connected. If it’s not possible, return -1.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Example 1:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: n = 4, connections = [[0,1],[0,2],[1,2]]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Example 2:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: 2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Example 3:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: -1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation: There are not enough cables.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Example 4:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">makeConnected</span>(n, connections):
</span></span><span style="display:flex;"><span>    uf <span style="color:#f92672">=</span> {i: i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n)}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find</span>(x):
</span></span><span style="display:flex;"><span>        uf<span style="color:#f92672">.</span>setdefault(x, x)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> uf[x] <span style="color:#f92672">!=</span> x:
</span></span><span style="display:flex;"><span>            uf[x] <span style="color:#f92672">=</span> find(uf[x])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> uf[x]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">union</span>(a, b):
</span></span><span style="display:flex;"><span>        uf[find(a)] <span style="color:#f92672">=</span> find(b)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(connections) <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> a, b <span style="color:#f92672">in</span> connections:
</span></span><span style="display:flex;"><span>        union(a, b)
</span></span><span style="display:flex;"><span>    islands <span style="color:#f92672">=</span> len({find(x) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> uf})
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> islands <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>connections <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">2</span>],[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>]]
</span></span><span style="display:flex;"><span>print(makeConnected(n, connections))
</span></span></code></pre></div><h2 id="word-ladder">word Ladder<a hidden class="anchor" aria-hidden="true" href="#word-ladder">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given two words (beginWord and endWord), and a dictionary&#39;s word list,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">find the length of shortest transformation sequence from beginWord to endWord, such that:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">(i) Only one letter can be changed at a time, and (ii) each transformed word must exist in
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">the word list. Note that beginWord is not a transformed word.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EXAMPLES
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">beginWord = &#34;hit&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">endWord = &#34;cog&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">wordList = [&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;lot&#34;,&#34;log&#34;,&#34;cog&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">-&gt; 5 (because &#34;hit&#34; -&gt; &#34;hot&#34; -&gt; &#34;dot&#34; -&gt; &#34;dog&#34; -&gt; &#34;cog&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ladderLength</span>(beginWord, endWord, wordList):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type beginWord: str
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type endWord: str
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type wordList: Set[str]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :rtype: int
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    queue <span style="color:#f92672">=</span> deque()
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">.</span>append((beginWord, [beginWord]))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> queue:
</span></span><span style="display:flex;"><span>        node, path <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> next <span style="color:#f92672">in</span> next_nodes(node, wordList) <span style="color:#f92672">-</span> set(path):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> next <span style="color:#f92672">==</span> endWord:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> len(path) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                queue<span style="color:#f92672">.</span>append((next, path <span style="color:#f92672">+</span> [next]))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">next_nodes</span>(word, word_list):
</span></span><span style="display:flex;"><span>    to_return <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> word_list:
</span></span><span style="display:flex;"><span>        mismatch_count, w_length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, len(w)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(w_length):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> w[i] <span style="color:#f92672">!=</span> word[i]:
</span></span><span style="display:flex;"><span>                mismatch_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> mismatch_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            to_return<span style="color:#f92672">.</span>add(w)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> to_return
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>beginWord <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hit&#34;</span>
</span></span><span style="display:flex;"><span>endWord <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cog&#34;</span>
</span></span><span style="display:flex;"><span>wordList <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;hot&#34;</span>,<span style="color:#e6db74">&#34;dot&#34;</span>,<span style="color:#e6db74">&#34;dog&#34;</span>,<span style="color:#e6db74">&#34;lot&#34;</span>,<span style="color:#e6db74">&#34;log&#34;</span>,<span style="color:#e6db74">&#34;cog&#34;</span>]
</span></span><span style="display:flex;"><span>print(ladderLength(beginWord, endWord, wordList))
</span></span></code></pre></div><h2 id="dijkstra-algo">Dijkstra algo<a hidden class="anchor" aria-hidden="true" href="#dijkstra-algo">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a source vertex s from a set of vertices V in a weighted digraph where all its edge weights w(u, v) are non-negative, find the shortest path weights d(s, v) from source s for all vertices v present in the graph    
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> heapq <span style="color:#f92672">import</span> heappop, heappush
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, vertex, weight<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>vertex <span style="color:#f92672">=</span> vertex
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>weight <span style="color:#f92672">=</span> weight
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Override the __lt__() function to make `Node` class work with a min-heap</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __lt__(self, other):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>weight <span style="color:#f92672">&lt;</span> other<span style="color:#f92672">.</span>weight
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, edges, n):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># allocate memory for the adjacency list</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>adjList <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># add edges to the directed graph</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (source, dest, weight) <span style="color:#f92672">in</span> edges:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[source]<span style="color:#f92672">.</span>append((dest, weight))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_route</span>(prev, i, route):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        get_route(prev, prev[i], route)
</span></span><span style="display:flex;"><span>        route<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findShortestPaths</span>(graph, source, n):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create a min-heap and push source node having distance 0</span>
</span></span><span style="display:flex;"><span>    pq <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    heappush(pq, Node(source))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># set initial distance from the source to `v` as infinity</span>
</span></span><span style="display:flex;"><span>    dist <span style="color:#f92672">=</span> [sys<span style="color:#f92672">.</span>maxsize] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># distance from the source to itself is zero</span>
</span></span><span style="display:flex;"><span>    dist[source] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># list to track vertices for which minimum cost is already found</span>
</span></span><span style="display:flex;"><span>    done <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span>    done[source] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># stores predecessor of a vertex (to a print path)</span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># run till min-heap is empty</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> pq:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> heappop(pq)      <span style="color:#75715e"># Remove and return the best vertex</span>
</span></span><span style="display:flex;"><span>        u <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>vertex         <span style="color:#75715e"># get the vertex number</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># do for each neighbor `v` of `u`</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (v, weight) <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adjList[u]:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> done[v] <span style="color:#f92672">and</span> (dist[u] <span style="color:#f92672">+</span> weight) <span style="color:#f92672">&lt;</span> dist[v]:        <span style="color:#75715e"># Relaxation step</span>
</span></span><span style="display:flex;"><span>                dist[v] <span style="color:#f92672">=</span> dist[u] <span style="color:#f92672">+</span> weight
</span></span><span style="display:flex;"><span>                prev[v] <span style="color:#f92672">=</span> u
</span></span><span style="display:flex;"><span>                heappush(pq, Node(v, dist[v]))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># mark vertex `u` as done so it will not get picked up again</span>
</span></span><span style="display:flex;"><span>        done[u] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    route <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">!=</span> source <span style="color:#f92672">and</span> dist[i] <span style="color:#f92672">!=</span> sys<span style="color:#f92672">.</span>maxsize:
</span></span><span style="display:flex;"><span>            get_route(prev, i, route)
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Path (</span><span style="color:#e6db74">{</span>source<span style="color:#e6db74">}</span><span style="color:#e6db74"> —&gt; </span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">): Minimum cost = </span><span style="color:#e6db74">{</span>dist[i]<span style="color:#e6db74">}</span><span style="color:#e6db74">, Route = </span><span style="color:#e6db74">{</span>route<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>            route<span style="color:#f92672">.</span>clear()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># initialize edges as per the above diagram (u, v, w) represent edge from vertex `u` to vertex `v` having weight `w`</span>
</span></span><span style="display:flex;"><span>edges <span style="color:#f92672">=</span> [(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>), (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">9</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span>),
</span></span><span style="display:flex;"><span>        (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>), (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>), (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>)]
</span></span><span style="display:flex;"><span><span style="color:#75715e"># total number of nodes in the graph (labelled from 0 to 4)</span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> Graph(edges, n)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> source <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>    findShortestPaths(graph, source, n)
</span></span></code></pre></div><h2 id="implement-topological-sort">Implement Topological Sort<a hidden class="anchor" aria-hidden="true" href="#implement-topological-sort">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a Directed Acyclic Graph (DAG), print it in topological order using topological sort algorithm. If the graph has more than one topological ordering, output any of them. Assume valid Directed Acyclic Graph (DAG).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">A Topological sort or Topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. A topological ordering is possible if and only if the graph has no directed cycles, i.e. if the graph is DAG.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A class to represent a graph object</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, edges, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>adjList <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (src, dest) <span style="color:#f92672">in</span> edges:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>adjList[src]<span style="color:#f92672">.</span>append(dest)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Perform DFS on the graph and set the departure time of all vertices of the graph</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">DFS</span>(graph, v, discovered, departure, time):
</span></span><span style="display:flex;"><span>    discovered[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    time <span style="color:#f92672">=</span> time <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> u <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adjList[v]:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[u]:
</span></span><span style="display:flex;"><span>            time <span style="color:#f92672">=</span> DFS(graph, u, discovered, departure, time)
</span></span><span style="display:flex;"><span>    departure[time] <span style="color:#f92672">=</span> v
</span></span><span style="display:flex;"><span>    time <span style="color:#f92672">=</span> time <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> time
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to perform a topological sort on a given DAG</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">doTopologicalSort</span>(graph, n):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># departure[] stores the vertex number using departure time as an index</span>
</span></span><span style="display:flex;"><span>    departure <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39; If we had done it the other way around, i.e., fill the array
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        with departure time using vertex number as an index, we would
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        need to sort it later &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># to keep track of whether a vertex is discovered or not</span>
</span></span><span style="display:flex;"><span>    discovered <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span>    time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># perform DFS on all undiscovered vertices</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[i]:
</span></span><span style="display:flex;"><span>            time <span style="color:#f92672">=</span> DFS(graph, i, discovered, departure, time)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Print the vertices in order of their decreasing</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># departure time in DFS, i.e., in topological order</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> reversed(range(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> departure[i] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            print(departure[i], end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># List of graph edges as per the above diagram</span>
</span></span><span style="display:flex;"><span>edges <span style="color:#f92672">=</span> [(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>), (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>), (<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>), (<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">1</span>)] 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># total number of nodes in the graph (labelled from 0 to 7)</span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> Graph(edges, n) 
</span></span><span style="display:flex;"><span>doTopologicalSort(graph, n)
</span></span></code></pre></div><h2 id="minimum-time-taken-by-each-job-to-be-completed-given-by-a-directed-acyclic-graph">Minimum time taken by each job to be completed given by a Directed Acyclic Graph<a hidden class="anchor" aria-hidden="true" href="#minimum-time-taken-by-each-job-to-be-completed-given-by-a-directed-acyclic-graph">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a Directed Acyclic Graph having V vertices and E edges, where each edge {U, V} represents the Jobs U and V such that Job V can only be started only after completion of Job U. The task is to determine the minimum time taken by each job to be completed where each Job takes unit time to get completed.   
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self, vertices, edges):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> defaultdict(list)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>n <span style="color:#f92672">=</span> vertices
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>m <span style="color:#f92672">=</span> edges
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Function to add an edge to graph</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addEdge</span>(self, u, v):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph[u]<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Function to find the minimum time needed by each node to get the task</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printOrder</span>(self, n, m):
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Create a vector to store indegrees of all vertices. Initialize all indegrees as 0.</span>
</span></span><span style="display:flex;"><span>		indegree <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (self<span style="color:#f92672">.</span>n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Traverse adjacency lists to fill indegrees of vertices. This step takes O(V + E) time</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[i]:
</span></span><span style="display:flex;"><span>				indegree[j] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Array to store the time in which the job i can be done</span>
</span></span><span style="display:flex;"><span>		job <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (self<span style="color:#f92672">.</span>n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Create an queue and enqueue all vertices with indegree 0</span>
</span></span><span style="display:flex;"><span>		q <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Update the time of the jobs who don&#39;t require any job to be completed before this job</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, self<span style="color:#f92672">.</span>n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> indegree[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>				q<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>				job[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Iterate until queue is empty</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> q:
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Get front element of queue</span>
</span></span><span style="display:flex;"><span>			cur <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> adj <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[cur]:
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># Decrease in-degree of the current node</span>
</span></span><span style="display:flex;"><span>				indegree[adj] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># Push its adjacent elements</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (indegree[adj] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>					job[adj] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> job[cur]
</span></span><span style="display:flex;"><span>					q<span style="color:#f92672">.</span>append(adj)
</span></span><span style="display:flex;"><span>					
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Print the time to complete the job</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>			print(job[i], end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>		print()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Given Nodes N and edges M</span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> <span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> Graph(n, m)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">9</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>printOrder(n, m)
</span></span></code></pre></div><h2 id="find-whether-it-is-possible-to-finish-all-tasks-or-not-from-given-dependencies">Find whether it is possible to finish all tasks or not from given dependencies<a hidden class="anchor" aria-hidden="true" href="#find-whether-it-is-possible-to-finish-all-tasks-or-not-from-given-dependencies">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">There are a total of n tasks you have to pick, labelled from 0 to n-1. Some tasks may have prerequisites, for example to pick task 0 you have to first pick task 1, which is expressed as a pair: [0, 1]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given the total number of tasks and a list of prerequisite pairs, is it possible for you to finish all tasks?
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Examples:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: 2, [[1, 0]] 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: true 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation: There are a total of 2 tasks to pick. To pick task 1 you should have finished task 0. So it is possible.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: 2, [[1, 0], [0, 1]] 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: false 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation: There are a total of 2 tasks to pick. To pick task 1 you should have finished task 0, and to pick task 0 you should also have finished task 1. So it is impossible.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: 3, [[1, 0], [2, 1], [3, 2]] 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: true 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation: There are a total of 3 tasks to pick. To pick tasks 1 you should have finished task 0, and to pick task 2 you should have finished task 1 and to pick task 3 you should have finished task 2. So it is possible. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	arr <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># parameterized constructor</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self,n):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Initially, everyone is their own child</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>arr <span style="color:#f92672">=</span> list(range(n))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">makeParent</span>(self,a, b):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># find parent of b and make it a&#39;s parent</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>arr[a] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>findParent(b)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findParent</span>(self,c):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># when an independent task is found</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> c <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>arr) <span style="color:#66d9ef">else</span> self<span style="color:#f92672">.</span>findParent(self<span style="color:#f92672">.</span>arr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isPossible</span>(self,N , prerequisites):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># traverse through pre-requisites array</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(prerequisites)):
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># check whether given pre-requisite pair already have a common pre-requisite(parent)</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (self<span style="color:#f92672">.</span>findParent(prerequisites[i][<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>findParent(prerequisites[i][<span style="color:#ae81ff">1</span>])):
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># tasks cannot be completed because there was a cyclic condition in the tasks</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># make parent-child relation between pre-requisite task and the task dependent on it</span>
</span></span><span style="display:flex;"><span>			self<span style="color:#f92672">.</span>makeParent(prerequisites[i][<span style="color:#ae81ff">0</span>], prerequisites[i][<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># if there was no cycle found, tasks can be completed</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>prerequisites <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>]]
</span></span><span style="display:flex;"><span>ob <span style="color:#f92672">=</span> Solution(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ob<span style="color:#f92672">.</span>isPossible(<span style="color:#ae81ff">4</span>,prerequisites ):
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;Yes&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span></code></pre></div><h2 id="find-the-no-of-islands">Find the no. of Islands<a hidden class="anchor" aria-hidden="true" href="#find-the-no-of-islands">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a boolean 2D matrix, find the number of islands. A group of connected 1s forms an island. For example, the below matrix contains 5 islands
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Example: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : mat[][] = {{1, 1, 0, 0, 0},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                   {0, 1, 0, 0, 1},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                   {1, 0, 0, 1, 1},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                   {0, 0, 0, 0, 0},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                   {1, 0, 1, 0, 1}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : 5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Program to count islands in boolean 2D matrix</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self, row, col, graph):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>ROW <span style="color:#f92672">=</span> row
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>COL <span style="color:#f92672">=</span> col
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> graph
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># A utility function to do DFS for a 2D boolean matrix. It only considers the 8 neighbours as adjacent vertices</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">DFS</span>(self, i, j):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">&gt;=</span> len(self<span style="color:#f92672">.</span>graph) <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">&gt;=</span> len(self<span style="color:#f92672">.</span>graph[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">or</span> self<span style="color:#f92672">.</span>graph[i][j] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># mark it as visited</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph[i][j] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Recur for 8 neighbours</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>DFS(i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>DFS(i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>DFS(i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>DFS(i, j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>DFS(i, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>DFS(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>DFS(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>DFS(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># The main function that returns count of islands in a given boolean 2D matrix</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countIslands</span>(self):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Initialize count as 0 and traverse through the all cells of given matrix</span>
</span></span><span style="display:flex;"><span>		count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>ROW):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>COL):
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># If a cell with value 1 is not visited yet, then new island found</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>graph[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>					<span style="color:#75715e"># Visit all cells in this island and increment island count</span>
</span></span><span style="display:flex;"><span>					self<span style="color:#f92672">.</span>DFS(i, j)
</span></span><span style="display:flex;"><span>					count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>row <span style="color:#f92672">=</span> len(graph)
</span></span><span style="display:flex;"><span>col <span style="color:#f92672">=</span> len(graph[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> Graph(row, col, graph)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Number of islands is:&#34;</span>, g<span style="color:#f92672">.</span>countIslands())
</span></span></code></pre></div><h2 id="given-a-sorted-dictionary-of-an-alien-language-find-order-of-characters">Given a sorted Dictionary of an Alien Language, find order of characters<a hidden class="anchor" aria-hidden="true" href="#given-a-sorted-dictionary-of-an-alien-language-find-order-of-characters">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a dictionary of ancient origin where the words are arranged alphabetically, find the correct order of alphabets in the ancient language.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">For example,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input:  Ancient dictionary { ¥€±, €±€, €±‰ð, ðß, ±±ð, ±ßß }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: The correct order of alphabets in the ancient language is {¥ € ‰ ð ± ß}.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Since the input is small, more than one ordering is possible. Another such ordering is {¥ € ð ± ß ‰}.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input:  Ancient dictionary { ÿ€±š, €€€ß, €€‰ð, ðß, ±ß¥š }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: The correct order of alphabets in the ancient language is {ÿ € ‰ ð ±}.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The alphabets {š, ß, ¥} are not included in the order as they are not properly defined.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, N):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>adj <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N)]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">DFS</span>(graph, v, discovered, departure, time):
</span></span><span style="display:flex;"><span>    discovered[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    time <span style="color:#f92672">=</span> time <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> u <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adj[v]:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[u]:
</span></span><span style="display:flex;"><span>            time <span style="color:#f92672">=</span> DFS(graph, u, discovered, departure, time)
</span></span><span style="display:flex;"><span>    departure[time] <span style="color:#f92672">=</span> v
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> time <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Utility function to performs topological sort on a given DAG</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">doTopologicalSort</span>(graph, d):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># `departure[]` stores the vertex number using departure time as an index</span>
</span></span><span style="display:flex;"><span>    departure <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> N)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39; If we had done it the other way around, i.e., fill the array
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        with departure time using vertex number as an index, we would
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        need to sort it later &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># to keep track of whether a vertex is discovered or not</span>
</span></span><span style="display:flex;"><span>    discovered <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> N
</span></span><span style="display:flex;"><span>    time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># perform DFS on all undiscovered connected vertices</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> discovered[i] <span style="color:#f92672">and</span> len(graph<span style="color:#f92672">.</span>adj[i]):
</span></span><span style="display:flex;"><span>            time <span style="color:#f92672">=</span> DFS(graph, i, discovered, departure, time)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">The correct order of alphabets in the ancient language is&#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Print the vertices in order of their decreasing</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># departure time in DFS, i.e., in topological order</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> reversed(range(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>N)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> departure[i] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            print(d[departure[i]], end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Utility function to print adjacency list representation of a graph</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printGraph</span>(graph, d):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ignore vertices with no outgoing edges</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> graph<span style="color:#f92672">.</span>adj[i]:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># print current vertex and all neighboring vertices of a vertex `i`</span>
</span></span><span style="display:flex;"><span>            print(d[i], <span style="color:#e6db74">&#39;—&gt;&#39;</span>, [d[v] <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>adj[i]])
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find the correct order of alphabets in a given dictionary of</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ancient origin. This function assumes that the input is correct.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findAlphabetsOrder</span>(dictionary):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create a dictionary to map each non-ASCII character present in the given dictionary with a unique integer</span>
</span></span><span style="display:flex;"><span>    d <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># do for each word</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> word <span style="color:#f92672">in</span> dictionary:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># do for each non-ASCII character of the word</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> word:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># if the current character is not present in the dictionary, insert it</span>
</span></span><span style="display:flex;"><span>            d<span style="color:#f92672">.</span>setdefault(s, k)
</span></span><span style="display:flex;"><span>            k <span style="color:#f92672">=</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create a graph containing `N` nodes</span>
</span></span><span style="display:flex;"><span>    graph <span style="color:#f92672">=</span> Graph(N)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># iterate through the complete dictionary and compare adjacent words for character mismatch</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(dictionary)):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># previous word in the dictionary</span>
</span></span><span style="display:flex;"><span>        prev <span style="color:#f92672">=</span> dictionary[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># current word in the dictionary</span>
</span></span><span style="display:flex;"><span>        curr <span style="color:#f92672">=</span> dictionary[i]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># iterate through both `prev` and `curr` simultaneously and find the first mismatching character</span>
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> j <span style="color:#f92672">&lt;</span> len(prev) <span style="color:#f92672">and</span> j <span style="color:#f92672">&lt;</span> len(curr):
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># mismatch found</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> prev[j] <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> curr[j]:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># add an edge from the current character of `prev` to the</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># current character of `curr` in the graph</span>
</span></span><span style="display:flex;"><span>                graph<span style="color:#f92672">.</span>adj[d[prev[j]]]<span style="color:#f92672">.</span>append(d[curr[j]])
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create a reverse dict</span>
</span></span><span style="display:flex;"><span>    reverse <span style="color:#f92672">=</span> {v: k <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> d<span style="color:#f92672">.</span>items()}
</span></span><span style="display:flex;"><span>    printGraph(graph, reverse)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># perform a topological sort on the above graph</span>
</span></span><span style="display:flex;"><span>    doTopologicalSort(graph, reverse)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># define the maximum number of alphabets in the ancient dictionary</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>dictionary <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;¥&#34;</span>, <span style="color:#e6db74">&#34;€&#34;</span>, <span style="color:#e6db74">&#34;±&#34;</span>],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;€&#34;</span>, <span style="color:#e6db74">&#34;±&#34;</span>, <span style="color:#e6db74">&#34;€&#34;</span>],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;€&#34;</span>, <span style="color:#e6db74">&#34;±&#34;</span>, <span style="color:#e6db74">&#34;‰&#34;</span>, <span style="color:#e6db74">&#34;ð&#34;</span>],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;ð&#34;</span>, <span style="color:#e6db74">&#34;ß&#34;</span>],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;±&#34;</span>, <span style="color:#e6db74">&#34;±&#34;</span>, <span style="color:#e6db74">&#34;ð&#34;</span>],
</span></span><span style="display:flex;"><span>    [<span style="color:#e6db74">&#34;±&#34;</span>, <span style="color:#e6db74">&#34;ß&#34;</span>, <span style="color:#e6db74">&#34;ß&#34;</span>]
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>findAlphabetsOrder(dictionary)
</span></span></code></pre></div><h2 id="implement-kruksalsalgorithm">Implement Kruksal’sAlgorithm<a hidden class="anchor" aria-hidden="true" href="#implement-kruksalsalgorithm">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Below are the steps for finding MST using Kruskal’s algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">1. Sort all the edges in non-decreasing order of their weight. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">3. Repeat step#2 until there are (V-1) edges in the spanning tree.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self, vertices):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>V <span style="color:#f92672">=</span> vertices <span style="color:#75715e"># No. of vertices</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> [] <span style="color:#75715e"># default dictionary</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># to store graph</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># function to add an edge to graph</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addEdge</span>(self, u, v, w):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph<span style="color:#f92672">.</span>append([u, v, w])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># A utility function to find set of an element i (uses path compression technique)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find</span>(self, parent, i):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> i <span style="color:#66d9ef">if</span> parent[i] <span style="color:#f92672">==</span> i <span style="color:#66d9ef">else</span> self<span style="color:#f92672">.</span>find(parent, parent[i])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># A function that does union of two sets of x and y (uses union by rank)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">union</span>(self, parent, rank, x, y):
</span></span><span style="display:flex;"><span>		xroot <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>find(parent, x)
</span></span><span style="display:flex;"><span>		yroot <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>find(parent, y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Attach smaller rank tree under root of high rank tree (Union by Rank)</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> rank[xroot] <span style="color:#f92672">&lt;</span> rank[yroot]:
</span></span><span style="display:flex;"><span>			parent[xroot] <span style="color:#f92672">=</span> yroot
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">elif</span> rank[xroot] <span style="color:#f92672">&gt;</span> rank[yroot]:
</span></span><span style="display:flex;"><span>			parent[yroot] <span style="color:#f92672">=</span> xroot
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># If ranks are same, then make one as root and increment its rank by one</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>			parent[yroot] <span style="color:#f92672">=</span> xroot
</span></span><span style="display:flex;"><span>			rank[xroot] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># The main function to construct MST using Kruskal&#39;s algorithm</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">KruskalMST</span>(self):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		result <span style="color:#f92672">=</span> [] <span style="color:#75715e"># This will store the resultant MST</span>
</span></span><span style="display:flex;"><span>		i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e"># An index variable, used for sorted edges</span>
</span></span><span style="display:flex;"><span>		e <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e"># An index variable, used for result[]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Step 1: Sort all the edges in non-decreasing order of their</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># weight. If we are not allowed to change the given graph, we can create a copy of graph</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> sorted(self<span style="color:#f92672">.</span>graph, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> item: item[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		parent <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>		rank <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Create V subsets with single elements</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> node <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>V):
</span></span><span style="display:flex;"><span>			parent<span style="color:#f92672">.</span>append(node)
</span></span><span style="display:flex;"><span>			rank<span style="color:#f92672">.</span>append(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Number of edges to be taken is equal to V-1</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> e <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>V <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Step 2: Pick the smallest edge and increment the index for next iteration</span>
</span></span><span style="display:flex;"><span>			u, v, w <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>graph[i]
</span></span><span style="display:flex;"><span>			i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>			x <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>find(parent, u)
</span></span><span style="display:flex;"><span>			y <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>find(parent, v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># If including this edge doesn&#39;t cause cycle, include it in result and increment the indexof </span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># result for next edge</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> x <span style="color:#f92672">!=</span> y:
</span></span><span style="display:flex;"><span>				e <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>				result<span style="color:#f92672">.</span>append([u, v, w])
</span></span><span style="display:flex;"><span>				self<span style="color:#f92672">.</span>union(parent, rank, x, y)
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># Else discard the edge</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		minimumCost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		print (<span style="color:#e6db74">&#34;Edges in the constructed MST&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> u, v, weight <span style="color:#f92672">in</span> result:
</span></span><span style="display:flex;"><span>			minimumCost <span style="color:#f92672">+=</span> weight
</span></span><span style="display:flex;"><span>			print(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> -- </span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> == </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (u, v, weight))
</span></span><span style="display:flex;"><span>		print(<span style="color:#e6db74">&#34;Minimum Spanning Tree&#34;</span> , minimumCost)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> Graph(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>KruskalMST()
</span></span></code></pre></div><h2 id="implement-prims-algorithm">Implement Prim’s Algorithm<a hidden class="anchor" aria-hidden="true" href="#implement-prims-algorithm">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># A Python program for Prim&#39;s Minimum Spanning Tree (MST) algorithm.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The program is for adjacency matrix representation of the graph</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys <span style="color:#75715e"># Library for INT_MAX</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>():
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self, vertices):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>V <span style="color:#f92672">=</span> vertices
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> column <span style="color:#f92672">in</span> range(vertices)]
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> range(vertices)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># A utility function to print the constructed MST stored in parent[]</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printMST</span>(self, parent):
</span></span><span style="display:flex;"><span>		print (<span style="color:#e6db74">&#34;Edge </span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">Weight&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, self<span style="color:#f92672">.</span>V):
</span></span><span style="display:flex;"><span>			print (parent[i], <span style="color:#e6db74">&#34;-&#34;</span>, i, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span>, self<span style="color:#f92672">.</span>graph[i][parent[i]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># A utility function to find the vertex with minimum distance value, from the set of vertices not yet included in shortest path tree</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minKey</span>(self, key, mstSet):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Initialize minValue value</span>
</span></span><span style="display:flex;"><span>		minValue <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>maxsize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>V):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> key[v] <span style="color:#f92672">&lt;</span> minValue <span style="color:#f92672">and</span> mstSet[v] <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>				minValue <span style="color:#f92672">=</span> key[v]
</span></span><span style="display:flex;"><span>				min_index <span style="color:#f92672">=</span> v
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> min_index
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Function to construct and print MST for a graph represented using adjacency matrix representation</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">primMST</span>(self):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Key values used to pick minimum weight edge in cut</span>
</span></span><span style="display:flex;"><span>		key <span style="color:#f92672">=</span> [sys<span style="color:#f92672">.</span>maxsize] <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>V
</span></span><span style="display:flex;"><span>		parent <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>V <span style="color:#75715e"># Array to store constructed MST</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Make key 0 so that this vertex is picked as first vertex</span>
</span></span><span style="display:flex;"><span>		key[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		mstSet <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>V
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		parent[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#75715e"># First node is always the root of</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> cout <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>V):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Pick the minimum distance vertex from the set of vertices not yet processed. u is always equal to src in first iteration</span>
</span></span><span style="display:flex;"><span>			u <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>minKey(key, mstSet)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Put the minimum distance vertex in the shortest path tree</span>
</span></span><span style="display:flex;"><span>			mstSet[u] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Update dist value of the adjacent vertices of the picked vertex only if the current</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># distance is greater than new distance and the vertex in not in the shortest path tree</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>V):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># graph[u][v] is non zero only for adjacent vertices of m mstSet[v] is false for vertices not yet included in MST</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># Update the key only if graph[u][v] is smaller than key[v]</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>graph[u][v] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> mstSet[v] <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span> <span style="color:#f92672">and</span> key[v] <span style="color:#f92672">&gt;</span> self<span style="color:#f92672">.</span>graph[u][v]:
</span></span><span style="display:flex;"><span>						key[v] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>graph[u][v]
</span></span><span style="display:flex;"><span>						parent[v] <span style="color:#f92672">=</span> u
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>printMST(parent)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> Graph(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> [ [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>			[<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">5</span>],
</span></span><span style="display:flex;"><span>			[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>],
</span></span><span style="display:flex;"><span>			[<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">9</span>],
</span></span><span style="display:flex;"><span>			[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span>]]
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>primMST();
</span></span></code></pre></div><h2 id="total-no-of-spanning-tree-in-a-graph">Total no. of Spanning tree in a graph<a hidden class="anchor" aria-hidden="true" href="#total-no-of-spanning-tree-in-a-graph">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TODO
</span></span></code></pre></div><h2 id="implement-bellman-ford-algorithm">Implement Bellman Ford Algorithm<a hidden class="anchor" aria-hidden="true" href="#implement-bellman-ford-algorithm">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">We are given a directed graph. We need to compute whether the graph has a negative cycle or not. A negative cycle is one in which the overall sum of the cycle becomes negative.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># a structure to represent a weighted edge in graph</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Edge</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>src <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>dest <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>weight <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># a structure to represent a connected, directed and weighted graph</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># V. Number of vertices, E. Number of edges</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>V <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>E <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># graph is represented as an array of edges.</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>edge <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Creates a graph with V vertices and E edges</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">createGraph</span>(V, E):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	graph <span style="color:#f92672">=</span> Graph()
</span></span><span style="display:flex;"><span>	graph<span style="color:#f92672">.</span>V <span style="color:#f92672">=</span> V;
</span></span><span style="display:flex;"><span>	graph<span style="color:#f92672">.</span>E <span style="color:#f92672">=</span> E;
</span></span><span style="display:flex;"><span>	graph<span style="color:#f92672">.</span>edge <span style="color:#f92672">=</span> [Edge() <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(graph<span style="color:#f92672">.</span>E)]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> graph;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The main function that finds shortest distances from src to all other vertices using Bellman- Ford algorithm. The function also detects negative weight cycle</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isNegCycleBellmanFord</span>(graph, src):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	V <span style="color:#f92672">=</span> graph<span style="color:#f92672">.</span>V;
</span></span><span style="display:flex;"><span>	E <span style="color:#f92672">=</span> graph<span style="color:#f92672">.</span>E;
</span></span><span style="display:flex;"><span>	dist <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1000000</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(V)];
</span></span><span style="display:flex;"><span>	dist[src] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Step 2: Relax all edges |V| - 1 times. </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># A simple shortest path from src to any other vertex can have at-most |V| - 1 edges</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, V):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(E):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			u <span style="color:#f92672">=</span> graph<span style="color:#f92672">.</span>edge[j]<span style="color:#f92672">.</span>src;
</span></span><span style="display:flex;"><span>			v <span style="color:#f92672">=</span> graph<span style="color:#f92672">.</span>edge[j]<span style="color:#f92672">.</span>dest;
</span></span><span style="display:flex;"><span>			weight <span style="color:#f92672">=</span> graph<span style="color:#f92672">.</span>edge[j]<span style="color:#f92672">.</span>weight;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (dist[u] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1000000</span> <span style="color:#f92672">and</span> dist[u] <span style="color:#f92672">+</span> weight <span style="color:#f92672">&lt;</span> dist[v]):
</span></span><span style="display:flex;"><span>				dist[v] <span style="color:#f92672">=</span> dist[u] <span style="color:#f92672">+</span> weight;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Step 3: check for negative-weight cycles.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># The above step guarantees shortest distances if graph doesn&#39;t contain negative weight cycle.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># If we get a shorter path, then there is a cycle.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(E):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		u <span style="color:#f92672">=</span> graph<span style="color:#f92672">.</span>edge[i]<span style="color:#f92672">.</span>src;
</span></span><span style="display:flex;"><span>		v <span style="color:#f92672">=</span> graph<span style="color:#f92672">.</span>edge[i]<span style="color:#f92672">.</span>dest;
</span></span><span style="display:flex;"><span>		weight <span style="color:#f92672">=</span> graph<span style="color:#f92672">.</span>edge[i]<span style="color:#f92672">.</span>weight;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (dist[u] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1000000</span> <span style="color:#f92672">and</span> dist[u] <span style="color:#f92672">+</span> weight <span style="color:#f92672">&lt;</span> dist[v]):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Let us create the graph given in above example</span>
</span></span><span style="display:flex;"><span>V <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e"># Number of vertices in graph</span>
</span></span><span style="display:flex;"><span>E <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>; <span style="color:#75715e"># Number of edges in graph</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> createGraph(V, E)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>source<span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>destination<span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>weight<span style="color:#f92672">=</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(E):
</span></span><span style="display:flex;"><span>    graph<span style="color:#f92672">.</span>edge[i]<span style="color:#f92672">.</span>src<span style="color:#f92672">=</span>source[i]
</span></span><span style="display:flex;"><span>    graph<span style="color:#f92672">.</span>edge[i]<span style="color:#f92672">.</span>dest<span style="color:#f92672">=</span>destination[i]
</span></span><span style="display:flex;"><span>    graph<span style="color:#f92672">.</span>edge[i]<span style="color:#f92672">.</span>weight<span style="color:#f92672">=</span>weight[i]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (isNegCycleBellmanFord(graph, <span style="color:#ae81ff">0</span>)):
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;Yes&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span></code></pre></div><h2 id="implement-floyd-warshallalgorithm">Implement Floyd warshallAlgorithm<a hidden class="anchor" aria-hidden="true" href="#implement-floyd-warshallalgorithm">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The Floyd Warshall Algorithm is for solving the All Pairs Shortest Path problem. The problem is to find shortest distances between every pair of vertices in a given edge weighted directed Graph. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Example: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       graph[][] = { {0,   5,  INF, 10},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {INF,  0,  3,  INF},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {INF, INF, 0,   1},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    {INF, INF, INF, 0} }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">which represents the following graph
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       (0)-------&gt;(3)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        |         /|</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">      5 |          |
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        |          | 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       \|/         |
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       (1)-------&gt;(2)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            3       
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Note that the value of graph[i][j] is 0 if i is equal to j 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">And graph[i][j] is INF (infinite) if there is no edge from vertex i to j.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Shortest distance matrix
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      0      5      8      9
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    INF      0      3      4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    INF    INF      0      1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    INF    INF    INF      0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">floydWarshall</span>(graph):
</span></span><span style="display:flex;"><span>	dist <span style="color:#f92672">=</span> list(map(<span style="color:#66d9ef">lambda</span> i: list(map(<span style="color:#66d9ef">lambda</span> j: j, i)), graph))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># pick all vertices as source one by one</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Pick all vertices as destination for the above picked source</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># If vertex k is on the shortest path from i to j, then update the value of dist[i][j]</span>
</span></span><span style="display:flex;"><span>				dist[i][j] <span style="color:#f92672">=</span> min(dist[i][j],dist[i][k] <span style="color:#f92672">+</span> dist[k][j])
</span></span><span style="display:flex;"><span>	printSolution(dist)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function to print the solution</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printSolution</span>(dist):
</span></span><span style="display:flex;"><span>	print (<span style="color:#e6db74">&#34;Following matrix shows the shortest distances</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">between every pair of vertices&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(dist[i][j] <span style="color:#f92672">==</span> INF):
</span></span><span style="display:flex;"><span>				print (<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%7s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (<span style="color:#e6db74">&#34;INF&#34;</span>),end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>				print (<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%7d</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (dist[i][j]),end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> j <span style="color:#f92672">==</span> V<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>				print ()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Let us create the following weighted graph</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">			10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	(0)-------&gt;(3)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		|		 /|</span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">	5 |		 |
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		|		 | 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	\|/		 |
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	(1)-------&gt;(2)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">			3		 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Number of vertices in the graph</span>
</span></span><span style="display:flex;"><span>V <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">99999</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, INF, <span style="color:#ae81ff">10</span>],
</span></span><span style="display:flex;"><span>		[INF, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, INF],
</span></span><span style="display:flex;"><span>		[INF, INF, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>		[INF, INF, INF, <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>		]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>floydWarshall(graph)
</span></span></code></pre></div><h2 id="travelling-salesman-problem">Travelling Salesman Problem<a hidden class="anchor" aria-hidden="true" href="#travelling-salesman-problem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Travelling Salesman Problem (TSP): 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a set of cities and the distance between every pair of cities, the problem is to find the shortest possible route that visits every city exactly once and returns to the starting point.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#75715e"># there are four nodes in example graph (graph is 1-based)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># dist[i][j] represents shortest distance to go from i to  this matrix can be calculated for any given graph usin all-pair shortest path algorithms</span>
</span></span><span style="display:flex;"><span>dist <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">20</span>], [
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">25</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">30</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">0</span>]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># memoization for top down recursion</span>
</span></span><span style="display:flex;"><span>memo <span style="color:#f92672">=</span> [[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fun</span>(i, mask):
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># base case</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># if only ith bit and 1st bit is set in our mask, it implies we have visited all other nodes already</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> mask <span style="color:#f92672">==</span> ((<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> i) <span style="color:#f92672">|</span> <span style="color:#ae81ff">3</span>):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> dist[<span style="color:#ae81ff">1</span>][i]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># memoization</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> memo[i][mask] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> memo[i][mask]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	res <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span> <span style="color:#75715e"># result of this sub-problem</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># we have to travel all nodes j in mask and end the path at ith node so for every node j in mask, recursively calculate cost of travelling all nodes in mask except i and then travel back from node j to node i taking</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># the shortest path take the minimum of all possible j nodes</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (mask <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> j)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> j <span style="color:#f92672">!=</span> i <span style="color:#f92672">and</span> j <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>			res <span style="color:#f92672">=</span> min(res, fun(j, mask <span style="color:#f92672">&amp;</span> (<span style="color:#f92672">~</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> i))) <span style="color:#f92672">+</span> dist[j][i])
</span></span><span style="display:flex;"><span>	memo[i][mask] <span style="color:#f92672">=</span> res <span style="color:#75715e"># storing the minimum value</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> res
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># try to go from node 1 visiting all nodes in between to i then return from i taking the shortest route to 1</span>
</span></span><span style="display:flex;"><span>	ans <span style="color:#f92672">=</span> min(ans, fun(i, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> dist[i][<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;The cost of most efficient tour = </span><span style="color:#e6db74">{</span>str(ans)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><h2 id="graph-colouringproblem">Graph ColouringProblem<a hidden class="anchor" aria-hidden="true" href="#graph-colouringproblem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TODO
</span></span></code></pre></div><h2 id="snake-and-ladders-problem">Snake and Ladders Problem<a hidden class="anchor" aria-hidden="true" href="#snake-and-ladders-problem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">You start on square 1 of the board (which is always in the last row and first column). Each move, starting from square x, consists of the following:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is &lt;= N*N.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">If S has a snake or ladder, you move to the destination of that snake or ladder. Otherwise, you move to S. A board square on row r and column c has a “snake or ladder” if board[r][c] != -1. The destination of that snake or ladder is board[r][c].
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving. (For example, if the board is [[4,-1],[-1,3]], and on the first move your destination square is 2, then you finish your first move at 3, because you do not continue moving to 4.)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Return the least number of moves required to reach square N*N. If it is not possible, return -1.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> collections
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">snakesAndLadders</span>(board):
</span></span><span style="display:flex;"><span>        rows <span style="color:#f92672">=</span> len(board)
</span></span><span style="display:flex;"><span>        total_square <span style="color:#f92672">=</span> rows<span style="color:#f92672">*</span>rows
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">next_square</span>(step):
</span></span><span style="display:flex;"><span>                quot, rem <span style="color:#f92672">=</span> divmod(step<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, rows)
</span></span><span style="display:flex;"><span>                row <span style="color:#f92672">=</span> (rows <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> quot
</span></span><span style="display:flex;"><span>                col <span style="color:#f92672">=</span> rem <span style="color:#66d9ef">if</span> row<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">!=</span> rows<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#66d9ef">else</span> (rows <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> rem
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> row, col
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dist <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>: <span style="color:#ae81ff">0</span>}<span style="color:#75715e">#square and step</span>
</span></span><span style="display:flex;"><span>        queue <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>deque([<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> queue:
</span></span><span style="display:flex;"><span>            square <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> square <span style="color:#f92672">==</span> total_square:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> dist[square]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> new_square <span style="color:#f92672">in</span> range(square<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, min(square<span style="color:#f92672">+</span><span style="color:#ae81ff">6</span>, total_square) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>                r, c <span style="color:#f92672">=</span> next_square(new_square)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> board[r][c] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                    new_square <span style="color:#f92672">=</span> board[r][c]
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> new_square <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> dist:
</span></span><span style="display:flex;"><span>                    dist[new_square] <span style="color:#f92672">=</span> dist[square] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                    queue<span style="color:#f92672">.</span>append(new_square)
</span></span><span style="display:flex;"><span>board<span style="color:#f92672">=</span>[
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">35</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">13</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">15</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]
</span></span><span style="display:flex;"><span>print(snakesAndLadders(board))
</span></span></code></pre></div><h2 id="find-bridge-in-a-graph">Find bridge in a graph<a hidden class="anchor" aria-hidden="true" href="#find-bridge-in-a-graph">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#This class represents an undirected graph using adjacency list representation</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self,vertices):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>V<span style="color:#f92672">=</span> vertices <span style="color:#75715e">#No. of vertices</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> defaultdict(list) <span style="color:#75715e"># default dictionary to store graph</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>Time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># function to add an edge to graph</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addEdge</span>(self,u,v):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph[u]<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph[v]<span style="color:#f92672">.</span>append(u)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    A recursive function that finds and prints bridges
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	using DFS traversal
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	u --&gt; The vertex to be visited next
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	visited[] --&gt; keeps track of visited vertices
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	disc[] --&gt; Stores discovery times of visited vertices
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	parent[] --&gt; Stores parent vertices in DFS tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bridgeUtil</span>(self, u, visited, parent, low, disc):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Mark the current node as visited and print it</span>
</span></span><span style="display:flex;"><span>		visited[u]<span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Initialize discovery time and low value</span>
</span></span><span style="display:flex;"><span>		disc[u] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>Time
</span></span><span style="display:flex;"><span>		low[u] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>Time
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>Time <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#Recur for all the vertices adjacent to this vertex</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[u]:
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># If v is not visited yet, then make it a child of u in DFS tree and recur for it</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> visited[v] <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span> :
</span></span><span style="display:flex;"><span>				parent[v] <span style="color:#f92672">=</span> u
</span></span><span style="display:flex;"><span>				self<span style="color:#f92672">.</span>bridgeUtil(v, visited, parent, low, disc)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># Check if the subtree rooted with v has a connection to one of the ancestors of u</span>
</span></span><span style="display:flex;"><span>				low[u] <span style="color:#f92672">=</span> min(low[u], low[v])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#e6db74">&#39;&#39;&#39; If the lowest vertex reachable from subtree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">				under v is below u in DFS tree, then u-v is
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">				a bridge&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> low[v] <span style="color:#f92672">&gt;</span> disc[u]:
</span></span><span style="display:flex;"><span>					print (<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span>(u,v))
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>					
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">elif</span> v <span style="color:#f92672">!=</span> parent[u]: <span style="color:#75715e"># Update low value of u for parent function calls.</span>
</span></span><span style="display:flex;"><span>				low[u] <span style="color:#f92672">=</span> min(low[u], disc[v])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># DFS based function to find all bridges. It uses recursive function bridgeUtil()</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bridge</span>(self):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Mark all the vertices as not visited and Initialize parent and visited, and ap(articulation point) arrays</span>
</span></span><span style="display:flex;"><span>		visited <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> (self<span style="color:#f92672">.</span>V)
</span></span><span style="display:flex;"><span>		disc <span style="color:#f92672">=</span> [float(<span style="color:#e6db74">&#34;Inf&#34;</span>)] <span style="color:#f92672">*</span> (self<span style="color:#f92672">.</span>V)
</span></span><span style="display:flex;"><span>		low <span style="color:#f92672">=</span> [float(<span style="color:#e6db74">&#34;Inf&#34;</span>)] <span style="color:#f92672">*</span> (self<span style="color:#f92672">.</span>V)
</span></span><span style="display:flex;"><span>		parent <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> (self<span style="color:#f92672">.</span>V)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Call the recursive helper function to find bridges in DFS tree rooted with vertex &#39;i&#39;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>V):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> visited[i] <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>				self<span style="color:#f92672">.</span>bridgeUtil(i, visited, parent, low, disc)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>g1 <span style="color:#f92672">=</span> Graph(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;Bridges in first graph &#34;</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>bridge()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>g2 <span style="color:#f92672">=</span> Graph(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g2<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>g2<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g2<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Bridges in second graph &#34;</span>)
</span></span><span style="display:flex;"><span>g2<span style="color:#f92672">.</span>bridge()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>g3 <span style="color:#f92672">=</span> Graph (<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>g3<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>g3<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g3<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>g3<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>g3<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g3<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>g3<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g3<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Bridges in third graph &#34;</span>)
</span></span><span style="display:flex;"><span>g3<span style="color:#f92672">.</span>bridge()
</span></span></code></pre></div><h2 id="count-strongly-connected-componentskosaraju-algo">Count Strongly connected Components(Kosaraju Algo)<a hidden class="anchor" aria-hidden="true" href="#count-strongly-connected-componentskosaraju-algo">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self,vertices):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>V<span style="color:#f92672">=</span> vertices 
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> defaultdict(list) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addEdge</span>(self,u,v):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph[u]<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># A function used by DFS</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">DFSUtil</span>(self,v,visited):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Mark the current node as visited and print it</span>
</span></span><span style="display:flex;"><span>		visited[v]<span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>		print (v)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#Recur for all the vertices adjacent to this vertex</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[v]:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> visited[i]<span style="color:#f92672">==</span><span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>				self<span style="color:#f92672">.</span>DFSUtil(i,visited)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fillOrder</span>(self,v,visited, stack):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Mark the current node as visited</span>
</span></span><span style="display:flex;"><span>		visited[v]<span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#Recur for all the vertices adjacent to this vertex</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[v]:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> visited[i]<span style="color:#f92672">==</span><span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>				self<span style="color:#f92672">.</span>fillOrder(i, visited, stack)
</span></span><span style="display:flex;"><span>		stack <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Function that returns reverse (or transpose) of this graph</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getTranspose</span>(self):
</span></span><span style="display:flex;"><span>		g <span style="color:#f92672">=</span> Graph(self<span style="color:#f92672">.</span>V)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Recur for all the vertices adjacent to this vertex</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[i]:
</span></span><span style="display:flex;"><span>				g<span style="color:#f92672">.</span>addEdge(j,i)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> g
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># The main function that finds and prints all strongly connected components</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printSCCs</span>(self):
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		stack <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Mark all the vertices as not visited (For first DFS)</span>
</span></span><span style="display:flex;"><span>		visited <span style="color:#f92672">=</span>[<span style="color:#66d9ef">False</span>]<span style="color:#f92672">*</span>(self<span style="color:#f92672">.</span>V)
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Fill vertices in stack according to their finishing times</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>V):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> visited[i]<span style="color:#f92672">==</span><span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>				self<span style="color:#f92672">.</span>fillOrder(i, visited, stack)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Create a reversed graph</span>
</span></span><span style="display:flex;"><span>		gr <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>getTranspose()
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Mark all the vertices as not visited (For second DFS)</span>
</span></span><span style="display:flex;"><span>		visited <span style="color:#f92672">=</span>[<span style="color:#66d9ef">False</span>]<span style="color:#f92672">*</span>(self<span style="color:#f92672">.</span>V)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Now process all vertices in order defined by Stack</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> stack:
</span></span><span style="display:flex;"><span>			i <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> visited[i]<span style="color:#f92672">==</span><span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>				gr<span style="color:#f92672">.</span>DFSUtil(i, visited)
</span></span><span style="display:flex;"><span>				print()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a graph given in the above diagram</span>
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> Graph(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;Following are strongly connected components &#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;in given graph&#34;</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>printSCCs()
</span></span></code></pre></div><h2 id="check-whether-a-graph-is-bipartite-or-not">Check whether a graph is Bipartite or Not<a hidden class="anchor" aria-hidden="true" href="#check-whether-a-graph-is-bipartite-or-not">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>V <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">colorGraph</span>(G, color, pos, c):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> color[pos] <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, c]:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># color this pos as c and all its neighbours and 1-c</span>
</span></span><span style="display:flex;"><span>	color[pos] <span style="color:#f92672">=</span> c
</span></span><span style="display:flex;"><span>	ans <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> G[pos][i]:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> color[i] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>				ans <span style="color:#f92672">&amp;=</span> colorGraph(G, color, i, <span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>c)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> color[i] <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> c]:
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ans:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isBipartite</span>(G):
</span></span><span style="display:flex;"><span>	color <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> V
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#start is vertex 0</span>
</span></span><span style="display:flex;"><span>	pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># two colors 1 and 0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> colorGraph(G, color, pos, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>G <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> isBipartite(G): print(<span style="color:#e6db74">&#34;Yes&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>: print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span></code></pre></div><h2 id="longest-path-in-a-directed-acyclic-graph">Longest path in a Directed Acyclic Graph<a hidden class="anchor" aria-hidden="true" href="#longest-path-in-a-directed-acyclic-graph">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">topologicalSortUtil</span>(v):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">global</span> Stack, visited, adj
</span></span><span style="display:flex;"><span>	visited[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> adj[v]:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span> visited[i[<span style="color:#ae81ff">0</span>]]):
</span></span><span style="display:flex;"><span>			topologicalSortUtil(i[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>	Stack<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The function to find longest distances from a given vertex. It uses recursive topologicalSortUtil() to get topological sorting.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestPath</span>(s):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">global</span> Stack, visited, adj, V
</span></span><span style="display:flex;"><span>	dist <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(V)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Call the recursive helper function to store Topological Sort starting from all vertices one by one</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (visited[i] <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span>):
</span></span><span style="display:flex;"><span>			topologicalSortUtil(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Initialize distances to all vertices as infinite and distance to source as 0</span>
</span></span><span style="display:flex;"><span>	dist[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Process vertices in topological order</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (len(Stack) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Get the next vertex from topological order</span>
</span></span><span style="display:flex;"><span>		u <span style="color:#f92672">=</span> Stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">del</span> Stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Update distances of all adjacent vertices</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (dist[u] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span>):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> adj[u]:
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (dist[i[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">&lt;</span> dist[u] <span style="color:#f92672">+</span> i[<span style="color:#ae81ff">1</span>]):
</span></span><span style="display:flex;"><span>					dist[i[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">=</span> dist[u] <span style="color:#f92672">+</span> i[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Print calculated longest distances print(dist)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>		print(<span style="color:#e6db74">&#34;INF &#34;</span>,end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#66d9ef">if</span> (dist[i] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">9</span>) <span style="color:#66d9ef">else</span> print(dist[i],end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>V, Stack, visited <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>, [], [<span style="color:#66d9ef">False</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">7</span>)]
</span></span><span style="display:flex;"><span>adj <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">7</span>)]
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a graph given in the above diagram.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Here vertex numbers are 0, 1, 2, 3, 4, 5 with following mappings:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0=r, 1=s, 2=t, 3=x, 4=y, 5=z</span>
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>])
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>])
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>])
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>])
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>])
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">4</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>adj[<span style="color:#ae81ff">4</span>]<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">5</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Following are longest distances from source vertex &#34;</span>,s)
</span></span><span style="display:flex;"><span>longestPath(s)
</span></span></code></pre></div><h2 id="journey-to-the-moon">Journey to the Moon<a hidden class="anchor" aria-hidden="true" href="#journey-to-the-moon">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TODO
</span></span></code></pre></div><h2 id="cheapest-flights-within-k-stops">Cheapest Flights Within K Stops<a hidden class="anchor" aria-hidden="true" href="#cheapest-flights-within-k-stops">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TODO
</span></span></code></pre></div><h2 id="oliver-and-the-game">Oliver and the Game<a hidden class="anchor" aria-hidden="true" href="#oliver-and-the-game">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TODO
</span></span></code></pre></div><h2 id="water-jug-problem-using-bfs">Water Jug problem using BFS<a hidden class="anchor" aria-hidden="true" href="#water-jug-problem-using-bfs">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">You are given an m liter jug and a n liter jug. Both the jugs are initially empty. The jugs don’t have markings to allow measuring smaller quantities. You have to use the jugs to measure d liters of water where d is less than n. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">(X, Y) corresponds to a state where X refers to the amount of water in Jug1 and Y refers to the amount of water in Jug2 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Determine the path from the initial state (xi, yi) to the final state (xf, yf), where (xi, yi) is (0, 0) which indicates both Jugs are initially empty and (xf, yf) indicates a state which could be (0, d) or (d, 0).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The operations you can perform are: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Empty a Jug, (X, Y)-&gt;(0, Y) Empty Jug 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Fill a Jug, (0, 0)-&gt;(X, 0) Fill Jug 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Pour water from one jug to the other until one of the jugs is either empty or full, (X, Y) -&gt; (X-d, Y+d)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Examples: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : 4 3 2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : {(0, 0), (0, 3), (3, 0), (3, 3), (4, 2), (0, 2)}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">BFS</span>(a, b, target):
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Map is used to store the states, every state is hashed to binary value to indicate either that state is visited before or not</span>
</span></span><span style="display:flex;"><span>	m <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>	isSolvable <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>	path <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Queue to maintain states</span>
</span></span><span style="display:flex;"><span>	q <span style="color:#f92672">=</span> deque()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Initialing with initial state</span>
</span></span><span style="display:flex;"><span>	q<span style="color:#f92672">.</span>append((<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (len(q) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Current state</span>
</span></span><span style="display:flex;"><span>		u <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">#q.pop() #pop off used state</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># If this state is already visited</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((u[<span style="color:#ae81ff">0</span>], u[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">in</span> m):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Doesn&#39;t met jug constraints</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((u[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> a <span style="color:#f92672">or</span> u[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> b <span style="color:#f92672">or</span>
</span></span><span style="display:flex;"><span>			u[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> u[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Filling the vector for constructing the solution path</span>
</span></span><span style="display:flex;"><span>		path<span style="color:#f92672">.</span>append([u[<span style="color:#ae81ff">0</span>], u[<span style="color:#ae81ff">1</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Marking current state as visited</span>
</span></span><span style="display:flex;"><span>		m[(u[<span style="color:#ae81ff">0</span>], u[<span style="color:#ae81ff">1</span>])] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># If we reach solution state, put ans=1</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (u[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> target <span style="color:#f92672">or</span> u[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> target):
</span></span><span style="display:flex;"><span>			isSolvable <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (u[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> target):
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (u[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>					
</span></span><span style="display:flex;"><span>					<span style="color:#75715e"># Fill final state</span>
</span></span><span style="display:flex;"><span>					path<span style="color:#f92672">.</span>append([u[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (u[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>					<span style="color:#75715e"># Fill final state</span>
</span></span><span style="display:flex;"><span>					path<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">0</span>, u[<span style="color:#ae81ff">1</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Print the solution path</span>
</span></span><span style="display:flex;"><span>			sz <span style="color:#f92672">=</span> len(path)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(sz):
</span></span><span style="display:flex;"><span>				print(<span style="color:#e6db74">&#34;(&#34;</span>, path[i][<span style="color:#ae81ff">0</span>], <span style="color:#e6db74">&#34;,&#34;</span>,
</span></span><span style="display:flex;"><span>						path[i][<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;)&#34;</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># If we have not reached final state then, start developing intermediate states to reach solution state</span>
</span></span><span style="display:flex;"><span>		q<span style="color:#f92672">.</span>append([u[<span style="color:#ae81ff">0</span>], b]) <span style="color:#75715e"># Fill Jug2</span>
</span></span><span style="display:flex;"><span>		q<span style="color:#f92672">.</span>append([a, u[<span style="color:#ae81ff">1</span>]]) <span style="color:#75715e"># Fill Jug1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> ap <span style="color:#f92672">in</span> range(max(a, b) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Pour amount ap from Jug2 to Jug1</span>
</span></span><span style="display:flex;"><span>			c <span style="color:#f92672">=</span> u[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> ap
</span></span><span style="display:flex;"><span>			d <span style="color:#f92672">=</span> u[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> ap
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Check if this state is possible or not</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> a <span style="color:#f92672">or</span> (d <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> d <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)):
</span></span><span style="display:flex;"><span>				q<span style="color:#f92672">.</span>append([c, d])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Pour amount ap from Jug 1 to Jug2</span>
</span></span><span style="display:flex;"><span>			c <span style="color:#f92672">=</span> u[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> ap
</span></span><span style="display:flex;"><span>			d <span style="color:#f92672">=</span> u[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> ap
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Check if this state is possible or not</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> ((c <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> c <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">or</span> d <span style="color:#f92672">==</span> b):
</span></span><span style="display:flex;"><span>				q<span style="color:#f92672">.</span>append([c, d])
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Empty Jug2</span>
</span></span><span style="display:flex;"><span>		q<span style="color:#f92672">.</span>append([a, <span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Empty Jug1</span>
</span></span><span style="display:flex;"><span>		q<span style="color:#f92672">.</span>append([<span style="color:#ae81ff">0</span>, b])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># No, solution exists if ans=0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span> isSolvable):
</span></span><span style="display:flex;"><span>		print (<span style="color:#e6db74">&#34;No solution&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Jug1, Jug2, target <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Path from initial state to solution state ::&#34;</span>)
</span></span><span style="display:flex;"><span>BFS(Jug1, Jug2, target)
</span></span></code></pre></div><h2 id="find-if-there-is-a-path-of-more-thank-length-from-a-source">Find if there is a path of more thank length from a source<a hidden class="anchor" aria-hidden="true" href="#find-if-there-is-a-path-of-more-thank-length-from-a-source">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a graph, a source vertex in the graph and a number k, find if there is a simple path (without any cycle) starting from given source and ending at any other vertex such that the distance from source to that vertex is atleast ‘k’ length.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Example:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input  : Source s = 0, k = 58
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : True
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">There exists a simple path 0 -&gt; 7 -&gt; 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">-&gt; 2 -&gt; 8 -&gt; 6 -&gt; 5 -&gt; 3 -&gt; 4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Which has a total distance of 60 km which
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">is more than 58.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input  : Source s = 0, k = 62
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : False
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">In the above graph, the longest simple
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">path has distance 61 (0 -&gt; 7 -&gt; 1-&gt; 2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> -&gt; 3 -&gt; 4 -&gt; 5-&gt; 6 -&gt; 8, so output 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">should be false for any input greater 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">than 61.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Program to find if there is a simple path with</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># weight more than k</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This class represents a dipathted graph using</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># adjacency list representation</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Allocates memory for adjacency list</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self, V):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>V <span style="color:#f92672">=</span> V
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>adj <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(V)]
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Returns true if graph has path more than k length</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pathMoreThanK</span>(self,src, k):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Create a path array with nothing included in path</span>
</span></span><span style="display:flex;"><span>		path <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>]<span style="color:#f92672">*</span>self<span style="color:#f92672">.</span>V
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Add source vertex to path</span>
</span></span><span style="display:flex;"><span>		path[src] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>pathMoreThanKUtil(src, k, path)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Prints shortest paths from src to all other vertices</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pathMoreThanKUtil</span>(self,src, k, path):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># If k is 0 or negative, return true</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (k <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Get all adjacent vertices of source vertex src and recursively explore all paths from src.</span>
</span></span><span style="display:flex;"><span>		i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> i <span style="color:#f92672">!=</span> len(self<span style="color:#f92672">.</span>adj[src]):
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Get adjacent vertex and weight of edge</span>
</span></span><span style="display:flex;"><span>			v <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>adj[src][i][<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>			w <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>adj[src][i][<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>			i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># If vertex v is already there in path, then there is a cycle (we ignore this edge)</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (path[v] <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>):
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># If weight of is more than k, return true</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (w <span style="color:#f92672">&gt;=</span> k):
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Else add this vertex to path</span>
</span></span><span style="display:flex;"><span>			path[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># If this adjacent can provide a path longer than k, return true.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (self<span style="color:#f92672">.</span>pathMoreThanKUtil(v, k<span style="color:#f92672">-</span>w, path)):
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Backtrack</span>
</span></span><span style="display:flex;"><span>			path[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># If no adjacent could produce longer path, return false</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Utility function to an edge (u, v) of weight w</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addEdge</span>(self,u, v, w):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>adj[u]<span style="color:#f92672">.</span>append([v, w])
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>adj[v]<span style="color:#f92672">.</span>append([u, w])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># create the graph given in above figure</span>
</span></span><span style="display:flex;"><span>V <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> Graph(V)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># making above shown graph</span>
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">9</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>src <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">62</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> g<span style="color:#f92672">.</span>pathMoreThanK(src, k):
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;Yes&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">60</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> g<span style="color:#f92672">.</span>pathMoreThanK(src, k):
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;Yes&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span></code></pre></div><h2 id="minimum-edges-to-reverse-o-make-path-from-source-to-destination">Minimum edges to reverse o make path from source to destination<a hidden class="anchor" aria-hidden="true" href="#minimum-edges-to-reverse-o-make-path-from-source-to-destination">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a directed graph and a source node and destination node, we need to find how many edges we need to reverse in order to make at least 1 path from the source node to the destination node.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addEdge</span>(u, v, w):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">global</span> adj
</span></span><span style="display:flex;"><span>	adj[u]<span style="color:#f92672">.</span>append((v, w))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">shortestPath</span>(src):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Create a set to store vertices that are being preprocessed</span>
</span></span><span style="display:flex;"><span>	setds <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Create a vector for distances and initialize all distances as infinite (INF)</span>
</span></span><span style="display:flex;"><span>	dist <span style="color:#f92672">=</span> [<span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">18</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(V)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Insert source itself in Set and initialize its</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">global</span> adj
</span></span><span style="display:flex;"><span>	setds[(<span style="color:#ae81ff">0</span>, src)] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	dist[src] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> setds:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># The first vertex in Set is the minimum distance vertex, extract it from set.</span>
</span></span><span style="display:flex;"><span>		tmp <span style="color:#f92672">=</span> list(setds<span style="color:#f92672">.</span>keys())[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">del</span> setds[tmp]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># vertex label is stored in second of pair (it has to be done this way to keep the vertices sorted distance (distance must be first item in pair)</span>
</span></span><span style="display:flex;"><span>		u <span style="color:#f92672">=</span> tmp[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># &#39;i&#39; is used to get all adjacent vertices of a vertex</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># list&lt; pair&lt;int, int&gt; &gt;::iterator i;</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> adj[u]:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Get vertex label and weight of current adjacent</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># of u.</span>
</span></span><span style="display:flex;"><span>			v <span style="color:#f92672">=</span> i[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>			weight <span style="color:#f92672">=</span> i[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># If there is shorter path to v through u.</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (dist[v] <span style="color:#f92672">&gt;</span> dist[u] <span style="color:#f92672">+</span> weight):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># /* If distance of v is not INF then it must be in</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">#	 our set, so removing it and inserting again</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">#	 with updated less distance.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">#	 Note : We extract only those vertices from Set</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">#	 for which distance is finalized. So for them,</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">#	 we would never reach here. */</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (dist[v] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">18</span>):
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">del</span> setds[(dist[v], v)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># Updating distance of v</span>
</span></span><span style="display:flex;"><span>				dist[v] <span style="color:#f92672">=</span> dist[u] <span style="color:#f92672">+</span> weight
</span></span><span style="display:flex;"><span>				setds[(dist[v], v)] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> dist
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># method adds reverse edge of each original edge in the graph. It gives reverse edge a weight = 1 and all original edges a weight of 0. Now, the length of the shortest path will give us the answer. If shortest path is p: it means we used p reverse edges in the shortest path. </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">modelGraphWithEdgeWeight</span>(edge, E, V):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">global</span> adj
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(E):
</span></span><span style="display:flex;"><span>		addEdge(edge[i][<span style="color:#ae81ff">0</span>], edge[i][<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">0</span>) <span style="color:#75715e"># original edge : weight 0</span>
</span></span><span style="display:flex;"><span>		addEdge(edge[i][<span style="color:#ae81ff">1</span>], edge[i][<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">1</span>) <span style="color:#75715e"># reverse edge : weight 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Method returns minimum number of edges to be reversed to reach from src to dest</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getMinEdgeReversal</span>(edge, E, V,src, dest):
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># get modified graph with edge weight</span>
</span></span><span style="display:flex;"><span>	modelGraphWithEdgeWeight(edge, E, V)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># get shortes path vector</span>
</span></span><span style="display:flex;"><span>	dist <span style="color:#f92672">=</span> shortestPath(src)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># If distance of destination is still INF, not possible</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> (dist[dest] <span style="color:#f92672">==</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">18</span>) <span style="color:#66d9ef">else</span> dist[dest]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>V <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>edge <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>], [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">4</span>], [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>]]
</span></span><span style="display:flex;"><span>E, adj <span style="color:#f92672">=</span> len(edge), [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(V <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]
</span></span><span style="display:flex;"><span>minEdgeToReverse <span style="color:#f92672">=</span> getMinEdgeReversal(edge, E, V, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (minEdgeToReverse <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>	print(minEdgeToReverse)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;Not possible&#34;</span>)
</span></span></code></pre></div><h2 id="paths-to-travel-each-nodes-using-each-edgeseven-bridges">Paths to travel each nodes using each edge(Seven Bridges)<a hidden class="anchor" aria-hidden="true" href="#paths-to-travel-each-nodes-using-each-edgeseven-bridges">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TODO
</span></span></code></pre></div><h2 id="vertex-cover-problem">Vertex Cover Problem<a hidden class="anchor" aria-hidden="true" href="#vertex-cover-problem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">There are n nodes and m bridges in between these nodes. Print the possible path through each node using each edges (if possible), traveling through each edges only once.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self, vertices):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>V <span style="color:#f92672">=</span> vertices
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> defaultdict(list)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addEdge</span>(self, u, v):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>graph[u]<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printVertexCover</span>(self):
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Initialize all vertices as not visited.</span>
</span></span><span style="display:flex;"><span>		visited <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> (self<span style="color:#f92672">.</span>V)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Consider all edges one by one</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> u <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>V):
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># An edge is only picked when both visited[u] and visited[v] are false</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> visited[u]:
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># Go through all adjacents of u and pick the first not yet visited</span>
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># vertex (We are basically picking an edge (u, v) from remaining edges.</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[u]:
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> visited[v]:
</span></span><span style="display:flex;"><span>						
</span></span><span style="display:flex;"><span>						<span style="color:#75715e"># Add the vertices (u, v) to the</span>
</span></span><span style="display:flex;"><span>						<span style="color:#75715e"># result set. We make the vertex u and v visited so that all</span>
</span></span><span style="display:flex;"><span>						<span style="color:#75715e"># edges from/to them would be ignored</span>
</span></span><span style="display:flex;"><span>						visited[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>						visited[u] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Print the vertex cover</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>V):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> visited[j]:
</span></span><span style="display:flex;"><span>				print(j, end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>		print()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> Graph(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>printVertexCover()
</span></span></code></pre></div><h2 id="chinese-postman-or-route-inspection">Chinese Postman or Route Inspection<a hidden class="anchor" aria-hidden="true" href="#chinese-postman-or-route-inspection">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TODO
</span></span></code></pre></div><h2 id="number-of-triangles-in-a-directed-and-undirected-graph">Number of Triangles in a Directed and Undirected Graph<a hidden class="anchor" aria-hidden="true" href="#number-of-triangles-in-a-directed-and-undirected-graph">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a Graph, count number of triangles in it. The graph is can be directed or undirected.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Example: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: digraph[V][V] = { {0, 0, 1, 0},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        {1, 0, 0, 1},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        {0, 1, 0, 0},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        {0, 0, 1, 0}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                      };
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: 2
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Give adjacency matrix represents following 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">directed graph.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># function to calculate the number of triangles in a simple directed/undirected graph.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># isDirected is true if the graph is directed, its false otherwise</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countTriangle</span>(g, isDirected):
</span></span><span style="display:flex;"><span>    nodes <span style="color:#f92672">=</span> len(g)
</span></span><span style="display:flex;"><span>    count_Triangle <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Consider every possible triplet of edges in graph</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(nodes):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(nodes):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(nodes):
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># check the triplet if it satisfies the condition</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">!=</span> j <span style="color:#f92672">and</span> i <span style="color:#f92672">!=</span> k <span style="color:#f92672">and</span> j <span style="color:#f92672">!=</span> k <span style="color:#f92672">and</span> g[i][j] <span style="color:#f92672">and</span> g[j][k] <span style="color:#f92672">and</span> g[k][i]):
</span></span><span style="display:flex;"><span>                    count_Triangle <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>          
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If graph is directed , division is done by 3 else division by 6 is done</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> isDirected:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> (count_Triangle<span style="color:#f92672">//</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>: 
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> (count_Triangle<span style="color:#f92672">//</span><span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create adjacency matrix of an undirected graph</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>		[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>		[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>		[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]]
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create adjacency matrix of a directed graph</span>
</span></span><span style="display:flex;"><span>digraph <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>		[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>		[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>		[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;The Number of triangles in undirected graph : </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span>
</span></span><span style="display:flex;"><span>	countTriangle(graph, <span style="color:#66d9ef">False</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;The Number of triangles in directed graph : </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span>
</span></span><span style="display:flex;"><span>	countTriangle(digraph, <span style="color:#66d9ef">True</span>))
</span></span></code></pre></div><h2 id="minimise-the-cashflow-among-a-given-set-of-friends-who-have-borrowed-money-from-each-other">Minimise the cashflow among a given set of friends who have borrowed money from each other<a hidden class="anchor" aria-hidden="true" href="#minimise-the-cashflow-among-a-given-set-of-friends-who-have-borrowed-money-from-each-other">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a number of friends who have to give or take some amount of money from one another. Design an algorithm by which the total cash flow among all the friends is minimized. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Number of persons(or vertices in graph)</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function that returns index of minimum value in arr[]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getMin</span>(arr):
</span></span><span style="display:flex;"><span>	minInd <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (arr[i] <span style="color:#f92672">&lt;</span> arr[minInd]):
</span></span><span style="display:flex;"><span>			minInd <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> minInd
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function that returns index of maximum value in arr[]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getMax</span>(arr):
</span></span><span style="display:flex;"><span>	maxInd <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (arr[i] <span style="color:#f92672">&gt;</span> arr[maxInd]):
</span></span><span style="display:flex;"><span>			maxInd <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> maxInd
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minOf2</span>(x, y):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> x <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&lt;</span> y <span style="color:#66d9ef">else</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># amount[p] indicates the net amount to be credited/debited to/from person &#39;p&#39; If amount[p] is positive, then i&#39;th person will amount[i] If amount[p] is negative, then i&#39;th person will give -amount[i]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minCashFlowRec</span>(amount):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Find the indexes of minimum and maximum values in amount[] amount[mxCredit] indicates the maximum amount to be given(or credited) to any person. And amount[mxDebit] indicates the maximum amount to be taken (or debited) from any person. So if there is a positive value in amount[], then there must be a negative value</span>
</span></span><span style="display:flex;"><span>	mxCredit <span style="color:#f92672">=</span> getMax(amount)
</span></span><span style="display:flex;"><span>	mxDebit <span style="color:#f92672">=</span> getMin(amount)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># If both amounts are 0, then all amounts are settled</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (amount[mxCredit] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> amount[mxDebit] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Find the minimum of two amounts</span>
</span></span><span style="display:flex;"><span>	min <span style="color:#f92672">=</span> minOf2(<span style="color:#f92672">-</span>amount[mxDebit], amount[mxCredit])
</span></span><span style="display:flex;"><span>	amount[mxCredit] <span style="color:#f92672">-=</span>min
</span></span><span style="display:flex;"><span>	amount[mxDebit] <span style="color:#f92672">+=</span> min
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># If minimum is the maximum amount to be</span>
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;Person &#34;</span> , mxDebit , <span style="color:#e6db74">&#34; pays &#34;</span> , min
</span></span><span style="display:flex;"><span>		, <span style="color:#e6db74">&#34; to &#34;</span> , <span style="color:#e6db74">&#34;Person &#34;</span> , mxCredit)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Recur for the amount array. Note that it is guaranteed that the recursion would terminate as either amount[mxCredit] or amount[mxDebit] becomes 0</span>
</span></span><span style="display:flex;"><span>	minCashFlowRec(amount)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Given a set of persons as graph[] where graph[i][j] indicates the amount that person i needs to pay person j, this function finds and prints the minimum cash flow to settle all debts.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minCashFlow</span>(graph):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Create an array amount[], initialize all value in it as 0.</span>
</span></span><span style="display:flex;"><span>	amount <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Calculate the net amount to be paid to person &#39;p&#39;, and stores it in amount[p]. The value of amount[p] can be calculated by subtracting debts of &#39;p&#39; from credits of &#39;p&#39;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>			amount[p] <span style="color:#f92672">+=</span> (graph[i][p] <span style="color:#f92672">-</span> graph[p][i])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	minCashFlowRec(amount)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># graph[i][j] indicates the amount that person i needs to pay person j</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> [ [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1000</span>, <span style="color:#ae81ff">2000</span>],
</span></span><span style="display:flex;"><span>		[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5000</span>],
</span></span><span style="display:flex;"><span>		[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>] ]
</span></span><span style="display:flex;"><span>minCashFlow(graph)
</span></span></code></pre></div><h2 id="two-clique-problem">Two Clique Problem<a hidden class="anchor" aria-hidden="true" href="#two-clique-problem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">A Clique is a subgraph of graph such that all vertices in subgraph are completely connected with each other. Given a Graph, find if it can be divided into two Cliques.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Examples:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : G[][] =   {{0, 1, 1, 0, 0},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  {1, 0, 1, 1, 0},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  {1, 1, 0, 0, 0},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  {0, 1, 0, 0, 1},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                  {0, 0, 0, 1, 0}};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : Yes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> queue <span style="color:#f92672">import</span> Queue
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This function returns true if subgraph reachable from src is Bipartite or not.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isBipartiteUtil</span>(G, src, colorArr):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">global</span> V
</span></span><span style="display:flex;"><span>	colorArr[src] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Create a queue (FIFO) of vertex numbers and enqueue source vertex for BFS traversal</span>
</span></span><span style="display:flex;"><span>	q <span style="color:#f92672">=</span> Queue()
</span></span><span style="display:flex;"><span>	q<span style="color:#f92672">.</span>put(src)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Run while there are vertices in queue (Similar to BFS)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">not</span> q<span style="color:#f92672">.</span>empty()):
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Dequeue a vertex from queue</span>
</span></span><span style="display:flex;"><span>		u <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>get()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># Find all non-colored adjacent vertices</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>			
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># An edge from u to v exists and destination v is not colored</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (G[u][v] <span style="color:#f92672">and</span> colorArr[v] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>				<span style="color:#75715e"># Assign alternate color to this adjacent v of u</span>
</span></span><span style="display:flex;"><span>				colorArr[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> colorArr[u]
</span></span><span style="display:flex;"><span>				q<span style="color:#f92672">.</span>put(v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># An edge from u to v exists and destination v is colored with same color as u</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">elif</span> (G[u][v] <span style="color:#f92672">and</span> colorArr[v] <span style="color:#f92672">==</span> colorArr[u]):
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># If we reach here, then all adjacent vertices can be colored with alternate color</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Returns true if a Graph G[][] is Bipartite or Note that G may not be connected.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isBipartite</span>(G):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">global</span> V
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Create a color array to store colors assigned to all vertices. Vertex number is used as index in this array. The value &#39;-1&#39; of colorArr[i] is used to indicate that no color is assigned to vertex &#39;i&#39;. The value 1 is used to indicate first color is assigned and value 0 indicates second color is assigned.</span>
</span></span><span style="display:flex;"><span>	colorArr <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> V
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># One by one check all not yet colored vertices.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (colorArr[i] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (isBipartiteUtil(G, i, colorArr) <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span>):
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Returns true if G can be divided into</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># two Cliques, else false.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canBeDividedinTwoCliques</span>(G):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">global</span> V
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Find complement of G[][] All values are complemented except diagonal ones</span>
</span></span><span style="display:flex;"><span>	GC <span style="color:#f92672">=</span> [[<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> V <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(V)]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(V):
</span></span><span style="display:flex;"><span>			GC[i][j] <span style="color:#f92672">=</span> <span style="color:#f92672">not</span> G[i][j] <span style="color:#66d9ef">if</span> i <span style="color:#f92672">!=</span> j <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e"># Return true if complement is Bipartite else false.</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> isBipartite(GC)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>V <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>G <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>	[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]]
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> canBeDividedinTwoCliques(G):
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;Yes&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://atharvashah.netlify.app/tags/dsa-python/">DSA-Python</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://atharvashah.netlify.app/blog/dsapython/elementry-algos/">
    <span class="title">« Prev</span>
    <br>
    <span>DSA in Python - Elementry Algos</span>
  </a>
  <a class="next" href="https://atharvashah.netlify.app/blog/dsapython/greedy/">
    <span class="title">Next »</span>
    <br>
    <span>DSA in Python - Greedy</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Graph on twitter"
        href="https://twitter.com/intent/tweet/?text=DSA%20in%20Python%20-%20Graph&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fgraph%2f&amp;hashtags=DSA-Python">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Graph on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fgraph%2f&amp;title=DSA%20in%20Python%20-%20Graph&amp;summary=DSA%20in%20Python%20-%20Graph&amp;source=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fgraph%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Graph on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fgraph%2f&title=DSA%20in%20Python%20-%20Graph">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Graph on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fgraph%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Graph on whatsapp"
        href="https://api.whatsapp.com/send?text=DSA%20in%20Python%20-%20Graph%20-%20https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fgraph%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Graph on telegram"
        href="https://telegram.me/share/url?text=DSA%20in%20Python%20-%20Graph&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fgraph%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-atharvashah-netlify-app" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    (function() {
        
        
        if (window.location.hostname == "localhost")
            return;

        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        var disqus_shortname = 'https-atharvashah-netlify-app';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://atharvashah.netlify.app/">Atharva Shah</a></span> 
    | <span><a href="/privacy-policy/" target="_blank">Privacy Policy</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function() {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function(e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function() {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {};
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
