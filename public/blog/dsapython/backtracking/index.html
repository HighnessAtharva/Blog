<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DSA in Python - Backtracking | Atharva Shah</title>
<meta name="keywords" content="DSA-Python">
<meta name="description" content="Rat in a maze Problem Printing all solutions in N-Queen Problem Word Break Problem using Backtracking Remove Invalid Parentheses Sudoku Solver m-Colouring Problem Print all palindromic partitions of a string Subset Sum Problem The Knight’s tour problem Tug of War Find shortest safe route in a path with landmines Combinational Sum Find Maximum number possible by doing at-most K swaps Print all permutations of a string Find if there is a path of more than k length from a source Longest Possible Route in a Matrix with Hurdles Print all possible paths from top left to bottom right of a mXn matrix Partition of a set intoK subsets with equal sum Find the K-th Permutation Sequence of first N natural numbers Rat in a maze Problem &#34;&#34;&#34; N = 4 m[][] = {{1, 0, 0, 0}, {1, 1, 0, 1}, {1, 1, 0, 0}, {0, 1, 1, 1}} Output: DDRDRR DRDDRR Explanation: The rat can reach the destination at (3, 3) from (0, 0) by two paths - DRDDRR and DDRDRR, when printed in sorted order we get DDRDRR DRDDRR.">
<meta name="author" content="">
<link rel="canonical" href="https://atharvashah.netlify.app/blog/dsapython/backtracking/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3aeba09d5c04bb513a113d9fd3cab93b81640d19be7d4d68e228d9263fd84b30.css" integrity="sha256-OuugnVwEu1E6ET2f08q5O4FkDRm&#43;fU1o4ijZJj/YSzA=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://atharvashah.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://atharvashah.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://atharvashah.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://atharvashah.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://atharvashah.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="DSA in Python - Backtracking" />
<meta property="og:description" content="Rat in a maze Problem Printing all solutions in N-Queen Problem Word Break Problem using Backtracking Remove Invalid Parentheses Sudoku Solver m-Colouring Problem Print all palindromic partitions of a string Subset Sum Problem The Knight’s tour problem Tug of War Find shortest safe route in a path with landmines Combinational Sum Find Maximum number possible by doing at-most K swaps Print all permutations of a string Find if there is a path of more than k length from a source Longest Possible Route in a Matrix with Hurdles Print all possible paths from top left to bottom right of a mXn matrix Partition of a set intoK subsets with equal sum Find the K-th Permutation Sequence of first N natural numbers Rat in a maze Problem &#34;&#34;&#34; N = 4 m[][] = {{1, 0, 0, 0}, {1, 1, 0, 1}, {1, 1, 0, 0}, {0, 1, 1, 1}} Output: DDRDRR DRDDRR Explanation: The rat can reach the destination at (3, 3) from (0, 0) by two paths - DRDDRR and DDRDRR, when printed in sorted order we get DDRDRR DRDDRR." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://atharvashah.netlify.app/blog/dsapython/backtracking/" />
<meta property="og:image" content="https://atharvashah.netlify.app/blog/dsa/backtracking.jpg" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-07-07T23:18:34&#43;05:30" />
<meta property="article:modified_time" content="2022-07-07T23:18:34&#43;05:30" /><meta property="og:site_name" content="Atharva Shah" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://atharvashah.netlify.app/blog/dsa/backtracking.jpg" />
<meta name="twitter:title" content="DSA in Python - Backtracking"/>
<meta name="twitter:description" content="Rat in a maze Problem Printing all solutions in N-Queen Problem Word Break Problem using Backtracking Remove Invalid Parentheses Sudoku Solver m-Colouring Problem Print all palindromic partitions of a string Subset Sum Problem The Knight’s tour problem Tug of War Find shortest safe route in a path with landmines Combinational Sum Find Maximum number possible by doing at-most K swaps Print all permutations of a string Find if there is a path of more than k length from a source Longest Possible Route in a Matrix with Hurdles Print all possible paths from top left to bottom right of a mXn matrix Partition of a set intoK subsets with equal sum Find the K-th Permutation Sequence of first N natural numbers Rat in a maze Problem &#34;&#34;&#34; N = 4 m[][] = {{1, 0, 0, 0}, {1, 1, 0, 1}, {1, 1, 0, 0}, {0, 1, 1, 1}} Output: DDRDRR DRDDRR Explanation: The rat can reach the destination at (3, 3) from (0, 0) by two paths - DRDDRR and DDRDRR, when printed in sorted order we get DDRDRR DRDDRR."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://atharvashah.netlify.app/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "DSA in Python - Backtracking",
      "item": "https://atharvashah.netlify.app/blog/dsapython/backtracking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DSA in Python - Backtracking",
  "name": "DSA in Python - Backtracking",
  "description": "Rat in a maze Problem Printing all solutions in N-Queen Problem Word Break Problem using Backtracking Remove Invalid Parentheses Sudoku Solver m-Colouring Problem Print all palindromic partitions of a string Subset Sum Problem The Knight’s tour problem Tug of War Find shortest safe route in a path with landmines Combinational Sum Find Maximum number possible by doing at-most K swaps Print all permutations of a string Find if there is a path of more than k length from a source Longest Possible Route in a Matrix with Hurdles Print all possible paths from top left to bottom right of a mXn matrix Partition of a set intoK subsets with equal sum Find the K-th Permutation Sequence of first N natural numbers Rat in a maze Problem \u0026#34;\u0026#34;\u0026#34; N = 4 m[][] = {{1, 0, 0, 0}, {1, 1, 0, 1}, {1, 1, 0, 0}, {0, 1, 1, 1}} Output: DDRDRR DRDDRR Explanation: The rat can reach the destination at (3, 3) from (0, 0) by two paths - DRDDRR and DDRDRR, when printed in sorted order we get DDRDRR DRDDRR.",
  "keywords": [
    "DSA-Python"
  ],
  "articleBody": " Rat in a maze Problem Printing all solutions in N-Queen Problem Word Break Problem using Backtracking Remove Invalid Parentheses Sudoku Solver m-Colouring Problem Print all palindromic partitions of a string Subset Sum Problem The Knight’s tour problem Tug of War Find shortest safe route in a path with landmines Combinational Sum Find Maximum number possible by doing at-most K swaps Print all permutations of a string Find if there is a path of more than k length from a source Longest Possible Route in a Matrix with Hurdles Print all possible paths from top left to bottom right of a mXn matrix Partition of a set intoK subsets with equal sum Find the K-th Permutation Sequence of first N natural numbers Rat in a maze Problem \"\"\" N = 4 m[][] = {{1, 0, 0, 0}, {1, 1, 0, 1}, {1, 1, 0, 0}, {0, 1, 1, 1}} Output: DDRDRR DRDDRR Explanation: The rat can reach the destination at (3, 3) from (0, 0) by two paths - DRDDRR and DDRDRR, when printed in sorted order we get DDRDRR DRDDRR. \"\"\" def setup(): global v v = [[0 for i in range(100)] for j in range(100)] global ans ans = [] def path(arr, x, y, pth, n): if x==n-1 and y==n-1: global ans ans.append(pth) return global v if arr[x][y]==0 or v[x][y]==1: return v[x][y]=1 if x\u003e0: path(arr, x-1, y, pth+'U', n) if y\u003e0: path(arr, x, y-1, pth+'L', n) if x\u003cn-1: path(arr, x+1, y, pth+'D', n) if y\u003cn-1: path(arr, x, y+1, pth+'R', n) v[x][y]=0 def findPath(m, n): global ans ans= [] if m[0][0] == 0 or m[n-1][n-1]==0 : return ans setup() path(m, 0, 0, \"\", n) ans.sort() return ans m = [ [ 1, 0, 0, 0, 0 ], [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 0, 1 ], [ 0, 0, 0, 0, 1 ],[ 0, 0, 0, 0, 1 ] ] n = len(m) print(findPath(m, n)) Printing all solutions in N-Queen Problem def isSafe(mat, r, c): # return false if two queens share the same column for i in range(r): if mat[i][c] == 'Q': return False # return false if two queens share the same `` diagonal (i, j) = (r, c) while i \u003e= 0 and j \u003e= 0: if mat[i][j] == 'Q': return False i = i - 1 j = j - 1 # return false if two queens share the same `/` diagonal (i, j) = (r, c) while i \u003e= 0 and j \u003c len(mat): if mat[i][j] == 'Q': return False i = i - 1 j = j + 1 return True def printSolution(mat): for r in mat: print(str(r).replace(',', '').replace('\\'', '')) print() def nQueen(mat, r): # if `N` queens are placed successfully, print the solution if r == len(mat): printSolution(mat) return # place queen at every square in the current row `r` # and recur for each valid movement for i in range(len(mat)): # if no two queens threaten each other if isSafe(mat, r, i): # place queen on the current square mat[r][i] = 'Q' # recur for the next row nQueen(mat, r + 1) # backtrack and remove the queen from the current square mat[r][i] = '–' # `N × N` chessboard N = 8 # `mat[][]` keeps track of the position of queens in # the current configuration mat = [['–' for x in range(N)] for y in range(N)] nQueen(mat, 0) Word Break Problem using Backtracking # A recursive program to print all possible partitions of a given string into dictionary words # A utility function to check whether a word is present in dictionary or not. An array of strings is used for dictionary. Using array of strings for dictionary is definitely not a good idea. We have used for simplicity of the program def dictionaryContains(word): dictionary = {\"mobile\", \"samsung\", \"sam\", \"sung\", \"man\", \"mango\", \"icecream\", \"and\", \"go\", \"i\", \"love\", \"ice\", \"cream\"} return word in dictionary # Prints all possible word breaks of given string def wordBreak(string): # Last argument is prefix wordBreakUtil(string, len(string), \"\") # Result store the current prefix with spaces # between words def wordBreakUtil(string, n, result): # Process all prefixes one by one for i in range(1, n + 1): # Extract substring from 0 to i in prefix prefix = string[:i] # If dictionary contains this prefix, then # we check for remaining string. Otherwise # we ignore this prefix (there is no else for # this if) and try next if dictionaryContains(prefix): # If no more elements are there, print it if i == n: # Add this element to previous prefix result += prefix print(result) return wordBreakUtil(string[i:], n - i, result+prefix+\" \") print(\"First Test:\") wordBreak(\"iloveicecreamandmango\") print(\"\\nSecond Test:\") wordBreak(\"ilovesamsungmobile\") Remove Invalid Parentheses from collections import deque def isValidString(string): left = 0 right = 0 index = 0 while index \u003c len(string): if string[index] == '(': left += 1 elif string[index] == ')': if left \u003e 0: left -= 1 else: right += 1 if right \u003e left: return False index += 1 return left == right def removeInvalidParentheses(string): visited = set() result = [] q = deque() valid = False visited.add(string) q.append(string) # BFS. while len(q) \u003e 0: possibleAnswer = q.popleft() # Check whether 'possibleAnswer' is valid or not. if isValidString(possibleAnswer): result.append(possibleAnswer) valid = True # If true, then the solution exists at current level. No need to move at next state. if valid == True: continue # Generate all possible next state of Strings from current String. for i in range(len(possibleAnswer)): if possibleAnswer[i] == '(' or possibleAnswer[i] == ')': temp = possibleAnswer[0 : i] + possibleAnswer[i + 1 : len(possibleAnswer)] if temp not in visited: q.append(temp) visited.add(temp) return sorted(result) print(removeInvalidParentheses(')(()))')) print(removeInvalidParentheses('(((a))) ((a))()')) Sudoku Solver # N is the size of the 2D matrix N*N N = 9 # A utility function to print grid def printing(arr): for i in range(N): for j in range(N): print(arr[i][j], end = \" \") print() # Checks whether it will be legal to assign num to the given row, col def isSafe(grid, row, col, num): # Check if we find the same num in the similar row , we return false for x in range(9): if grid[row][x] == num: return False # Check if we find the same num in the similar column , we return false for x in range(9): if grid[x][col] == num: return False # Check if we find the same num in the particular 3*3 matrix, we return false startRow = row - row % 3 startCol = col - col % 3 for i in range(3): for j in range(3): if grid[i + startRow][j + startCol] == num: return False return True # Takes a partially filled-in grid and attempts to assign values to all unassigned locations in # such a way to meet the requirements for Sudoku solution (non-duplication across rows, columns, and boxes) def solveSudoku(grid, row, col): # Check if we have reached the 8th row and 9th column (0 indexed matrix) , we are # returning true to avoid further backtracking if (row == N - 1 and col == N): return True # Check if column value becomes 9 , we move to next row and column start from 0 if col == N: row += 1 col = 0 # Check if the current position of the grid already contains value \u003e0, we iterate for next column if grid[row][col] \u003e 0: return solveSudoku(grid, row, col + 1) for num in range(1, N + 1, 1): # Check if it is safe to place the num (1-9) in the given row ,col -\u003ewe # move to next column if isSafe(grid, row, col, num): # Assigning the num in the current (row,col) position of the grid and assuming our assigned # num in the position is correct grid[row][col] = num # Checking for next possibility with next column if solveSudoku(grid, row, col + 1): return True # Removing the assigned num , since our assumption was wrong , and we go for next assumption with #diff num value grid[row][col] = 0 return False # 0 means unassigned cells grid = [[3, 0, 6, 5, 0, 8, 4, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0], [0, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0, 0, 8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2, 5, 0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]] if (solveSudoku(grid, 0, 0)): printing(grid) else: print(\"no solution exists \") m-Colouring Problem \"\"\" An array color[V] that should have numbers from 1 to m. color[i] should represent the color assigned to the ith vertex. The code should also return false if the graph cannot be colored with m colors. \"\"\" from queue import Queue class node(object): color = 1 edges = set() def canPaint(nodes, n, m): # Create a visited array of n nodes, initialized to zero visited = [0 for _ in range(n+1)] # maxColors used till now are 1 as all nodes are painted color 1 maxColors = 1 # Do a full BFS traversal from all unvisited starting points for _ in range(1, n + 1): if visited[_]: continue # If the starting point is unvisited, mark it visited and push it in queue visited[_] = 1 q = Queue() q.put(_) # BFS Travel starts here while not q.empty(): top = q.get() # Checking all adjacent nodes to \"top\" edge in our queue for _ in nodes[top].edges: # IMPORTANT: If the color of the adjacent node is same, increase it by 1 if nodes[top].color == nodes[_].color: nodes[_].color += 1 # If number of colors used shoots m, return 0 maxColors = max(maxColors, max( nodes[top].color, nodes[_].color)) if maxColors \u003e m: print(maxColors) return 0 # If the adjacent node is not visited, mark it visited and push it in queue if not visited[_]: visited[_] = 1 q.put(_) return 1 n = 4 graph = [ [ 0, 1, 1, 1 ], [ 1, 0, 1, 0 ], [ 1, 1, 0, 1 ], [ 1, 0, 1, 0 ] ] # Number of colors m = 3 # Create a vector of n+1 nodes of type \"node\" The zeroth position is just dummy (1 to n to be used) nodes = [] for _ in range(n+1): nodes.append(node()) # Add edges to each node as per given input for _ in range(n): for __ in range(n): if graph[_][__]: # Connect the undirected graph nodes[_].edges.add(_) nodes[__].edges.add(__) # Display final answer print(canPaint(nodes, n, m)) Print all palindromic partitions of a string def isPalindrome(string: str, low: int, high: int): while low \u003c high: if string[low] != string[high]: return False low += 1 high -= 1 return True # Recursive function to find all palindromic partitions of str[start..n-1] # allPart --\u003e A vector of vector of strings. # Every vector inside it stores a partition # currPart --\u003e A vector of strings to store current partition def allPalPartUtil(allPart: list, currPart: list, start: int, n: int, string: str): # If 'start' has reached len if start \u003e= n: # In Python list are passed by reference that is why it is needed to copy first and then append x = currPart.copy() allPart.append(x) return # Pick all possible ending points for substrings for i in range(start, n): # If substring str[start..i] is palindrome if isPalindrome(string, start, i): # Add the substring to result currPart.append(string[start:i + 1]) # Recur for remaining substring allPalPartUtil(allPart, currPart, i + 1, n, string) # Remove substring str[start..i] from current partition currPart.pop() # Function to print all possible palindromic partitions of str. # It mainly creates vectors and calls allPalPartUtil() def allPalPartitions(string: str): n = len(string) # To Store all palindromic partitions allPart = [] # To store current palindromic partition currPart = [] # Call recursive function to generate all partitions and store in allPart allPalPartUtil(allPart, currPart, 0, n, string) # Print all partitions generated by above call for i in range(len(allPart)): for j in range(len(allPart[i])): print(allPart[i][j], end = \" \") print() string = \"nitin\" allPalPartitions(string) Subset Sum Problem \"\"\" Input : arr[] = {4, 1, 10, 12, 5, 2}, sum = 9 Output : TRUE {4, 5} is a subset with sum 9. Input : arr[] = {1, 8, 2, 5}, sum = 4 Output : FALSE There exists no subset with sum 4. \"\"\" def isPossible(elements, target): dp = [False]*(target+1) # initializing with 1 as sum 0 is always possible dp[0] = True # loop to go through every element of the elements array for ele in elements: # to change the value o all possible sum values to True for j in range(target, ele - 1, -1): if dp[j - ele]: dp[j] = True # If target is possible return True else False return dp[target] # Driver code arr = [6, 2, 5] target = 7 if isPossible(arr, target): print(\"YES\") else: print(\"NO\") The Knight’s tour problem # Chessboard Size n = 6 def isSafe(x, y, board): ''' A utility function to check if i,j are valid indexes for N*N chessboard ''' if(x \u003e= 0 and y \u003e= 0 and x \u003c n and y \u003c n and board[x][y] == -1): return True return False def printSolution(n, board): ''' A utility function to print Chessboard matrix ''' for i in range(n): for j in range(n): print(board[i][j], end=' ') print() def solveKT(n): ''' This function solves the Knight Tour problem using Backtracking. This function mainly uses solveKTUtil() to solve the problem. It returns false if no complete tour is possible, otherwise return true and prints the tour. Please note that there may be more than one solutions, this function prints one of the feasible solutions. ''' # Initialization of Board matrix board = [[-1 for i in range(n)]for i in range(n)] # move_x and move_y define next move of Knight. # move_x is for next value of x coordinate # move_y is for next value of y coordinate move_x = [2, 1, -1, -2, -2, -1, 1, 2] move_y = [1, 2, 2, 1, -1, -2, -2, -1] # Since the Knight is initially at the first block board[0][0] = 0 # Step counter for knight's position pos = 1 # Checking if solution exists or not if(not solveKTUtil(n, board, 0, 0, move_x, move_y, pos)): print(\"Solution does not exist\") else: printSolution(n, board) def solveKTUtil(n, board, curr_x, curr_y, move_x, move_y, pos): ''' A recursive utility function to solve Knight Tour problem ''' if(pos == n**2): return True # Try all next moves from the current coordinate x, y for i in range(8): new_x = curr_x + move_x[i] new_y = curr_y + move_y[i] if(isSafe(new_x, new_y, board)): board[new_x][new_y] = pos if(solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos+1)): return True # Backtracking board[new_x][new_y] = -1 return False solveKT(n) Tug of War # function that tries every possible solution by calling itself recursively def TOWUtil(arr, n, curr_elements, no_of_selected_elements, soln, min_diff, Sum, curr_sum, curr_position): # checks whether the it is going out of bound if (curr_position == n): return # checks that the numbers of elements left are not less than the number of elements required to form the solution if ((int(n / 2) - no_of_selected_elements) \u003e(n - curr_position)): return # consider the cases when current element is not included in the solution TOWUtil(arr, n, curr_elements, no_of_selected_elements, soln, min_diff, Sum, curr_sum, curr_position + 1) # add the current element to the solution no_of_selected_elements += 1 curr_sum = curr_sum + arr[curr_position] curr_elements[curr_position] = True # checks if a solution is formed if (no_of_selected_elements == int(n / 2)): # checks if the solution formed is better than the best solution so far if (abs(int(Sum / 2) - curr_sum) \u003c min_diff[0]): min_diff[0] = abs(int(Sum / 2) - curr_sum) for i in range(n): soln[i] = curr_elements[i] else: # consider the cases where current element is included in the solution TOWUtil(arr, n, curr_elements, no_of_selected_elements, soln, min_diff, Sum, curr_sum, curr_position + 1) # removes current element before returning # to the caller of this function curr_elements[curr_position] = False # main function that generate an arr def tugOfWar(arr, n): # the boolean array that contains the inclusion and exclusion of an element # in current set. The number excluded automatically form the other set curr_elements = [None] * n # The inclusion/exclusion array for final solution soln = [None] * n min_diff = [999999999999] Sum = 0 for i in range(n): Sum += arr[i] curr_elements[i] = soln[i] = False # Find the solution using recursive function TOWUtil() TOWUtil(arr, n, curr_elements, 0, soln, min_diff, Sum, 0, 0) # Print the solution print(\"The first subset is: \") for i in range(n): if (soln[i] == True): print(arr[i], end = \" \") print() print(\"The second subset is: \") for i in range(n): if (soln[i] == False): print(arr[i], end = \" \") arr = [23, 45, -34, 12, 0, 98, -99, 4, 189, -1, 4] n = len(arr) tugOfWar(arr, n) Find shortest safe route in a path with landmines # Python3 program to find shortest safe Route # in the matrix with landmines import sys R = 12 C = 10 # These arrays are used to get row and column # numbers of 4 neighbours of a given cell rowNum = [ -1, 0, 0, 1 ] colNum = [ 0, -1, 1, 0 ] min_dist = sys.maxsize # A function to check if a given cell (x, y) # can be visited or not def isSafe(mat, visited, x, y): if (mat[x][y] == 0 or visited[x][y]): return False return True # A function to check if a given cell (x, y) is # a valid cell or not def isValid(x, y): if (x \u003c R and y \u003c C and x \u003e= 0 and y \u003e= 0): return True return False # A function to mark all adjacent cells of # landmines as unsafe. Landmines are shown with # number 0 def markUnsafeCells(mat): for i in range(R): for j in range(C): # If a landmines is found if (mat[i][j] == 0): # Mark all adjacent cells for k in range(4): if (isValid(i + rowNum[k], j + colNum[k])): mat[i + rowNum[k]][j + colNum[k]] = -1 # Mark all found adjacent cells as unsafe for i in range(R): for j in range(C): if (mat[i][j] == -1): mat[i][j] = 0 print(mat) \"\"\" for i in range(R): for j in range(C): print(mat[i][j], end='') print() \"\"\" # Function to find shortest safe Route in the matrix with landmines # mat[][] - binary input matrix with safe cells marked as 1 # visited[][] - store info about cells already visited in current route # (i, j) are coordinates of the current cell # min_dist --\u003e stores minimum cost of shortest path so far # dist --\u003e stores current path cost def findShortestPathUtil(mat, visited, i, j, dist): global min_dist # If destination is reached if (j == C - 1): # Update shortest path found so far min_dist = min(dist, min_dist) return # If current path cost exceeds minimum so far if (dist \u003e min_dist): return # include (i, j) in current path visited[i][j] = True # Recurse for all safe adjacent neighbours for k in range(4): if (isValid(i + rowNum[k], j + colNum[k]) and isSafe(mat, visited, i + rowNum[k], j + colNum[k])): findShortestPathUtil(mat, visited, i + rowNum[k], j + colNum[k], dist + 1) # Backtrack visited[i][j] = False # A wrapper function over findshortestPathUtil() def findShortestPath(mat): global min_dist # Stores minimum cost of shortest path so far min_dist = sys.maxsize # Create a boolean matrix to store info about # cells already visited in current route visited = [[False for i in range(C)] for j in range(R)] # Mark adjacent cells of landmines as unsafe markUnsafeCells(mat) # Start from first column and take minimum for i in range(R): # If path is safe from current cell if (mat[i][0] == 1): # Find shortest route from (i, 0) to any # cell of last column (x, C - 1) where # 0 \u003c= x \u003c R findShortestPathUtil(mat, visited, i, 0, 0) # If min distance is already found if (min_dist == C - 1): break # If destination can be reached if (min_dist != sys.maxsize): print(\"Length of shortest safe route is\", min_dist) else: # If the destination is not reachable print(\"Destination not reachable from given source\") mat = [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 0, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 0, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 ], [ 1, 0, 1, 1, 1, 1, 1, 1, 0, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 0, 1, 1, 1, 1, 0, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 0, 1, 1, 1, 1, 1, 1 ] ] # Find shortest path findShortestPath(mat) Combinational Sum \"\"\"Find all combinations that sum to a given value. Input : arr[] = 2, 4, 6, 8 x = 8 Output : [2, 2, 2, 2] [2, 2, 4] [2, 6] [4, 4] [8] \"\"\" def combinationSum(arr, sum): ans = [] temp = [] # first do hashing nothing but set{} since set does not always sort removing the duplicates # using Set and Sorting the List arr = sorted(list(set(arr))) findNumbers(ans, arr, temp, sum, 0) return ans def findNumbers(ans, arr, temp, sum, index): if(sum == 0): # Adding deep copy of list to ans ans.append(list(temp)) return # Iterate from index to len(arr) - 1 for i in range(index, len(arr)): # checking that sum does not become negative if(sum - arr[i]) \u003e= 0: # adding element which can contribute to # sum temp.append(arr[i]) findNumbers(ans, arr, temp, sum-arr[i], i) # removing element from list (backtracking) temp.remove(arr[i]) arr = [2, 4, 6, 8] sum = 8 ans = combinationSum(arr, sum) # If result is empty, then if len(ans) \u003c= 0: print(\"empty\") # print all combinations stored in ans for i in range(len(ans)): print(\"(\", end=' ') for j in range(len(ans[i])): print(str(ans[i][j])+\" \", end=' ') print(\")\", end=' ') Find Maximum number possible by doing at-most K swaps \"\"\" Given a positive integer, find the maximum integer possible by doing at-most K swap operations on its digits. Examples: Input: M = 254, K = 1 Output: 524 Swap 5 with 2 so number becomes 524 \"\"\" # function to find maximum integer possible by doing at-most K swap operations on its digits def findMaximumNum(string, k, maxm, ctr): # return if no swaps left if k == 0: return n = len(string) # Consider every digit after the cur position mx = string[ctr] for i in range(ctr+1,n): # Find maximum digit greater than at ctr among rest if int(string[i]) \u003e int(mx): mx=string[i] # If maxm is not equal to str[ctr], decrement k if(mx!=string[ctr]): k=k-1 # search this maximum among the rest from behind first swap the last maximum digit if it occurs more then 1 time # example str= 1293498 and k=1 then max string is 9293418 instead of 9213498 for i in range(ctr,n): # If digit equals maxm swap the digit with current digit and recurse for the rest if(string[i]==mx): # swap str[ctr] with str[j] string[ctr], string[i] = string[i], string[ctr] new_str = \"\".join(string) # If current num is more than maximum so far if int(new_str) \u003e int(maxm[0]): maxm[0] = new_str # recurse of the other k - 1 swaps findMaximumNum(string, k , maxm, ctr+1) # backtrack string[ctr], string[i] = string[i], string[ctr] string = \"129814999\" k = 4 maxm = [string] string = [char for char in string] findMaximumNum(string, k, maxm, 0) print(maxm[0]) Print all permutations of a string def permute(s, answer): if (len(s) == 0): print(answer, end = \" \") return for i in range(len(s)): ch = s[i] left_substr = s[0:i] right_substr = s[i + 1:] rest = left_substr + right_substr permute(rest, answer + ch) answer=\"\" s = \"alex\" print(\"All possible strings are : \") permute(s, answer) Find if there is a path of more than k length from a source # Program to find if there is a simple path with weight more than k # This class represents a dipathted graph using adjacency list representation class Graph: # Allocates memory for adjacency list def __init__(self, V): self.V = V self.adj = [[] for i in range(V)] # Returns true if graph has path more than k length def pathMoreThanK(self,src, k): # Create a path array with nothing included in path path = [False]*self.V # Add source vertex to path path[src] = 1 return self.pathMoreThanKUtil(src, k, path) # Prints shortest paths from src to all other vertices def pathMoreThanKUtil(self,src, k, path): # If k is 0 or negative, return true if (k \u003c= 0): return True # Get all adjacent vertices of source vertex src and recursively explore all paths from src. i = 0 while i != len(self.adj[src]): # Get adjacent vertex and weight of edge v = self.adj[src][i][0] w = self.adj[src][i][1] i += 1 # If vertex v is already there in path, then there is a cycle (we ignore this edge) if (path[v] == True): continue # If weight of is more than k, return true if (w \u003e= k): return True # Else add this vertex to path path[v] = True # If this adjacent can provide a path longer than k, return true. if (self.pathMoreThanKUtil(v, k-w, path)): return True # Backtrack path[v] = False # If no adjacent could produce longer path, return false return False # Utility function to an edge (u, v) of weight w def addEdge(self,u, v, w): self.adj[u].append([v, w]) self.adj[v].append([u, w]) # create the graph given in above figure V = 9 g = Graph(V) # making above shown graph g.addEdge(0, 1, 4) g.addEdge(0, 7, 8) g.addEdge(1, 2, 8) g.addEdge(1, 7, 11) g.addEdge(2, 3, 7) g.addEdge(2, 8, 2) g.addEdge(2, 5, 4) g.addEdge(3, 4, 9) g.addEdge(3, 5, 14) g.addEdge(4, 5, 10) g.addEdge(5, 6, 2) g.addEdge(6, 7, 1) g.addEdge(6, 8, 6) g.addEdge(7, 8, 7) #calling in the function src = 0 k = 62 print(\"Yes\") if g.pathMoreThanK(src, k) else print(\"No\") k = 60 print(\"Yes\") if g.pathMoreThanK(src, k) else print(\"No\") Longest Possible Route in a Matrix with Hurdles # Python program to find Longest Possible Route in a matrix with hurdles import sys R,C = 3,10 # A Pair to store status of a cell. found is set to True of destination is reachable and value stores # distance of longest path class Pair: def __init__(self, found, value): self.found = found self.value = value # Function to find Longest Possible Route in the matrix with hurdles. If the destination is not reachable # the function returns false with cost sys.maxsize. (i, j) is source cell and (x, y) is destination cell. def findLongestPathUtil(mat, i, j, x, y, visited): # if (i, j) itself is destination, return True if (i == x and j == y): p = Pair( True, 0 ) return p # if not a valid cell, return false if (i \u003c 0 or i \u003e= R or j \u003c 0 or j \u003e= C or mat[i][j] == 0 or visited[i][j]) : p = Pair( False, sys.maxsize ) return p # include (i, j) in current path i.e. set visited(i, j) to True visited[i][j] = True # res stores longest path from current cell (i, j) to destination cell (x, y) res = -sys.maxsize -1 # go left from current cell sol = findLongestPathUtil(mat, i, j - 1, x, y, visited) # if destination can be reached on going left from current cell, update res if (sol.found): res = max(res, sol.value) # go right from current cell sol = findLongestPathUtil(mat, i, j + 1, x, y, visited) # if destination can be reached on going right from current cell, update res if (sol.found): res = max(res, sol.value) # go up from current cell sol = findLongestPathUtil(mat, i - 1, j, x, y, visited) # if destination can be reached on going up from current cell, update res if (sol.found): res = max(res, sol.value) # go down from current cell sol = findLongestPathUtil(mat, i + 1, j, x, y, visited) # if destination can be reached on going down from current cell, update res if (sol.found): res = max(res, sol.value) # Backtrack visited[i][j] = False # if destination can be reached from current cell, return True if (res != -sys.maxsize -1): p = Pair( True, 1 + res ) return p # if destination can't be reached from current cell, return false else: p = Pair( False, sys.maxsize ) return p # A wrapper function over findLongestPathUtil() def findLongestPath(mat, i, j, x,y): # create a boolean matrix to store info about cells already visited in current route initialize visited to false visited = [[False for i in range(C)]for j in range(R)] # find longest route from (i, j) to (x, y) and print its maximum cost p = findLongestPathUtil(mat, i, j, x, y, visited) if (p.found): print(\"Length of longest possible route is \",str(p.value)) # If the destination is not reachable else: print(\"Destination not reachable from given source\") # input matrix with hurdles shown with number 0 mat = [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 0, 1, 1, 0, 1, 1, 0, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ] # find longest path with source (0, 0) and destination (1, 7) findLongestPath(mat, 0, 0, 1, 7) Print all possible paths from top left to bottom right of a mXn matrix \"\"\" The problem is to print all the possible paths from top left to bottom right of a mXn matrix with the constraints that from each cell you can either move only to right or down. Examples : Input : 1 2 3 4 5 6 Output : 1 4 5 6 1 2 5 6 1 2 3 6 Input : 1 2 3 4 Output : 1 2 4 1 3 4 \"\"\" def printAllPaths(M, m, n): mapping = {} if not mapping.get((m,n)): if m == 1 and n == 1: return [M[m-1][n-1]] else: res = [] if n \u003e 1: a = printAllPaths(M, m, n-1) for i in a: if not isinstance(i, list): i = [i] res.append(i+[M[m-1][n-1]]) if m \u003e 1: b =printAllPaths(M, m-1, n) for i in b: if not isinstance(i, list): i = [i] res.append(i+[M[m-1][n-1]]) mapping[(m,n)] = res return mapping.get((m,n)) M = [[1, 2, 3], [4, 5, 6], [7,8,9]] m, n = len(M), len(M[0]) res = printAllPaths(M, m, n) for i in res: print(i) Partition of a set intoK subsets with equal sum \"\"\" Input : arr = [2, 1, 4, 5, 6], K = 3 Output : Yes we can divide above array into 3 parts with equal sum as [[2, 4], [1, 5], [6]] Input : arr = [2, 1, 5, 5, 6], K = 3 Output : No It is not possible to divide above array into 3 parts with equal sum \"\"\" \"\"\"* array - given input array subsetSum array - sum to store each subset of the array taken -boolean array to check whether element is taken into sum partition or not K - number of partitions needed N - total number of element in array curIdx - current subsetSum index limitIdx - lastIdx from where array element should be taken \"\"\" def isKPartitionPossibleRec(arr, subsetSum, taken, subset, K, N, curIdx, limitIdx): if subsetSum[curIdx] == subset: \"\"\" current index (K - 2) represents (K - 1) subsets of equal sum last partition will already remain with sum 'subset' \"\"\" if (curIdx == K - 2): return True # recursive call for next subsetition return isKPartitionPossibleRec(arr, subsetSum, taken, subset, K, N, curIdx + 1 , N - 1) # start from limitIdx and include elements into current partition for i in range(limitIdx, -1, -1): # if already taken, continue if (taken[i]): continue tmp = subsetSum[curIdx] + arr[i] # if temp is less than subset, then only include the element and call recursively if (tmp \u003c= subset): # mark the element and include into current partition sum taken[i] = True subsetSum[curIdx] += arr[i] nxt = isKPartitionPossibleRec(arr, subsetSum, taken, subset, K, N, curIdx, i - 1) # after recursive call unmark the element and remove from subsetition sum taken[i] = False subsetSum[curIdx] -= arr[i] if (nxt): return True return False # Method returns True if arr can be partitioned into K subsets with equal sum def isKPartitionPossible(arr, N, K): # If K is 1, then complete array will be our answer if (K == 1): return True # If total number of partitions are more than N, then division is not possible if (N \u003c K): return False # if array sum is not divisible by K then we can't divide array into K partitions sum = 0 for i in range(N): sum += arr[i] if (sum % K != 0): return False # the sum of each subset should be subset (= sum / K) subset = sum // K subsetSum = [0] * K taken = [0] * N # Initialize sum of each subset from 0 for i in range(K): subsetSum[i] = 0 # mark all elements as not taken for i in range(N): taken[i] = False # initialize first subset sum as last element of array and mark that as taken subsetSum[0] = arr[N - 1] taken[N - 1] = True # call recursive method to check K-substitution condition return isKPartitionPossibleRec(arr, subsetSum, taken, subset, K, N, 0, N - 1) arr = [2, 1, 4, 5, 3, 3 ] N = len(arr) K = 3 if (isKPartitionPossible(arr, N, K)): print(\"Partitions into equal sum is possible.\\n\") else: print(\"Partitions into equal sum is not possible.\\n\") Find the K-th Permutation Sequence of first N natural numbers \"\"\" Input: N = 3, K = 4 Output: 231 Explanation: The ordered list of permutation sequence from integer 1 to 3 is : 123, 132, 213, 231, 312, 321. So, the 4th permutation sequence is “231”. Input: N = 2, K = 1 Output: 12 Explanation: For n = 2, only 2 permutations are possible 12 21. So, the 1st permutation sequence is “12”. \"\"\" # Function to find the index of number at first position of kth sequence of set of size n def findFirstNumIndex(k, n): if (n == 1): return 0, k n -= 1 first_num_index = 0 # n_actual_fact = n! n_partial_fact = n while (k \u003e= n_partial_fact and n \u003e 1): n_partial_fact = n_partial_fact * (n - 1) n -= 1 # First position of the kth sequence will be occupied by the number present at index = k / (n-1)! first_num_index = k // n_partial_fact k = k % n_partial_fact return first_num_index, k # Function to find the kth permutation of n numbers def findKthPermutation(n, k): # Store final answer ans = \"\" s = set() # Insert all natural number upto n in set for i in range(1, n + 1): s.add(i) # Subtract 1 to get 0 based indexing k = k - 1 for i in range(n): # Mark the first position itr = list(s) index, k = findFirstNumIndex(k, n - i) # itr now points to the number at index in set s ans += str(itr[index]) # remove current number from the set itr.pop(index) s = set(itr) return ans n = 3 k = 4 kth_perm_seq = findKthPermutation(n, k) print(kth_perm_seq) ",
  "wordCount" : "5932",
  "inLanguage": "en",
  "image":"https://atharvashah.netlify.app/blog/dsa/backtracking.jpg","datePublished": "2022-07-07T23:18:34+05:30",
  "dateModified": "2022-07-07T23:18:34+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://atharvashah.netlify.app/blog/dsapython/backtracking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Atharva Shah",
    "logo": {
      "@type": "ImageObject",
      "url": "https://atharvashah.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://atharvashah.netlify.app/" accesskey="h" title="Atharva Shah (Alt + H)">
                <img src="https://atharvashah.netlify.app/profile/header_button.gif" alt="" aria-label="logo"
                    height="30">Atharva Shah</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://atharvashah.netlify.app/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://atharvashah.netlify.app/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://atharvashah.netlify.app/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://atharvashah.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://atharvashah.netlify.app/blog/">Blogs</a></div>
    <h1 class="post-title">
      DSA in Python - Backtracking
    </h1>
    <div class="post-meta"><span title='2022-07-07 23:18:34 +0530 IST'>July 7, 2022</span>&nbsp;·&nbsp;28 min&nbsp;·&nbsp;5932 words

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://atharvashah.netlify.app/blog/dsa/backtracking.jpg" alt="Backtracking">
        <p>Learn Backtracking Algorithms in Python</p>
</figure>
  <div class="post-content"><ul>
<li><a href="#rat-in-a-maze-problem">Rat in a maze Problem</a></li>
<li><a href="#printing-all-solutions-in-n-queen-problem">Printing all solutions in N-Queen Problem</a></li>
<li><a href="#word-break-problem-using-backtracking">Word Break Problem using Backtracking</a></li>
<li><a href="#remove-invalid-parentheses">Remove Invalid Parentheses</a></li>
<li><a href="#sudoku-solver">Sudoku Solver</a></li>
<li><a href="#m-colouring-problem">m-Colouring Problem</a></li>
<li><a href="#print-all-palindromic-partitions-of-a-string">Print all palindromic partitions of a string</a></li>
<li><a href="#subset-sum-problem">Subset Sum Problem</a></li>
<li><a href="#the-knights-tour-problem">The Knight’s tour problem</a></li>
<li><a href="#tug-of-war">Tug of War</a></li>
<li><a href="#find-shortest-safe-route-in-a-path-with-landmines">Find shortest safe route in a path with landmines</a></li>
<li><a href="#combinational-sum">Combinational Sum</a></li>
<li><a href="#find-maximum-number-possible-by-doing-at-most-k-swaps">Find Maximum number possible by doing at-most K swaps</a></li>
<li><a href="#print-all-permutations-of-a-string">Print all permutations of a string</a></li>
<li><a href="#find-if-there-is-a-path-of-more-than-k-length-from-a-source">Find if there is a path of more than k length from a source</a></li>
<li><a href="#longest-possible-route-in-a-matrix-with-hurdles">Longest Possible Route in a Matrix with Hurdles</a></li>
<li><a href="#print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix">Print all possible paths from top left to bottom right of a mXn matrix</a></li>
<li><a href="#partition-of-a-set-intok-subsets-with-equal-sum">Partition of a set intoK subsets with equal sum</a></li>
<li><a href="#find-the-k-th-permutation-sequence-of-first-n-natural-numbers">Find the K-th Permutation Sequence of first N natural numbers</a></li>
</ul>
<h2 id="rat-in-a-maze-problem">Rat in a maze Problem<a hidden class="anchor" aria-hidden="true" href="#rat-in-a-maze-problem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">N = 4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">m[][] = {{1, 0, 0, 0},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         {1, 1, 0, 1}, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         {1, 1, 0, 0},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         {0, 1, 1, 1}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">DDRDRR DRDDRR
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The rat can reach the destination at 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">(3, 3) from (0, 0) by two paths - DRDDRR 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">and DDRDRR, when printed in sorted order 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">we get DDRDRR DRDDRR.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">setup</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> v
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>)] <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>)]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> ans
</span></span><span style="display:flex;"><span>    ans <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">path</span>(arr, x, y, pth, n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> x<span style="color:#f92672">==</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> y<span style="color:#f92672">==</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">global</span> ans
</span></span><span style="display:flex;"><span>        ans<span style="color:#f92672">.</span>append(pth)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> v
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> arr[x][y]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> v[x][y]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    v[x][y]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> x<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        path(arr, x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, y, pth<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;U&#39;</span>, n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> y<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        path(arr, x, y<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, pth<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;L&#39;</span>, n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> x<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        path(arr, x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, y, pth<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;D&#39;</span>, n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> y<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        path(arr, x, y<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, pth<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;R&#39;</span>, n)
</span></span><span style="display:flex;"><span>    v[x][y]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findPath</span>(m, n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> ans
</span></span><span style="display:flex;"><span>    ans<span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> m[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> m[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> :
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans
</span></span><span style="display:flex;"><span>    setup()
</span></span><span style="display:flex;"><span>    path(m, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#34;&#34;</span>, n)
</span></span><span style="display:flex;"><span>    ans<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> [ [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> ], [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ], [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ], [ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ],[ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ] ]
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> len(m)
</span></span><span style="display:flex;"><span>print(findPath(m, n))
</span></span></code></pre></div><h2 id="printing-all-solutions-in-n-queen-problem">Printing all solutions in N-Queen Problem<a hidden class="anchor" aria-hidden="true" href="#printing-all-solutions-in-n-queen-problem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isSafe</span>(mat, r, c):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return false if two queens share the same column</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(r):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> mat[i][c] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;Q&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return false if two queens share the same `` diagonal</span>
</span></span><span style="display:flex;"><span>    (i, j) <span style="color:#f92672">=</span> (r, c)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> mat[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;Q&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return false if two queens share the same `/` diagonal</span>
</span></span><span style="display:flex;"><span>    (i, j) <span style="color:#f92672">=</span> (r, c)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> j <span style="color:#f92672">&lt;</span> len(mat):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> mat[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;Q&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printSolution</span>(mat):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> mat:
</span></span><span style="display:flex;"><span>        print(str(r)<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#39;,&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>)<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\&#39;</span><span style="color:#e6db74">&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>))
</span></span><span style="display:flex;"><span>    print()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nQueen</span>(mat, r):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if `N` queens are placed successfully, print the solution</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> r <span style="color:#f92672">==</span> len(mat):
</span></span><span style="display:flex;"><span>        printSolution(mat)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># place queen at every square in the current row `r`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># and recur for each valid movement</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(mat)):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if no two queens threaten each other</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> isSafe(mat, r, i):
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># place queen on the current square</span>
</span></span><span style="display:flex;"><span>            mat[r][i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Q&#39;</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># recur for the next row</span>
</span></span><span style="display:flex;"><span>            nQueen(mat, r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># backtrack and remove the queen from the current square</span>
</span></span><span style="display:flex;"><span>            mat[r][i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;–&#39;</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># `N × N` chessboard</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># `mat[][]` keeps track of the position of queens in</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the current configuration</span>
</span></span><span style="display:flex;"><span>mat <span style="color:#f92672">=</span> [[<span style="color:#e6db74">&#39;–&#39;</span> <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(N)] <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(N)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>nQueen(mat, <span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><h2 id="word-break-problem-using-backtracking">Word Break Problem using Backtracking<a hidden class="anchor" aria-hidden="true" href="#word-break-problem-using-backtracking">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># A recursive program to print all possible partitions of a given string into dictionary words</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function to check whether a word is present in dictionary or not.  An array of strings is used for dictionary.  Using array of strings for dictionary is definitely not a good idea. We have used for simplicity of the program</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dictionaryContains</span>(word):
</span></span><span style="display:flex;"><span>    dictionary <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;mobile&#34;</span>, <span style="color:#e6db74">&#34;samsung&#34;</span>, <span style="color:#e6db74">&#34;sam&#34;</span>, <span style="color:#e6db74">&#34;sung&#34;</span>, <span style="color:#e6db74">&#34;man&#34;</span>,
</span></span><span style="display:flex;"><span>                  <span style="color:#e6db74">&#34;mango&#34;</span>, <span style="color:#e6db74">&#34;icecream&#34;</span>, <span style="color:#e6db74">&#34;and&#34;</span>, <span style="color:#e6db74">&#34;go&#34;</span>, <span style="color:#e6db74">&#34;i&#34;</span>, <span style="color:#e6db74">&#34;love&#34;</span>, <span style="color:#e6db74">&#34;ice&#34;</span>, <span style="color:#e6db74">&#34;cream&#34;</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> word <span style="color:#f92672">in</span> dictionary
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Prints all possible word breaks of given string</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wordBreak</span>(string):
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Last argument is prefix</span>
</span></span><span style="display:flex;"><span>    wordBreakUtil(string, len(string), <span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Result store the current prefix with spaces</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># between words</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wordBreakUtil</span>(string, n, result):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Process all prefixes one by one</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Extract substring from 0 to i in prefix</span>
</span></span><span style="display:flex;"><span>        prefix <span style="color:#f92672">=</span> string[:i]
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># If dictionary contains this prefix, then</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># we check for remaining string. Otherwise</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># we ignore this prefix (there is no else for</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># this if) and try next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> dictionaryContains(prefix):
</span></span><span style="display:flex;"><span>           
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># If no more elements are there, print it</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> n:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># Add this element to previous prefix</span>
</span></span><span style="display:flex;"><span>                result <span style="color:#f92672">+=</span> prefix
</span></span><span style="display:flex;"><span>                print(result)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>            wordBreakUtil(string[i:], n <span style="color:#f92672">-</span> i, result<span style="color:#f92672">+</span>prefix<span style="color:#f92672">+</span><span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;First Test:&#34;</span>)
</span></span><span style="display:flex;"><span>wordBreak(<span style="color:#e6db74">&#34;iloveicecreamandmango&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Second Test:&#34;</span>)
</span></span><span style="display:flex;"><span>wordBreak(<span style="color:#e6db74">&#34;ilovesamsungmobile&#34;</span>)
</span></span><span style="display:flex;"><span> 
</span></span></code></pre></div><h2 id="remove-invalid-parentheses">Remove Invalid Parentheses<a hidden class="anchor" aria-hidden="true" href="#remove-invalid-parentheses">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isValidString</span>(string):
</span></span><span style="display:flex;"><span>    left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> index <span style="color:#f92672">&lt;</span> len(string):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> string[index] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>:
</span></span><span style="display:flex;"><span>            left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> string[index] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> left <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                left <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                right <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> right <span style="color:#f92672">&gt;</span> left:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>        index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> left <span style="color:#f92672">==</span> right
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">removeInvalidParentheses</span>(string):
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    visited <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> deque()
</span></span><span style="display:flex;"><span>    valid <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    visited<span style="color:#f92672">.</span>add(string)
</span></span><span style="display:flex;"><span>    q<span style="color:#f92672">.</span>append(string)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># BFS.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> len(q) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        possibleAnswer <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Check whether &#39;possibleAnswer&#39; is valid or not.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> isValidString(possibleAnswer):
</span></span><span style="display:flex;"><span>            result<span style="color:#f92672">.</span>append(possibleAnswer)
</span></span><span style="display:flex;"><span>            valid <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># If true, then the solution exists at current level. No need to move at next state.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> valid <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Generate all possible next state of Strings from current String.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(possibleAnswer)):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> possibleAnswer[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#f92672">or</span> possibleAnswer[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>:
</span></span><span style="display:flex;"><span>                temp <span style="color:#f92672">=</span> possibleAnswer[<span style="color:#ae81ff">0</span> : i] <span style="color:#f92672">+</span> possibleAnswer[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> : len(possibleAnswer)]
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> temp <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> visited:
</span></span><span style="display:flex;"><span>                    q<span style="color:#f92672">.</span>append(temp)
</span></span><span style="display:flex;"><span>                    visited<span style="color:#f92672">.</span>add(temp)
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sorted(result)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>print(removeInvalidParentheses(<span style="color:#e6db74">&#39;)(()))&#39;</span>))
</span></span><span style="display:flex;"><span>print(removeInvalidParentheses(<span style="color:#e6db74">&#39;(((a))) ((a))()&#39;</span>))
</span></span></code></pre></div><h2 id="sudoku-solver">Sudoku Solver<a hidden class="anchor" aria-hidden="true" href="#sudoku-solver">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># N is the size of the 2D matrix N*N</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function to print grid</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printing</span>(arr):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>            print(arr[i][j], end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>        print()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Checks whether it will be legal to assign num to the given row, col</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isSafe</span>(grid, row, col, num):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Check if we find the same num in the similar row , we return false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">9</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> grid[row][x] <span style="color:#f92672">==</span> num:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Check if we find the same num in the similar column , we return false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">9</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> grid[x][col] <span style="color:#f92672">==</span> num:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Check if we find the same num in the particular 3*3 matrix, we return false</span>
</span></span><span style="display:flex;"><span>    startRow <span style="color:#f92672">=</span> row <span style="color:#f92672">-</span> row <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    startCol <span style="color:#f92672">=</span> col <span style="color:#f92672">-</span> col <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> grid[i <span style="color:#f92672">+</span> startRow][j <span style="color:#f92672">+</span> startCol] <span style="color:#f92672">==</span> num:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Takes a partially filled-in grid and attempts to assign values to all unassigned locations in</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># such a way to meet the requirements for Sudoku solution (non-duplication across rows, columns, and boxes) </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solveSudoku</span>(grid, row, col):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Check if we have reached the 8th row and 9th column (0 indexed matrix) , we are</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># returning true to avoid further backtracking</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (row <span style="color:#f92672">==</span> N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> col <span style="color:#f92672">==</span> N):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Check if column value becomes 9 , we move to next row and column start from 0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> col <span style="color:#f92672">==</span> N:
</span></span><span style="display:flex;"><span>        row <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        col <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Check if the current position of the grid already contains value &gt;0, we iterate for next column</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> grid[row][col] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> solveSudoku(grid, row, col <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Check if it is safe to place the num (1-9) in the given row ,col -&gt;we</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># move to next column</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> isSafe(grid, row, col, num):
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Assigning the num in the current (row,col) position of the grid and assuming our assigned</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># num in the position is correct</span>
</span></span><span style="display:flex;"><span>            grid[row][col] <span style="color:#f92672">=</span> num
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Checking for next possibility with next column</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> solveSudoku(grid, row, col <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Removing the assigned num , since our assumption was wrong , and we go for next assumption with </span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">#diff num value</span>
</span></span><span style="display:flex;"><span>        grid[row][col] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0 means unassigned cells</span>
</span></span><span style="display:flex;"><span>grid <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">4</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>]]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (solveSudoku(grid, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)):
</span></span><span style="display:flex;"><span>    printing(grid)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;no solution exists &#34;</span>)
</span></span></code></pre></div><h2 id="m-colouring-problem">m-Colouring Problem<a hidden class="anchor" aria-hidden="true" href="#m-colouring-problem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">An array color[V] that should have numbers from 1 to m. color[i] should represent the color assigned to the ith vertex. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The code should also return false if the graph cannot be colored with m colors.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> queue <span style="color:#f92672">import</span> Queue
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">node</span>(object):
</span></span><span style="display:flex;"><span>    color <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    edges <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canPaint</span>(nodes, n, m):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Create a visited array of n nodes, initialized to zero</span>
</span></span><span style="display:flex;"><span>    visited <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># maxColors used till now are 1 as all nodes are painted color 1</span>
</span></span><span style="display:flex;"><span>    maxColors <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Do a full BFS traversal from all unvisited starting points</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> visited[_]:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># If the starting point is unvisited, mark it visited and push it in queue</span>
</span></span><span style="display:flex;"><span>        visited[_] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        q <span style="color:#f92672">=</span> Queue()
</span></span><span style="display:flex;"><span>        q<span style="color:#f92672">.</span>put(_)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># BFS Travel starts here</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> q<span style="color:#f92672">.</span>empty():
</span></span><span style="display:flex;"><span>            top <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>get()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Checking all adjacent nodes to &#34;top&#34; edge in our queue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> nodes[top]<span style="color:#f92672">.</span>edges:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># IMPORTANT: If the color of the adjacent node is same, increase it by 1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> nodes[top]<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> nodes[_]<span style="color:#f92672">.</span>color:
</span></span><span style="display:flex;"><span>                    nodes[_]<span style="color:#f92672">.</span>color <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># If number of colors used shoots m, return 0</span>
</span></span><span style="display:flex;"><span>                maxColors <span style="color:#f92672">=</span> max(maxColors, max(
</span></span><span style="display:flex;"><span>                    nodes[top]<span style="color:#f92672">.</span>color, nodes[_]<span style="color:#f92672">.</span>color))
</span></span><span style="display:flex;"><span>                     
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> maxColors <span style="color:#f92672">&gt;</span> m:
</span></span><span style="display:flex;"><span>                    print(maxColors)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># If the adjacent node is not visited, mark it visited and push it in queue</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> visited[_]:
</span></span><span style="display:flex;"><span>                    visited[_] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                    q<span style="color:#f92672">.</span>put(_)
</span></span><span style="display:flex;"><span>                     
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>graph <span style="color:#f92672">=</span> [ [ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>          [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span> ],
</span></span><span style="display:flex;"><span>          [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>          [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span> ] ]
</span></span><span style="display:flex;"><span>           
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Number of colors</span>
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a vector of n+1 nodes of type &#34;node&#34; The zeroth position is just dummy (1 to n to be used)</span>
</span></span><span style="display:flex;"><span>nodes <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    nodes<span style="color:#f92672">.</span>append(node())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add edges to each node as per given input</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> __ <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> graph[_][__]:
</span></span><span style="display:flex;"><span>             
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Connect the undirected graph</span>
</span></span><span style="display:flex;"><span>            nodes[_]<span style="color:#f92672">.</span>edges<span style="color:#f92672">.</span>add(_)
</span></span><span style="display:flex;"><span>            nodes[__]<span style="color:#f92672">.</span>edges<span style="color:#f92672">.</span>add(__)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Display final answer</span>
</span></span><span style="display:flex;"><span>print(canPaint(nodes, n, m))
</span></span></code></pre></div><h2 id="print-all-palindromic-partitions-of-a-string">Print all palindromic partitions of a string<a hidden class="anchor" aria-hidden="true" href="#print-all-palindromic-partitions-of-a-string">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isPalindrome</span>(string: str,
</span></span><span style="display:flex;"><span>                 low: int, high: int):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> low <span style="color:#f92672">&lt;</span> high:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> string[low] <span style="color:#f92672">!=</span> string[high]:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        low <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        high <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to find all palindromic partitions of str[start..n-1]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># allPart --&gt; A vector of vector of strings.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#             Every vector inside it stores a partition</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># currPart --&gt; A vector of strings to store current partition</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">allPalPartUtil</span>(allPart: list, currPart: list,
</span></span><span style="display:flex;"><span>                   start: int, n: int, string: str):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If &#39;start&#39; has reached len</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> start <span style="color:#f92672">&gt;=</span> n:
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># In Python list are passed by reference that is why it is needed to copy first and then append</span>
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> currPart<span style="color:#f92672">.</span>copy()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        allPart<span style="color:#f92672">.</span>append(x)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Pick all possible ending points for substrings</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(start, n):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># If substring str[start..i] is palindrome</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> isPalindrome(string, start, i):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Add the substring to result</span>
</span></span><span style="display:flex;"><span>            currPart<span style="color:#f92672">.</span>append(string[start:i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Recur for remaining substring</span>
</span></span><span style="display:flex;"><span>            allPalPartUtil(allPart, currPart,
</span></span><span style="display:flex;"><span>                            i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, n, string)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Remove substring str[start..i] from current partition</span>
</span></span><span style="display:flex;"><span>            currPart<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to print all possible palindromic partitions of str.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># It mainly creates vectors and calls allPalPartUtil()</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">allPalPartitions</span>(string: str):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> len(string)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># To Store all palindromic partitions</span>
</span></span><span style="display:flex;"><span>    allPart <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># To store current palindromic partition</span>
</span></span><span style="display:flex;"><span>    currPart <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Call recursive function to generate all partitions and store in allPart</span>
</span></span><span style="display:flex;"><span>    allPalPartUtil(allPart, currPart, <span style="color:#ae81ff">0</span>, n, string)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Print all partitions generated by above call</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(allPart)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(allPart[i])):
</span></span><span style="display:flex;"><span>            print(allPart[i][j], end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>        print()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;nitin&#34;</span>
</span></span><span style="display:flex;"><span>allPalPartitions(string)
</span></span></code></pre></div><h2 id="subset-sum-problem">Subset Sum Problem<a hidden class="anchor" aria-hidden="true" href="#subset-sum-problem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : arr[] = {4, 1, 10, 12, 5, 2}, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          sum = 9
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : TRUE
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{4, 5} is a subset with sum 9.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : arr[] = {1, 8, 2, 5}, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          sum = 4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : FALSE 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">There exists no subset with sum 4.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isPossible</span>(elements, target):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    dp <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>]<span style="color:#f92672">*</span>(target<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># initializing with 1 as sum 0 is always possible</span>
</span></span><span style="display:flex;"><span>    dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># loop to go through every element of the elements array</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ele <span style="color:#f92672">in</span> elements:
</span></span><span style="display:flex;"><span>       
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># to change the value o all possible sum values to True</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(target, ele <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> dp[j <span style="color:#f92672">-</span> ele]:
</span></span><span style="display:flex;"><span>                dp[j] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If target is possible return True else False</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dp[target]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Driver code</span>
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span>target <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> isPossible(arr, target):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;YES&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;NO&#34;</span>)
</span></span></code></pre></div><h2 id="the-knights-tour-problem">The Knight’s tour problem<a hidden class="anchor" aria-hidden="true" href="#the-knights-tour-problem">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Chessboard Size</span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isSafe</span>(x, y, board):
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    A utility function to check if i,j are valid indexes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    for N*N chessboard
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> y <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> x <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">and</span> y <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">and</span> board[x][y] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printSolution</span>(n, board):
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    A utility function to print Chessboard matrix
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>      print(board[i][j], end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    print()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solveKT</span>(n):
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    This function solves the Knight Tour problem using
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Backtracking. This function mainly uses solveKTUtil()
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    to solve the problem. It returns false if no complete
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    tour is possible, otherwise return true and prints the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    tour.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Please note that there may be more than one solutions,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    this function prints one of the feasible solutions.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Initialization of Board matrix</span>
</span></span><span style="display:flex;"><span>  board <span style="color:#f92672">=</span> [[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n)]<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># move_x and move_y define next move of Knight.</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># move_x is for next value of x coordinate</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># move_y is for next value of y coordinate</span>
</span></span><span style="display:flex;"><span>  move_x <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>  move_y <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Since the Knight is initially at the first block</span>
</span></span><span style="display:flex;"><span>  board[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Step counter for knight&#39;s position</span>
</span></span><span style="display:flex;"><span>  pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Checking if solution exists or not</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">not</span> solveKTUtil(n, board, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, move_x, move_y, pos)):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Solution does not exist&#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    printSolution(n, board)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solveKTUtil</span>(n, board, curr_x, curr_y, move_x, move_y, pos):
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    A recursive utility function to solve Knight Tour
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    problem
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(pos <span style="color:#f92672">==</span> n<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Try all next moves from the current coordinate x, y</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">8</span>):
</span></span><span style="display:flex;"><span>    new_x <span style="color:#f92672">=</span> curr_x <span style="color:#f92672">+</span> move_x[i]
</span></span><span style="display:flex;"><span>    new_y <span style="color:#f92672">=</span> curr_y <span style="color:#f92672">+</span> move_y[i]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(isSafe(new_x, new_y, board)):
</span></span><span style="display:flex;"><span>      board[new_x][new_y] <span style="color:#f92672">=</span> pos
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># Backtracking</span>
</span></span><span style="display:flex;"><span>      board[new_x][new_y] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>solveKT(n)
</span></span></code></pre></div><h2 id="tug-of-war">Tug of War<a hidden class="anchor" aria-hidden="true" href="#tug-of-war">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># function that tries every possible solution by calling itself recursively</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">TOWUtil</span>(arr, n, curr_elements, no_of_selected_elements,
</span></span><span style="display:flex;"><span>      soln, min_diff, Sum, curr_sum, curr_position):
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># checks whether the it is going out of bound</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (curr_position <span style="color:#f92672">==</span> n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># checks that the numbers of elements left are not less than the number of elements required to form the solution</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((int(n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">-</span> no_of_selected_elements) <span style="color:#f92672">&gt;</span>(n <span style="color:#f92672">-</span> curr_position)):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># consider the cases when current element is not included in the solution</span>
</span></span><span style="display:flex;"><span>  TOWUtil(arr, n, curr_elements, no_of_selected_elements, soln, min_diff, Sum, curr_sum, curr_position <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># add the current element to the solution</span>
</span></span><span style="display:flex;"><span>  no_of_selected_elements <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  curr_sum <span style="color:#f92672">=</span> curr_sum <span style="color:#f92672">+</span> arr[curr_position]
</span></span><span style="display:flex;"><span>  curr_elements[curr_position] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># checks if a solution is formed</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (no_of_selected_elements <span style="color:#f92672">==</span> int(n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)):
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># checks if the solution formed is better than the best solution so far</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (abs(int(Sum <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">-</span> curr_sum) <span style="color:#f92672">&lt;</span> min_diff[<span style="color:#ae81ff">0</span>]):
</span></span><span style="display:flex;"><span>      min_diff[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> abs(int(Sum <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">-</span> curr_sum)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>        soln[i] <span style="color:#f92672">=</span> curr_elements[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># consider the cases where current element is included in the solution</span>
</span></span><span style="display:flex;"><span>    TOWUtil(arr, n, curr_elements, no_of_selected_elements, soln, min_diff, Sum, curr_sum, curr_position <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># removes current element before returning</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># to the caller of this function</span>
</span></span><span style="display:flex;"><span>  curr_elements[curr_position] <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># main function that generate an arr</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">tugOfWar</span>(arr, n):
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># the boolean array that contains the inclusion and exclusion of an element</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># in current set. The number excluded automatically form the other set</span>
</span></span><span style="display:flex;"><span>  curr_elements <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># The inclusion/exclusion array for final solution</span>
</span></span><span style="display:flex;"><span>  soln <span style="color:#f92672">=</span> [<span style="color:#66d9ef">None</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  min_diff <span style="color:#f92672">=</span> [<span style="color:#ae81ff">999999999999</span>]
</span></span><span style="display:flex;"><span>  Sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>    Sum <span style="color:#f92672">+=</span> arr[i]
</span></span><span style="display:flex;"><span>    curr_elements[i] <span style="color:#f92672">=</span> soln[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Find the solution using recursive function TOWUtil()</span>
</span></span><span style="display:flex;"><span>  TOWUtil(arr, n, curr_elements, <span style="color:#ae81ff">0</span>, soln, min_diff, Sum, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Print the solution</span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;The first subset is: &#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (soln[i] <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>):
</span></span><span style="display:flex;"><span>      print(arr[i], end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>  print()
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;The second subset is: &#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (soln[i] <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span>):
</span></span><span style="display:flex;"><span>      print(arr[i], end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">23</span>, <span style="color:#ae81ff">45</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">34</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">98</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">99</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">189</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> len(arr)
</span></span><span style="display:flex;"><span>tugOfWar(arr, n)
</span></span></code></pre></div><h2 id="find-shortest-safe-route-in-a-path-with-landmines">Find shortest safe route in a path with landmines<a hidden class="anchor" aria-hidden="true" href="#find-shortest-safe-route-in-a-path-with-landmines">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Python3 program to find shortest safe Route</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># in the matrix with landmines</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>R <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>C <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># These arrays are used to get row and column</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># numbers of 4 neighbours of a given cell</span>
</span></span><span style="display:flex;"><span>rowNum <span style="color:#f92672">=</span> [ <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ]
</span></span><span style="display:flex;"><span>colNum <span style="color:#f92672">=</span> [ <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span> ]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>min_dist <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>maxsize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A function to check if a given cell (x, y)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># can be visited or not</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isSafe</span>(mat, visited, x, y):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (mat[x][y] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> visited[x][y]):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A function to check if a given cell (x, y) is</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># a valid cell or not</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isValid</span>(x, y):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;</span> R <span style="color:#f92672">and</span> y <span style="color:#f92672">&lt;</span> C <span style="color:#f92672">and</span> x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> y <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A function to mark all adjacent cells of</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># landmines as unsafe. Landmines are shown with</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># number 0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">markUnsafeCells</span>(mat):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(R):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(C):
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># If a landmines is found</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (mat[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Mark all adjacent cells</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (isValid(i <span style="color:#f92672">+</span> rowNum[k], j <span style="color:#f92672">+</span> colNum[k])):
</span></span><span style="display:flex;"><span>            mat[i <span style="color:#f92672">+</span> rowNum[k]][j <span style="color:#f92672">+</span> colNum[k]] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Mark all found adjacent cells as unsafe</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(R):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(C):
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (mat[i][j] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        mat[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(mat)
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      for i in range(R):
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          for j in range(C):
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">              print(mat[i][j], end=&#39;&#39;)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          print()
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find shortest safe Route in the matrix with landmines</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mat[][] - binary input matrix with safe cells marked as 1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># visited[][] - store info about cells already visited in current route</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># (i, j) are coordinates of the current cell</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># min_dist --&gt; stores minimum cost of shortest path so far</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># dist --&gt; stores current path cost</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findShortestPathUtil</span>(mat, visited, i, j, dist):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">global</span> min_dist
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If destination is reached</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> C <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Update shortest path found so far</span>
</span></span><span style="display:flex;"><span>    min_dist <span style="color:#f92672">=</span> min(dist, min_dist)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If current path cost exceeds minimum so far</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (dist <span style="color:#f92672">&gt;</span> min_dist):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># include (i, j) in current path</span>
</span></span><span style="display:flex;"><span>  visited[i][j] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Recurse for all safe adjacent neighbours</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (isValid(i <span style="color:#f92672">+</span> rowNum[k], j <span style="color:#f92672">+</span> colNum[k]) <span style="color:#f92672">and</span> isSafe(mat, visited, i <span style="color:#f92672">+</span> rowNum[k], j <span style="color:#f92672">+</span> colNum[k])):
</span></span><span style="display:flex;"><span>      findShortestPathUtil(mat, visited, i <span style="color:#f92672">+</span> rowNum[k], j <span style="color:#f92672">+</span> colNum[k], dist <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Backtrack</span>
</span></span><span style="display:flex;"><span>  visited[i][j] <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A wrapper function over findshortestPathUtil()</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findShortestPath</span>(mat):
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">global</span> min_dist
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Stores minimum cost of shortest path so far</span>
</span></span><span style="display:flex;"><span>  min_dist <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>maxsize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Create a boolean matrix to store info about</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># cells already visited in current route</span>
</span></span><span style="display:flex;"><span>  visited <span style="color:#f92672">=</span> [[<span style="color:#66d9ef">False</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(C)] <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(R)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Mark adjacent cells of landmines as unsafe</span>
</span></span><span style="display:flex;"><span>  markUnsafeCells(mat)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Start from first column and take minimum</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(R):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If path is safe from current cell</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (mat[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># Find shortest route from (i, 0) to any</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># cell of last column (x, C - 1) where</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># 0 &lt;= x &lt; R</span>
</span></span><span style="display:flex;"><span>      findShortestPathUtil(mat, visited, i, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># If min distance is already found</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (min_dist <span style="color:#f92672">==</span> C <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If destination can be reached</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (min_dist <span style="color:#f92672">!=</span> sys<span style="color:#f92672">.</span>maxsize):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Length of shortest safe route is&#34;</span>, min_dist)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If the destination is not reachable</span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Destination not reachable from given source&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>mat <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ] ]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Find shortest path</span>
</span></span><span style="display:flex;"><span>findShortestPath(mat)
</span></span></code></pre></div><h2 id="combinational-sum">Combinational Sum<a hidden class="anchor" aria-hidden="true" href="#combinational-sum">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;Find all combinations that sum to a given value.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : arr[] = 2, 4, 6, 8 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            x = 8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : [2, 2, 2, 2]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [2, 2, 4]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [2, 6]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [4, 4]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         [8]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum</span>(arr, sum):
</span></span><span style="display:flex;"><span>  ans <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>  temp <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># first do hashing nothing but set{} since set does not always sort removing the duplicates </span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># using Set and Sorting the List</span>
</span></span><span style="display:flex;"><span>  arr <span style="color:#f92672">=</span> sorted(list(set(arr)))
</span></span><span style="display:flex;"><span>  findNumbers(ans, arr, temp, sum, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ans
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findNumbers</span>(ans, arr, temp, sum, index):
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(sum <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Adding deep copy of list to ans</span>
</span></span><span style="display:flex;"><span>    ans<span style="color:#f92672">.</span>append(list(temp))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Iterate from index to len(arr) - 1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index, len(arr)):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># checking that sum does not become negative</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(sum <span style="color:#f92672">-</span> arr[i]) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># adding element which can contribute to</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># sum</span>
</span></span><span style="display:flex;"><span>      temp<span style="color:#f92672">.</span>append(arr[i])
</span></span><span style="display:flex;"><span>      findNumbers(ans, arr, temp, sum<span style="color:#f92672">-</span>arr[i], i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># removing element from list (backtracking)</span>
</span></span><span style="display:flex;"><span>      temp<span style="color:#f92672">.</span>remove(arr[i])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>]
</span></span><span style="display:flex;"><span>sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>ans <span style="color:#f92672">=</span> combinationSum(arr, sum)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># If result is empty, then</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> len(ans) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;empty&#34;</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print all combinations stored in ans</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(ans)):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;(&#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(ans[i])):
</span></span><span style="display:flex;"><span>    print(str(ans[i][j])<span style="color:#f92672">+</span><span style="color:#e6db74">&#34; &#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;)&#34;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span></code></pre></div><h2 id="find-maximum-number-possible-by-doing-at-most-k-swaps">Find Maximum number possible by doing at-most K swaps<a hidden class="anchor" aria-hidden="true" href="#find-maximum-number-possible-by-doing-at-most-k-swaps">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a positive integer, find the maximum integer possible by doing at-most K swap operations on its digits.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Examples: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: M = 254, K = 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: 524
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Swap 5 with 2 so number becomes 524
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># function to find maximum integer possible by doing at-most K swap operations on its digits</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMaximumNum</span>(string, k, maxm, ctr):
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># return if no swaps left</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> k <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  n <span style="color:#f92672">=</span> len(string)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Consider every digit after the cur position</span>
</span></span><span style="display:flex;"><span>  mx <span style="color:#f92672">=</span> string[ctr]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(ctr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,n):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Find maximum digit greater than at ctr among rest</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> int(string[i]) <span style="color:#f92672">&gt;</span> int(mx):
</span></span><span style="display:flex;"><span>      mx<span style="color:#f92672">=</span>string[i]
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If maxm is not equal to str[ctr], decrement k  </span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(mx<span style="color:#f92672">!=</span>string[ctr]):
</span></span><span style="display:flex;"><span>    k<span style="color:#f92672">=</span>k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># search this maximum among the rest from behind first swap the last maximum digit if it occurs more then 1 time</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># example str= 1293498 and k=1 then max string is 9293418 instead of 9213498</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(ctr,n):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If digit equals maxm swap the digit with current digit and recurse for the rest</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(string[i]<span style="color:#f92672">==</span>mx):
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># swap str[ctr] with str[j]</span>
</span></span><span style="display:flex;"><span>      string[ctr], string[i] <span style="color:#f92672">=</span> string[i], string[ctr]
</span></span><span style="display:flex;"><span>      new_str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(string)
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># If current num is more than maximum so far</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> int(new_str) <span style="color:#f92672">&gt;</span> int(maxm[<span style="color:#ae81ff">0</span>]):
</span></span><span style="display:flex;"><span>        maxm[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> new_str
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># recurse of the other k - 1 swaps</span>
</span></span><span style="display:flex;"><span>      findMaximumNum(string, k , maxm, ctr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># backtrack</span>
</span></span><span style="display:flex;"><span>      string[ctr], string[i] <span style="color:#f92672">=</span> string[i], string[ctr]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;129814999&#34;</span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>maxm <span style="color:#f92672">=</span> [string]
</span></span><span style="display:flex;"><span>string <span style="color:#f92672">=</span> [char <span style="color:#66d9ef">for</span> char <span style="color:#f92672">in</span> string]
</span></span><span style="display:flex;"><span>findMaximumNum(string, k, maxm, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>print(maxm[<span style="color:#ae81ff">0</span>])
</span></span></code></pre></div><h2 id="print-all-permutations-of-a-string">Print all permutations of a string<a hidden class="anchor" aria-hidden="true" href="#print-all-permutations-of-a-string">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">permute</span>(s, answer):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (len(s) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    print(answer, end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s)):
</span></span><span style="display:flex;"><span>    ch <span style="color:#f92672">=</span> s[i]
</span></span><span style="display:flex;"><span>    left_substr <span style="color:#f92672">=</span> s[<span style="color:#ae81ff">0</span>:i]
</span></span><span style="display:flex;"><span>    right_substr <span style="color:#f92672">=</span> s[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>    rest <span style="color:#f92672">=</span> left_substr <span style="color:#f92672">+</span> right_substr
</span></span><span style="display:flex;"><span>    permute(rest, answer <span style="color:#f92672">+</span> ch)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>answer<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;alex&#34;</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;All possible strings are : &#34;</span>)
</span></span><span style="display:flex;"><span>permute(s, answer)
</span></span></code></pre></div><h2 id="find-if-there-is-a-path-of-more-than-k-length-from-a-source">Find if there is a path of more than k length from a source<a hidden class="anchor" aria-hidden="true" href="#find-if-there-is-a-path-of-more-than-k-length-from-a-source">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Program to find if there is a simple path with weight more than k</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This class represents a dipathted graph using adjacency list representation</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Allocates memory for adjacency list</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, V):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>V <span style="color:#f92672">=</span> V
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>adj <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(V)]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Returns true if graph has path more than k length</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pathMoreThanK</span>(self,src, k):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Create a path array with nothing included in path</span>
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>]<span style="color:#f92672">*</span>self<span style="color:#f92672">.</span>V
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Add source vertex to path</span>
</span></span><span style="display:flex;"><span>    path[src] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>pathMoreThanKUtil(src, k, path)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Prints shortest paths from src to all other vertices</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pathMoreThanKUtil</span>(self,src, k, path):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If k is 0 or negative, return true</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Get all adjacent vertices of source vertex src and recursively explore all paths from src.</span>
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> i <span style="color:#f92672">!=</span> len(self<span style="color:#f92672">.</span>adj[src]):
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># Get adjacent vertex and weight of edge</span>
</span></span><span style="display:flex;"><span>      v <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>adj[src][i][<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>      w <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>adj[src][i][<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>      i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># If vertex v is already there in path, then there is a cycle (we ignore this edge)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (path[v] <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># If weight of is more than k, return true</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (w <span style="color:#f92672">&gt;=</span> k):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># Else add this vertex to path</span>
</span></span><span style="display:flex;"><span>      path[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># If this adjacent can provide a path longer than k, return true.</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (self<span style="color:#f92672">.</span>pathMoreThanKUtil(v, k<span style="color:#f92672">-</span>w, path)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># Backtrack</span>
</span></span><span style="display:flex;"><span>      path[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If no adjacent could produce longer path, return false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Utility function to an edge (u, v) of weight w</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addEdge</span>(self,u, v, w):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>adj[u]<span style="color:#f92672">.</span>append([v, w])
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>adj[v]<span style="color:#f92672">.</span>append([u, w])
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># create the graph given in above figure</span>
</span></span><span style="display:flex;"><span>V <span style="color:#f92672">=</span> <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> Graph(V)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># making above shown graph</span>
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">11</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">9</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>g<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#calling in the function</span>
</span></span><span style="display:flex;"><span>src <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">62</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Yes&#34;</span>) <span style="color:#66d9ef">if</span> g<span style="color:#f92672">.</span>pathMoreThanK(src, k) <span style="color:#66d9ef">else</span> print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">60</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Yes&#34;</span>) <span style="color:#66d9ef">if</span> g<span style="color:#f92672">.</span>pathMoreThanK(src, k) <span style="color:#66d9ef">else</span> print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span></code></pre></div><h2 id="longest-possible-route-in-a-matrix-with-hurdles">Longest Possible Route in a Matrix with Hurdles<a hidden class="anchor" aria-hidden="true" href="#longest-possible-route-in-a-matrix-with-hurdles">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Python program to find Longest Possible Route in a matrix with hurdles</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>R,C <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A Pair to store status of a cell. found is set to True of destination is reachable and value stores</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># distance of longest path</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Pair</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, found, value):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>found <span style="color:#f92672">=</span> found
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span> value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find Longest Possible Route in the matrix with hurdles. If the destination is not reachable</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the function returns false with cost sys.maxsize. (i, j) is source cell and (x, y) is destination cell.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findLongestPathUtil</span>(mat, i, j, x, y, visited):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># if (i, j) itself is destination, return True</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> x <span style="color:#f92672">and</span> j <span style="color:#f92672">==</span> y):
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Pair( <span style="color:#66d9ef">True</span>, <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># if not a valid cell, return false</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">&gt;=</span> R <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">&gt;=</span> C <span style="color:#f92672">or</span> mat[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> visited[i][j]) :
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Pair( <span style="color:#66d9ef">False</span>, sys<span style="color:#f92672">.</span>maxsize )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># include (i, j) in current path i.e. set visited(i, j) to True</span>
</span></span><span style="display:flex;"><span>  visited[i][j] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># res stores longest path from current cell (i, j) to destination cell (x, y)</span>
</span></span><span style="display:flex;"><span>  res <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>sys<span style="color:#f92672">.</span>maxsize <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># go left from current cell</span>
</span></span><span style="display:flex;"><span>  sol <span style="color:#f92672">=</span> findLongestPathUtil(mat, i, j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, x, y, visited)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># if destination can be reached on going left from current cell, update res</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (sol<span style="color:#f92672">.</span>found):
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> max(res, sol<span style="color:#f92672">.</span>value)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># go right from current cell</span>
</span></span><span style="display:flex;"><span>  sol <span style="color:#f92672">=</span> findLongestPathUtil(mat, i, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, x, y, visited)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># if destination can be reached on going right from current cell, update res</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (sol<span style="color:#f92672">.</span>found):
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> max(res, sol<span style="color:#f92672">.</span>value)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># go up from current cell</span>
</span></span><span style="display:flex;"><span>  sol <span style="color:#f92672">=</span> findLongestPathUtil(mat, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j, x, y, visited)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># if destination can be reached on going up from current cell, update res</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (sol<span style="color:#f92672">.</span>found):
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> max(res, sol<span style="color:#f92672">.</span>value)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># go down from current cell</span>
</span></span><span style="display:flex;"><span>  sol <span style="color:#f92672">=</span> findLongestPathUtil(mat, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j, x, y, visited)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># if destination can be reached on going down from current cell, update res</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (sol<span style="color:#f92672">.</span>found):
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> max(res, sol<span style="color:#f92672">.</span>value)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Backtrack</span>
</span></span><span style="display:flex;"><span>  visited[i][j] <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># if destination can be reached from current cell, return True</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>sys<span style="color:#f92672">.</span>maxsize <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Pair( <span style="color:#66d9ef">True</span>, <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> res )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># if destination can&#39;t be reached from current cell, return false</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> Pair( <span style="color:#66d9ef">False</span>, sys<span style="color:#f92672">.</span>maxsize )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A wrapper function over findLongestPathUtil()</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findLongestPath</span>(mat, i, j, x,y):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># create a boolean matrix to store info about cells already visited in current route initialize visited to false</span>
</span></span><span style="display:flex;"><span>  visited <span style="color:#f92672">=</span> [[<span style="color:#66d9ef">False</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(C)]<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(R)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># find longest route from (i, j) to (x, y) and print its maximum cost</span>
</span></span><span style="display:flex;"><span>  p <span style="color:#f92672">=</span> findLongestPathUtil(mat, i, j, x, y, visited)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (p<span style="color:#f92672">.</span>found):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Length of longest possible route is &#34;</span>,str(p<span style="color:#f92672">.</span>value))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If the destination is not reachable</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Destination not reachable from given source&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># input matrix with hurdles shown with number 0</span>
</span></span><span style="display:flex;"><span>mat <span style="color:#f92672">=</span> [ [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> ],
</span></span><span style="display:flex;"><span>    [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ] ]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># find longest path with source (0, 0) and destination (1, 7)</span>
</span></span><span style="display:flex;"><span>findLongestPath(mat, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>)
</span></span></code></pre></div><h2 id="print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix">Print all possible paths from top left to bottom right of a mXn matrix<a hidden class="anchor" aria-hidden="true" href="#print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The problem is to print all the possible paths from top left to bottom right of a mXn matrix with the constraints that from each cell you can either move only to right or down.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Examples : 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : 1 2 3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        4 5 6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : 1 4 5 6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         1 2 5 6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         1 2 3 6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : 1 2 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        3 4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : 1 2 4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         1 3 4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printAllPaths</span>(M, m, n):
</span></span><span style="display:flex;"><span>  mapping <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> mapping<span style="color:#f92672">.</span>get((m,n)):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> m <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> [M[m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>      res <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> printAllPaths(M, m, n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> a:
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(i, list):
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">=</span> [i]
</span></span><span style="display:flex;"><span>          res<span style="color:#f92672">.</span>append(i<span style="color:#f92672">+</span>[M[m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]])
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> m <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        b <span style="color:#f92672">=</span>printAllPaths(M, m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, n)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> b:
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(i, list):
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">=</span> [i]
</span></span><span style="display:flex;"><span>          res<span style="color:#f92672">.</span>append(i<span style="color:#f92672">+</span>[M[m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]])
</span></span><span style="display:flex;"><span>    mapping[(m,n)] <span style="color:#f92672">=</span> res
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> mapping<span style="color:#f92672">.</span>get((m,n))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>M <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>]]
</span></span><span style="display:flex;"><span>m, n <span style="color:#f92672">=</span> len(M), len(M[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>res <span style="color:#f92672">=</span> printAllPaths(M, m, n)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> res:
</span></span><span style="display:flex;"><span>  print(i)
</span></span></code></pre></div><h2 id="partition-of-a-set-intok-subsets-with-equal-sum">Partition of a set intoK subsets with equal sum<a hidden class="anchor" aria-hidden="true" href="#partition-of-a-set-intok-subsets-with-equal-sum">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : arr = [2, 1, 4, 5, 6], K = 3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : Yes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">we can divide above array into 3 parts with equal
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">sum as [[2, 4], [1, 5], [6]]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input  : arr = [2, 1, 5, 5, 6], K = 3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : No
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">It is not possible to divide above array into 3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">parts with equal sum
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;*
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">array   - given input array
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">subsetSum array - sum to store each subset of the array
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">taken   -boolean array to check whether element
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">is taken into sum partition or not
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">K     - number of partitions needed
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">N     - total number of element in array
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">curIdx   - current subsetSum index
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">limitIdx   - lastIdx from where array element should
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">be taken &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isKPartitionPossibleRec</span>(arr, subsetSum, taken, subset, K, N, curIdx, limitIdx):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> subsetSum[curIdx] <span style="color:#f92672">==</span> subset:
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    current index (K - 2) represents (K - 1)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    subsets of equal sum last partition will
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    already remain with sum &#39;subset&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (curIdx <span style="color:#f92672">==</span> K <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursive call for next subsetition</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> isKPartitionPossibleRec(arr, subsetSum, taken,
</span></span><span style="display:flex;"><span>                  subset, K, N, curIdx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> , N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># start from limitIdx and include elements into current partition</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(limitIdx, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if already taken, continue</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (taken[i]):
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> subsetSum[curIdx] <span style="color:#f92672">+</span> arr[i]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if temp is less than subset, then only include the element and call recursively</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (tmp <span style="color:#f92672">&lt;=</span> subset):
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># mark the element and include into current partition sum</span>
</span></span><span style="display:flex;"><span>      taken[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>      subsetSum[curIdx] <span style="color:#f92672">+=</span> arr[i]
</span></span><span style="display:flex;"><span>      nxt <span style="color:#f92672">=</span> isKPartitionPossibleRec(arr, subsetSum, taken,
</span></span><span style="display:flex;"><span>                    subset, K, N, curIdx, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># after recursive call unmark the element and remove from subsetition sum</span>
</span></span><span style="display:flex;"><span>      taken[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>      subsetSum[curIdx] <span style="color:#f92672">-=</span> arr[i]
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (nxt):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Method returns True if arr can be partitioned into K subsets with equal sum</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isKPartitionPossible</span>(arr, N, K):
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If K is 1, then complete array will be our answer</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (K <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If total number of partitions are more than N, then division is not possible</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (N <span style="color:#f92672">&lt;</span> K):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># if array sum is not divisible by K then we can&#39;t divide array into K partitions</span>
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>    sum <span style="color:#f92672">+=</span> arr[i]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">%</span> K <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># the sum of each subset should be subset (= sum / K)</span>
</span></span><span style="display:flex;"><span>  subset <span style="color:#f92672">=</span> sum <span style="color:#f92672">//</span> K
</span></span><span style="display:flex;"><span>  subsetSum <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> K
</span></span><span style="display:flex;"><span>  taken <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> N
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Initialize sum of each subset from 0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(K):
</span></span><span style="display:flex;"><span>    subsetSum[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># mark all elements as not taken</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>    taken[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># initialize first subset sum as last element of array and mark that as taken</span>
</span></span><span style="display:flex;"><span>  subsetSum[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> arr[N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>  taken[N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># call recursive method to check K-substitution condition</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> isKPartitionPossibleRec(arr, subsetSum, taken,
</span></span><span style="display:flex;"><span>                subset, K, N, <span style="color:#ae81ff">0</span>, N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span> ]
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> len(arr)
</span></span><span style="display:flex;"><span>K <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (isKPartitionPossible(arr, N, K)):
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Partitions into equal sum is possible.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Partitions into equal sum is not possible.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><h2 id="find-the-k-th-permutation-sequence-of-first-n-natural-numbers">Find the K-th Permutation Sequence of first N natural numbers<a hidden class="anchor" aria-hidden="true" href="#find-the-k-th-permutation-sequence-of-first-n-natural-numbers">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: N = 3, K = 4 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: 231 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The ordered list of permutation sequence from integer 1 to 3 is : 123, 132, 213, 231, 312, 321. So, the 4th permutation sequence is “231”.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: N = 2, K = 1 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: 12 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">For n = 2, only 2 permutations are possible 12 21. So, the 1st permutation sequence is “12”. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find the index of number at first position of kth sequence of set of size n</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findFirstNumIndex</span>(k, n):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, k
</span></span><span style="display:flex;"><span>  n <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  first_num_index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># n_actual_fact = n!</span>
</span></span><span style="display:flex;"><span>  n_partial_fact <span style="color:#f92672">=</span> n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (k <span style="color:#f92672">&gt;=</span> n_partial_fact <span style="color:#f92672">and</span> n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    n_partial_fact <span style="color:#f92672">=</span> n_partial_fact <span style="color:#f92672">*</span> (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># First position of the kth sequence will be occupied by the number present at index = k / (n-1)!</span>
</span></span><span style="display:flex;"><span>  first_num_index <span style="color:#f92672">=</span> k <span style="color:#f92672">//</span> n_partial_fact
</span></span><span style="display:flex;"><span>  k <span style="color:#f92672">=</span> k <span style="color:#f92672">%</span> n_partial_fact
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> first_num_index, k
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find the kth permutation of n numbers</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findKthPermutation</span>(n, k):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Store final answer</span>
</span></span><span style="display:flex;"><span>  ans <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>  s <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Insert all natural number upto n in set</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    s<span style="color:#f92672">.</span>add(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Subtract 1 to get 0 based indexing</span>
</span></span><span style="display:flex;"><span>  k <span style="color:#f92672">=</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Mark the first position</span>
</span></span><span style="display:flex;"><span>    itr <span style="color:#f92672">=</span> list(s)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    index, k <span style="color:#f92672">=</span> findFirstNumIndex(k, n <span style="color:#f92672">-</span> i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># itr now points to the number at index in set s</span>
</span></span><span style="display:flex;"><span>    ans <span style="color:#f92672">+=</span> str(itr[index])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># remove current number from the set</span>
</span></span><span style="display:flex;"><span>    itr<span style="color:#f92672">.</span>pop(index)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> set(itr)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ans
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>kth_perm_seq <span style="color:#f92672">=</span> findKthPermutation(n, k)
</span></span><span style="display:flex;"><span>print(kth_perm_seq)
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://atharvashah.netlify.app/tags/dsa-python/">DSA-Python</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://atharvashah.netlify.app/blog/dsapython/arrays/">
    <span class="title">« Prev</span>
    <br>
    <span>DSA in Python - Arrays</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Backtracking on twitter"
        href="https://twitter.com/intent/tweet/?text=DSA%20in%20Python%20-%20Backtracking&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbacktracking%2f&amp;hashtags=DSA-Python">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Backtracking on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbacktracking%2f&amp;title=DSA%20in%20Python%20-%20Backtracking&amp;summary=DSA%20in%20Python%20-%20Backtracking&amp;source=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbacktracking%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Backtracking on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbacktracking%2f&title=DSA%20in%20Python%20-%20Backtracking">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Backtracking on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbacktracking%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Backtracking on whatsapp"
        href="https://api.whatsapp.com/send?text=DSA%20in%20Python%20-%20Backtracking%20-%20https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbacktracking%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Backtracking on telegram"
        href="https://telegram.me/share/url?text=DSA%20in%20Python%20-%20Backtracking&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbacktracking%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-atharvashah-netlify-app" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    (function() {
        
        
        if (window.location.hostname == "localhost")
            return;

        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        var disqus_shortname = 'https-atharvashah-netlify-app';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://atharvashah.netlify.app/">Atharva Shah</a></span> 
    | <span><a href="/privacy-policy/" target="_blank">Privacy Policy</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function() {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function(e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function() {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {};
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
