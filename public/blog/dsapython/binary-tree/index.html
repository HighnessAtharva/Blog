<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DSA in Python - Binary Trees | Atharva Shah</title>
<meta name="keywords" content="DSA-Python">
<meta name="description" content="Level order traversal AKA BFS Reverse Level Order traversal Height of a tree Diameter of a tree Mirror of a tree / Invert Binary Tree Inorder, Preorder and Postorder Tree Traversal (Recursive Method) Left View of a tree Right View of Tree Top View of a tree Bottom View of a tree Zig-Zag traversal of a binary tree Check if a tree is balanced or not Diagonal Traversal of a Binary tree Boundary traversal of a Binary tree Construct Binary Tree from String with Bracket Representation Convert Binary tree into Doubly Linked List Convert Binary tree into Sum tree Construct Binary tree from Inorder and preorder traversal Find minimum swaps required to convert a Binary tree into BST Check if Binary tree is Sum tree or not Check if all leaf nodes are at same level or not Check if a Binary Tree contains duplicate subtrees of size 2 or more Check if 2 trees are mirror or not Sum of Nodes on the Longest path from root to leaf node Check if given graph is tree or not Find Largest subtree sum in a tree Maximum Sum of nodes in Binary tree such that no two are adjacent Print all &ldquo;K&rdquo; Sum paths in a Binary tree Find Least Common Ancestor in a Binary tree Find distance between 2 nodes in a Binary tree Kth Ancestor of node in a Binary tree Find all Duplicate subtrees in a Binary tree Tree Isomorphism Problem Level order traversal AKA BFS class Node: def __init__(self, key): self.">
<meta name="author" content="">
<link rel="canonical" href="https://atharvashah.netlify.app/blog/dsapython/binary-tree/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.061a8952013664c99bacf079b6effc1f4b8dcc97ae88ed4456398d0f7830bf89.css" integrity="sha256-BhqJUgE2ZMmbrPB5tu/8H0uNzJeuiO1EVjmND3gwv4k=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://atharvashah.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://atharvashah.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://atharvashah.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://atharvashah.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://atharvashah.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9913536001930134" crossorigin="anonymous"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="DSA in Python - Binary Trees" />
<meta property="og:description" content="Level order traversal AKA BFS Reverse Level Order traversal Height of a tree Diameter of a tree Mirror of a tree / Invert Binary Tree Inorder, Preorder and Postorder Tree Traversal (Recursive Method) Left View of a tree Right View of Tree Top View of a tree Bottom View of a tree Zig-Zag traversal of a binary tree Check if a tree is balanced or not Diagonal Traversal of a Binary tree Boundary traversal of a Binary tree Construct Binary Tree from String with Bracket Representation Convert Binary tree into Doubly Linked List Convert Binary tree into Sum tree Construct Binary tree from Inorder and preorder traversal Find minimum swaps required to convert a Binary tree into BST Check if Binary tree is Sum tree or not Check if all leaf nodes are at same level or not Check if a Binary Tree contains duplicate subtrees of size 2 or more Check if 2 trees are mirror or not Sum of Nodes on the Longest path from root to leaf node Check if given graph is tree or not Find Largest subtree sum in a tree Maximum Sum of nodes in Binary tree such that no two are adjacent Print all &ldquo;K&rdquo; Sum paths in a Binary tree Find Least Common Ancestor in a Binary tree Find distance between 2 nodes in a Binary tree Kth Ancestor of node in a Binary tree Find all Duplicate subtrees in a Binary tree Tree Isomorphism Problem Level order traversal AKA BFS class Node: def __init__(self, key): self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://atharvashah.netlify.app/blog/dsapython/binary-tree/" />
<meta property="og:image" content="https://atharvashah.netlify.app/blog/dsa/binary-tree.jpg" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-07-08T13:18:34+05:30" />
<meta property="article:modified_time" content="2022-07-08T13:18:34+05:30" /><meta property="og:site_name" content="Atharva Shah" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://atharvashah.netlify.app/blog/dsa/binary-tree.jpg" />
<meta name="twitter:title" content="DSA in Python - Binary Trees"/>
<meta name="twitter:description" content="Level order traversal AKA BFS Reverse Level Order traversal Height of a tree Diameter of a tree Mirror of a tree / Invert Binary Tree Inorder, Preorder and Postorder Tree Traversal (Recursive Method) Left View of a tree Right View of Tree Top View of a tree Bottom View of a tree Zig-Zag traversal of a binary tree Check if a tree is balanced or not Diagonal Traversal of a Binary tree Boundary traversal of a Binary tree Construct Binary Tree from String with Bracket Representation Convert Binary tree into Doubly Linked List Convert Binary tree into Sum tree Construct Binary tree from Inorder and preorder traversal Find minimum swaps required to convert a Binary tree into BST Check if Binary tree is Sum tree or not Check if all leaf nodes are at same level or not Check if a Binary Tree contains duplicate subtrees of size 2 or more Check if 2 trees are mirror or not Sum of Nodes on the Longest path from root to leaf node Check if given graph is tree or not Find Largest subtree sum in a tree Maximum Sum of nodes in Binary tree such that no two are adjacent Print all &ldquo;K&rdquo; Sum paths in a Binary tree Find Least Common Ancestor in a Binary tree Find distance between 2 nodes in a Binary tree Kth Ancestor of node in a Binary tree Find all Duplicate subtrees in a Binary tree Tree Isomorphism Problem Level order traversal AKA BFS class Node: def __init__(self, key): self."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://atharvashah.netlify.app/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "DSA in Python - Binary Trees",
      "item": "https://atharvashah.netlify.app/blog/dsapython/binary-tree/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DSA in Python - Binary Trees",
  "name": "DSA in Python - Binary Trees",
  "description": "Level order traversal AKA BFS Reverse Level Order traversal Height of a tree Diameter of a tree Mirror of a tree / Invert Binary Tree Inorder, Preorder and Postorder Tree Traversal (Recursive Method) Left View of a tree Right View of Tree Top View of a tree Bottom View of a tree Zig-Zag traversal of a binary tree Check if a tree is balanced or not Diagonal Traversal of a Binary tree Boundary traversal of a Binary tree Construct Binary Tree from String with Bracket Representation Convert Binary tree into Doubly Linked List Convert Binary tree into Sum tree Construct Binary tree from Inorder and preorder traversal Find minimum swaps required to convert a Binary tree into BST Check if Binary tree is Sum tree or not Check if all leaf nodes are at same level or not Check if a Binary Tree contains duplicate subtrees of size 2 or more Check if 2 trees are mirror or not Sum of Nodes on the Longest path from root to leaf node Check if given graph is tree or not Find Largest subtree sum in a tree Maximum Sum of nodes in Binary tree such that no two are adjacent Print all \u0026ldquo;K\u0026rdquo; Sum paths in a Binary tree Find Least Common Ancestor in a Binary tree Find distance between 2 nodes in a Binary tree Kth Ancestor of node in a Binary tree Find all Duplicate subtrees in a Binary tree Tree Isomorphism Problem Level order traversal AKA BFS class Node: def __init__(self, key): self.",
  "keywords": [
    "DSA-Python"
  ],
  "articleBody": " Level order traversal AKA BFS Reverse Level Order traversal Height of a tree Diameter of a tree Mirror of a tree / Invert Binary Tree Inorder, Preorder and Postorder Tree Traversal (Recursive Method) Left View of a tree Right View of Tree Top View of a tree Bottom View of a tree Zig-Zag traversal of a binary tree Check if a tree is balanced or not Diagonal Traversal of a Binary tree Boundary traversal of a Binary tree Construct Binary Tree from String with Bracket Representation Convert Binary tree into Doubly Linked List Convert Binary tree into Sum tree Construct Binary tree from Inorder and preorder traversal Find minimum swaps required to convert a Binary tree into BST Check if Binary tree is Sum tree or not Check if all leaf nodes are at same level or not Check if a Binary Tree contains duplicate subtrees of size 2 or more Check if 2 trees are mirror or not Sum of Nodes on the Longest path from root to leaf node Check if given graph is tree or not Find Largest subtree sum in a tree Maximum Sum of nodes in Binary tree such that no two are adjacent Print all “K” Sum paths in a Binary tree Find Least Common Ancestor in a Binary tree Find distance between 2 nodes in a Binary tree Kth Ancestor of node in a Binary tree Find all Duplicate subtrees in a Binary tree Tree Isomorphism Problem Level order traversal AKA BFS class Node: def __init__(self, key): self.data = key self.left = None self.right = None def printLevelOrder(root): # Base Case if root is None: return # Create an empty queue for level order traversal queue = [] # Enqueue Root and initialize height queue.append(root) while(len(queue) \u003e 0): # Print front of queue and remove it from queue print(queue[0].data) node = queue.pop(0) # Enqueue left child if node.left is not None: queue.append(node.left) # Enqueue right child if node.right is not None: queue.append(node.right) root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) print(\"Level Order Traversal of binary tree is -\") printLevelOrder(root) Reverse Level Order traversal from collections import deque class Node: def __init__(self, data): self.data = data self.left = None self.right = None def reverseLevelOrder(root): q = deque() q.append(root) ans = deque() while q: node = q.popleft() if node is None: continue ans.appendleft(node.data) if node.right: q.append(node.right) if node.left: q.append(node.left) return ans root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) print (\"Level Order traversal of binary tree is\", reverseLevelOrder(root)) Height of a tree \"\"\" Given a binary tree, find height of it. Height of empty tree is -1, height of tree with one node is 0 \"\"\" class Node: # Constructor to create a new node def __init__(self, data): self.data = data self.left = None self.right = None # Compute the \"maxDepth\" of a tree -- the number of nodes along the longest path from the root node down to the # farthest leaf node def maxDepth(node): if node is None: return 0 ; else : # Compute the depth of each subtree lDepth = maxDepth(node.left) rDepth = maxDepth(node.right) # Use the larger one if (lDepth \u003e rDepth): return lDepth+1 else: return rDepth+1 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) print (\"Height of tree is %d\" %(maxDepth(root))) Diameter of a tree class Node: def __init__(self, data): self.data = data self.left = None self.right = None def height(node): # Base Case : Tree is empty if node is None: return 0 # If tree is not empty then height = 1 + max of left # height and right heights return 1 + max(height(node.left), height(node.right)) # Function to get the diameter of a binary tree def diameter(root): # Base Case when tree is empty if root is None: return 0 # Get the height of left and right sub-trees lheight = height(root.left) rheight = height(root.right) # Get the diameter of left and right sub-trees ldiameter = diameter(root.left) rdiameter = diameter(root.right) # Return max of the following tree: # 1) Diameter of left subtree # 2) Diameter of right subtree # 3) Height of left subtree + height of right subtree +1 return max(lheight + rheight + 1, max(ldiameter, rdiameter)) \"\"\" Constructed binary tree is 1 / \\ 2 3 / \\ 4 5 \"\"\" root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) print(diameter(root)) Mirror of a tree / Invert Binary Tree from collections import deque class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform preorder traversal on a given binary tree def preorder(root): if root is None: return print(root.data, end=' ') preorder(root.left) preorder(root.right) # Utility function to swap left subtree with right subtree def swap(root): if root is None: return temp = root.left root.left = root.right root.right = temp # Iterative function to invert a given binary tree using a queue def invertBinaryTree(root): # base case: if the tree is empty if root is None: return # maintain a queue and push the root node q = deque() q.append(root) # loop till queue is empty while q: # dequeue front node curr = q.popleft() # swap the left child with the right child swap(curr) # enqueue left child of the popped node if curr.left: q.append(curr.left) # enqueue right child of the popped node if curr.right: q.append(curr.right) ''' Construct the following tree 1 / \\ / \\ 2 3 / \\ / \\ 4 5 6 7 ''' root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) invertBinaryTree(root) preorder(root) Inorder, Preorder and Postorder Tree Traversal (Recursive Method) class Node: def __init__(self, data=None, left=None, right=None): self.data = data self.left = left self.right = right def preorder(root): if root is None: return print(root.data, end=' ') preorder(root.left) preorder(root.right) def inorder(root): if root is None: return inorder(root.left) print(root.data, end=' ') inorder(root.right) def postorder(root): if root is None: return postorder(root.left) postorder(root.right) print(root.data, end=' ') ''' Construct the following tree 1 / \\ / \\ 2 3 / / \\ / / \\ 4 5 6 / \\ / \\ 7 8 ''' root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) print(\"Preorder: \",preorder(root)) print(\"Inorder: \",inorder(root)) print(\"PostOrder: \",postorder(root)) Left View of a tree class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right def leftView(root, level=1, last_level=0): # base case: empty tree if root is None: return last_level # if the current node is the first node of the current level if last_level \u003c level: # print the node's data print(root.key, end=' ') # update the last level to the current level last_level = level # recur for the left and right subtree by increasing the level by 1 last_level = leftView(root.left, level + 1, last_level) last_level = leftView(root.right, level + 1, last_level) return last_level root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) leftView(root) Right View of Tree class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right def RightView(root, level=1, lastLevel=0): if root is None: return lastLevel # if the current node is the last node of the current level if lastLevel \u003c level: # print the node's data print(root.key, end=' ') # update the last level to the current level lastLevel = level # recur for the right and left subtree by increasing level by 1 lastLevel = RightView(root.right, level + 1, lastLevel) lastLevel = RightView(root.left, level + 1, lastLevel) return lastLevel root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) RightView(root) Top View of a tree class Node: def __init__(self, key=None, left=None, right=None): self.key = key self.left = left self.right = right # Recursive function to perform preorder traversal on the tree and fill the dictionary. # Here, the node has `dist` horizontal distance from the tree's root, and the level represents the node's level. def printTop(root, dist, level, d): if root is None: return # if the current level is less than the maximum level seen so far for the same horizontal distance, or if # the horizontal distance is seen for the first time, update the dictionary if dist not in d or level \u003c d[dist][1]: # update value and level for current distance d[dist] = (root.key, level) # recur for the left subtree by decreasing horizontal distance and increasing level by 1 printTop(root.left, dist - 1, level + 1, d) # recur for the right subtree by increasing both level and horizontal distance by 1 printTop(root.right, dist + 1, level + 1, d) def printTopView(root): # create a dictionary where # key —\u003e relative horizontal distance of the node from the root node, and # value —\u003e pair containing the node's value and its level d = {} # perform preorder traversal on the tree and fill the dictionary printTop(root, 0, 0, d) # traverse the dictionary in sorted order of keys and print the top view for key in sorted(d.keys()): print(d.get(key)[0], end=' ') root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) printTopView(root) Bottom View of a tree class Node: def __init__(self, key=None, left=None, right=None): self.key = key self.left = left self.right = right # Recursive function to perform preorder traversal on the tree and fill the map. # Here, the node has `dist` horizontal distance from the tree's root, and the `level` represents the node's level. def printBottom(root, dist, level, d): # base case: empty tree if root is None: return # if the current level is more than or equal to the maximum level seen so far for the same horizontal distance # or horizontal distance is seen for the first time, update the dictionary if dist not in d or level \u003e= d[dist][1]: # update value and level for the current distance d[dist] = (root.key, level) # recur for the left subtree by decreasing horizontal distance and increasing level by 1 printBottom(root.left, dist - 1, level + 1, d) # recur for the right subtree by increasing both level and horizontal distance by 1 printBottom(root.right, dist + 1, level + 1, d) # Function to print the bottom view of a given binary tree def printBottomView(root): # create a dictionary where # key —\u003e relative horizontal distance of the node from the root node, and # value —\u003e pair containing the node's value and its level d = {} # perform preorder traversal on the tree and fill the dictionary printBottom(root, 0, 0, d) # traverse the dictionary in sorted order of their keys and print the bottom view for key in sorted(d.keys()): print(d.get(key)[0], end=' ') root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) printBottomView(root) Zig-Zag traversal of a binary tree from collections import deque class Node: def __init__(self, key=None, left=None, right=None): self.key = key self.left = left self.right = right # Traverse the tree in a preorder fashion and store nodes in a dictionary corresponding to their level def preorder(root, level, d): if root is None: return # insert the current node and its level into the dictionary # if the level is odd, insert at the back; otherwise, search at front if level % 2 == 1: d.setdefault(level, deque()).append(root.key) else: d.setdefault(level, deque()).appendleft(root.key) # recur for the left and right subtree by increasing the level by 1 preorder(root.left, level + 1, d) preorder(root.right, level + 1, d) # Recursive function to print spiral order traversal of a given binary tree def SpiralOrderTraversal(root): # create an empty dictionary to store nodes between given levels d = {} # traverse the tree and insert its nodes into the dictionary corresponding to their level preorder(root, 1, d) # iterate through the dictionary and print all nodes present at every level for i in range(1, len(d) + 1): print(f'Level {i}:', list(d[i])) root = Node(15) root.left = Node(10) root.right = Node(20) root.left.left = Node(8) root.left.right = Node(12) root.right.left = Node(16) root.right.right = Node(25) root.left.left.left = Node(20) root.right.right.right = Node(30) SpiralOrderTraversal(root) Check if a tree is balanced or not \"\"\" Given a binary tree, write an efficient algorithm to check if it is height-balanced or not. In a height-balanced tree, the absolute difference between the height of the left and right subtree for every node is 0 or 1. \"\"\" class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right # Recursive function to check if a given binary tree is height-balanced or not def isHeightBalanced(root, isBalanced=True): # base case: tree is empty or not balanced if root is None or not isBalanced: return 0, isBalanced # get the height of the left subtree left_height, isBalanced = isHeightBalanced(root.left, isBalanced) # get the height of the right subtree right_height, isBalanced = isHeightBalanced(root.right, isBalanced) # tree is unbalanced if the absolute difference between the height of # its left and right subtree is more than 1 if abs(left_height - right_height) \u003e 1: isBalanced = False # return height of subtree rooted at the current node return max(left_height, right_height) + 1, isBalanced ''' Construct the following tree 1 / \\ / \\ 2 3 / \\ / 4 5 6 ''' root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) if isHeightBalanced(root)[1]: print('Binary tree is balanced') else: print('Binary tree is not balanced') Diagonal Traversal of a Binary tree class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Recursive function to perform preorder traversal on the tree and # fill the dictionary with diagonal elements def printDiagonal(node, diagonal, d): # base case: empty tree if node is None: return # insert the current node into the current diagonal d.setdefault(diagonal, []).append(node.data) # recur for the left subtree by increasing diagonal by 1 printDiagonal(node.left, diagonal + 1, d) # recur for the right subtree with the same diagonal printDiagonal(node.right, diagonal, d) # Function to print the diagonal elements of a given binary tree def printDiagonalElements(root): # create an empty dictionary to store the diagonal element in every slope d = {} # perform preorder traversal on the tree and fill the dictionary printDiagonal(root, 0, d) # traverse the dictionary and print diagonal elements for i in range(len(d)): print(d.get(i)) ''' Construct the following tree 1 / \\ / \\ 2 3 / / \\ / / \\ 4 5 6 / \\ / \\ 7 8 ''' root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) printDiagonalElements(root) Boundary traversal of a Binary tree class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def isLeaf(self): return self.left is None and self.right is None # Recursive function to print the left boundary of the given binary tree # in a top-down fashion, except for the leaf nodes def printLeftBoundary(root): if root is None: return node = root while not node.isLeaf(): print(node.data, end=' ') # next process, the left child of `root` if it exists; otherwise, move to the right child node = node.left if node.left else node.right # Recursive function to print the right boundary of the given binary tree # in a bottom-up fashion, except for the leaf nodes def printRightBoundary(root): if root is None or root.isLeaf(): return # recur for the right child of `root` if it exists; otherwise, recur for the left child printRightBoundary(root.right if root.right else root.left) # To ensure bottom-up order, print the value of the nodes after recursion unfolds print(root.data, end=' ') # Recursive function to print the leaf nodes of the given binary tree in an inorder fashion def printLeafNodes(root): if root is None: return printLeafNodes(root.left) # print only leaf nodes if root.isLeaf(): print(root.data, end=' ') # recur for the right subtree printLeafNodes(root.right) # Function to perform the boundary traversal on a given tree def performBoundaryTraversal(root): if root is None: return # print the root node print(root.data, end=' ') # print the left boundary (except leaf nodes) printLeftBoundary(root.left) # print all leaf nodes if not root.isLeaf(): printLeafNodes(root) # print the right boundary (except leaf nodes) printRightBoundary(root.right) root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) root.left.left.left = Node(8) root.left.left.right = Node(9) root.left.right.right = Node(10) root.right.right.left = Node(11) root.left.left.right.left = Node(12) root.left.left.right.right = Node(13) root.right.right.left.left = Node(14) performBoundaryTraversal(root) Construct Binary Tree from String with Bracket Representation class newNode: def __init__(self, data): self.data = data self.left = self.right = None def preOrder(node): if node is None: return print(node.data, end=\" \") preOrder(node.left) preOrder(node.right) # function to return the index of close parenthesis def findIndex(Str, si, ei): if (si \u003e ei): return -1 s = [] for i in range(si, ei + 1): # if open parenthesis, push it if (Str[i] == '('): s.append(Str[i]) elif (Str[i] == ')'): if (s[-1] == '('): s.pop(-1) # if stack is empty, this is # the required index if len(s) == 0: return i # if not found return -1 return -1 # function to conStruct tree from String def treeFromString(Str, si, ei): # Base case if (si \u003e ei): return None # new root root = newNode(ord(Str[si]) - ord('0')) index = -1 # if next char is '(' find the # index of its complement ')' if (si + 1 \u003c= ei and Str[si + 1] == '('): index = findIndex(Str, si + 1, ei) # if index found if (index != -1): # call for left subtree root.left = treeFromString(Str, si + 2, index - 1) # call for right subtree root.right = treeFromString(Str, index + 2, ei - 1) return root Str = \"4(2(3)(1))(6(5))\" root = treeFromString(Str, 0, len(Str) - 1) preOrder(root) Convert Binary tree into Doubly Linked List class Node(object): def __init__(self, item): self.data = item self.left = None self.right = None def BTToDLLUtil(root): \"\"\"This is a utility function to convert the binary tree to doubly linked list. Most of the core task is done by this function.\"\"\" if root is None: return root # Convert left subtree and link to root if root.left: # Convert the left subtree left = BTToDLLUtil(root.left) # Find inorder predecessor, After this loop, left will point to the # inorder predecessor of root while left.right: left = left.right # Make root as next of predecessor left.right = root # Make predecessor as previous of root root.left = left # Convert the right subtree and link to root if root.right: # Convert the right subtree right = BTToDLLUtil(root.right) # Find inorder successor, After this loop, right will point to the inorder successor of root while right.left: right = right.left # Make root as previous of successor right.left = root # Make successor as next of root root.right = right return root def BTToDLL(root): if root is None: return root # Convert to doubly linked list using BLLToDLLUtil root = BTToDLLUtil(root) # We need pointer to left most node which is head of the constructed Doubly Linked list while root.left: root = root.left return root def print_list(head): if head is None: return while head: print(head.data, end = \" \") head = head.right root = Node(10) root.left = Node(12) root.right = Node(15) root.left.left = Node(25) root.left.right = Node(30) root.right.left = Node(36) head = BTToDLL(root) print_list(head) Convert Binary tree into Sum tree # Given a Binary Tree where each node has positive and negative values. Convert this to a tree where each node contains the sum of the left and right sub trees in the original tree. The values of leaf nodes are changed to 0. class node: def __init__(self, data): self.left = None self.right = None self.data = data # Convert a given tree to a tree where every node contains sum of values of # nodes in left and right subtrees in the original tree def toSumTree(Node) : if Node is None: return 0 # Store the old value old_val = Node.data # Recursively call for left and right subtrees and store the sum as new value of this node Node.data = toSumTree(Node.left) + toSumTree(Node.right) # Return the sum of values of nodes in left and right subtrees and old_value of this node return Node.data + old_val # A utility function to print inorder traversal of a Binary Tree def printInorder(Node): if Node is None: return printInorder(Node.left) print(Node.data, end = \" \") printInorder(Node.right) # Utility function to create a new Binary Tree node def newNode(data) : temp = node(0) temp.data = data temp.left = None temp.right = None return temp root = newNode(10) root.left = newNode(-2) root.right = newNode(6) root.left.left = newNode(8) root.left.right = newNode(-4) root.right.left = newNode(7) root.right.right = newNode(5) toSumTree(root) print(\"Inorder Traversal of the resultant tree is: \") printInorder(root) Construct Binary tree from Inorder and preorder traversal # A class to store a binary tree node class Node: # Constructor def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Recursive function to perform inorder traversal on a given binary tree def inorderTraversal(root): if root is None: return inorderTraversal(root.left) print(root.data, end=' ') inorderTraversal(root.right) # Recursive function to perform postorder traversal on a given binary tree def preorderTraversal(root): if root is None: return print(root.data, end=' ') preorderTraversal(root.left) preorderTraversal(root.right) # Recursive function to construct a binary tree from a given inorder and preorder sequence def construct(start, end, preorder, pIndex, d): # base case if start \u003e end: return None, pIndex # The next element in `preorder[]` will be the root node of subtree # formed by sequence represented by `inorder[start, end]` root = Node(preorder[pIndex]) pIndex = pIndex + 1 # get the index of the root node in inorder to determine the # left and right subtree boundary index = d[root.data] # recursively construct the left subtree root.left, pIndex = construct(start, index - 1, preorder, pIndex, d) # recursively construct the right subtree root.right, pIndex = construct(index + 1, end, preorder, pIndex, d) # return current node return root, pIndex # Construct a binary tree from inorder and preorder traversals. # This function assumes that the input is valid i.e., given inorder and preorder sequence forms a binary tree def constructTree(inorder, preorder): # create a dictionary to efficiently find the index of any element in a given inorder sequence d = {} for i, e in enumerate(inorder): d[e] = i # `pIndex` stores the index of the next unprocessed node in a preorder sequence; # start with the root node (present at 0th index) pIndex = 0 return construct(0, len(inorder) - 1, preorder, pIndex, d)[0] ''' Construct the following tree 1 / \\ / \\ 2 3 / / \\ / / \\ 4 5 6 / \\ / \\ 7 8 ''' inorder = [4, 2, 1, 7, 5, 8, 3, 6] preorder = [1, 2, 4, 3, 5, 7, 8, 6] root = constructTree(inorder, preorder) print('The inorder traversal is ', end='') inorderTraversal(root) print('\\nThe preorder traversal is ', end='') preorderTraversal(root) Find minimum swaps required to convert a Binary tree into BST \"\"\" The idea is to use the fact that inorder traversal of Binary Search Tree is in increasing order of their value. So, find the inorder traversal of the Binary Tree and store it in the array and try to sort the array. The minimum number of swap required to get the array sorted will be the answer. \"\"\" def inorder(a, n, index): global v # If index is greater or equal to vector size if (index \u003e= n): return inorder(a, n, 2 * index + 1) # Push elements in vector v.append(a[index]) inorder(a, n, 2 * index + 2) def minSwaps(): global v t = [[0, 0] for _ in range(len(v))] ans = -2 for i in range(len(v)): t[i][0], t[i][1] = v[i], i t, i = sorted(t), 0 while i \u003c len(t): if (i == t[i][1]): i += 1 continue else: # Swapping of elements t[i][0], t[t[i][1]][0] = t[t[i][1]][0], t[i][0] t[i][1], t[t[i][1]][1] = t[t[i][1]][1], t[i][1] # Second is not equal to i if (i == t[i][1]): i -= 1 i += 1 ans += 1 return ans v = [] a = [5, 6, 7, 8, 9, 10, 11] n = len(a) inorder(a, n, 0) print(minSwaps()) Check if Binary tree is Sum tree or not class node: def __init__(self, x): self.data = x self.left = None self.right = None def isLeaf(node): if node is None: return 0 if node.left is None and node.right is None: return 1 return 0 # returns data if SumTree property holds for the given tree else return -1 def isSumTree(node): if node is None: return 0 ls = isSumTree(node.left) #To stop for further traversal of tree if found not sumTree if(ls == -1): return -1 rs = isSumTree(node.right) #To stop for further traversal of tree if found not sumTree if(rs == -1): return -1 return ls + rs + node.data if (isLeaf(node) or ls + rs == node.data) else -1 root = node(26) root.left = node(10) root.right = node(3) root.left.left = node(4) root.left.right = node(6) root.right.right = node(3) if(isSumTree(root)): print(\"The given tree is a SumTree \") else: print(\"The given tree is not a SumTree \") Check if all leaf nodes are at same level or not class Node: def __init__(self, data): self.data = data self.left = None self.right = None # Recursive function which check whether all leaves are at same level def checkUtil(root, level): if root is None: return True # If a tree node is encountered if root.left is None and root.right is None: # When a leaf node is found first time if check.leafLevel == 0 : check.leafLevel = level # Set first leaf found return True # If this is not first leaf node, compare its level with first leaf's level return level == check.leafLevel # If this is not first leaf node, compare its level with first leaf's level return (checkUtil(root.left, level+1)and checkUtil(root.right, level+1)) def check(root): level = 0 check.leafLevel = 0 return (checkUtil(root, level)) root = Node(12) root.left = Node(5) root.left.left = Node(3) root.left.right = Node(9) root.left.left.left = Node(1) root.left.right.left = Node(2) if(check(root)): print(\"Leaves are at same level\") else: print(\"Leaves are not at same level\") Check if a Binary Tree contains duplicate subtrees of size 2 or more # Helper function that allocates a new node with the given data and None left and right pointers. class newNode: def __init__(self, data): self.data = data self.left = self.right = None def inorder(node, m): if (not node): return \"\" Str = \"(\" Str += inorder(node.left, m) Str += str(node.data) Str += inorder(node.right, m) Str += \")\" # Subtree already present (Note that we use unordered_map instead of unordered_set because we want to print multiple duplicates only once, consider example of 4 in above subtree, it should be printed only once. if (Str in m and m[Str] == 1): print(node.data, end = \" \") if Str in m: m[Str] += 1 else: m[Str] = 1 return Str # Wrapper over inorder() def printAllDups(root): m = {} inorder(root, m) root = None root = newNode(1) root.left = newNode(2) root.right = newNode(3) root.left.left = newNode(4) root.right.left = newNode(2) root.right.left.left = newNode(4) root.right.right = newNode(4) printAllDups(root) Check if 2 trees are mirror or not def checkMirrorTree(M, N, u1, v1, u2, v2): mp = {} # Traverse first tree nodes for i in range(N): if u1[i] in mp: mp[u1[i]].append(v1[i]) else: mp[u1[i]] = [] # Traverse second tree nodes for i in range(N): if u2[i] in mp and len(mp[u2[i]]) \u003e 0: if(mp[u2[i]][-1] != v2[i]): return 0 mp[u2[i]].pop() return 1 M, N = 7, 6 #Tree 1 u1 = [ 1, 1, 1, 10, 10, 10 ] v1 = [ 10, 7, 3, 4, 5, 6 ] #Tree 2 u2 = [ 1, 1, 1, 10, 10, 10 ] v2 = [ 3, 7, 10, 6, 5, 4 ] if(checkMirrorTree(M, N, u1, v1, u2, v2)): print(\"Yes\") else: print(\"No\") Sum of Nodes on the Longest path from root to leaf node \"\"\" Input : Binary tree: 4 / \\ 2 5 / \\ / \\ 7 1 2 3 / 6 Output : 13 4 / \\ 2 5 / \\ / \\ 7 1 2 3 / 6 The highlighted nodes (4, 2, 1, 6) above are part of the longest root to leaf path having sum = (4 + 2 + 1 + 6) = 13 \"\"\" class getNode: def __init__(self, data): self.data = data self.left = self.right = None # function to find the Sum of nodes on the longest path from root to leaf node def SumOfLongRootToLeafPath(root, Sum, Len, maxLen, maxSum): # if true, then we have traversed a root to leaf path if (not root): # update maximum Length and maximum Sum according to the given conditions if (maxLen[0] \u003c Len): maxLen[0] = Len maxSum[0] = Sum elif (maxLen[0]== Len and maxSum[0] \u003c Sum): maxSum[0] = Sum return # recur for left subtree SumOfLongRootToLeafPath(root.left, Sum + root.data, Len + 1, maxLen, maxSum) # recur for right subtree SumOfLongRootToLeafPath(root.right, Sum + root.data, Len + 1, maxLen, maxSum) # utility function to find the Sum of nodes on the longest path from root to leaf node def SumOfLongRootToLeafPathUtil(root): # if tree is NULL, then Sum is 0 if (not root): return 0 maxSum = [-999999999999] maxLen = [0] # finding the maximum Sum 'maxSum' for the maximum Length root to leaf path SumOfLongRootToLeafPath(root, 0, 0, maxLen, maxSum) return maxSum[0] root = getNode(4) root.left = getNode(2) root.right = getNode(5) root.left.left = getNode(7) root.left.right = getNode(1) root.right.left = getNode(2) root.right.right = getNode(3) root.left.right.left = getNode(6) print(\"Sum = \", SumOfLongRootToLeafPathUtil(root)) Check if given graph is tree or not from collections import defaultdict class Graph(): def __init__(self, V): self.V = V self.graph = defaultdict(list) def addEdge(self, v, w): self.graph[v].append(w) self.graph[w].append(v) # A recursive function that uses visited[] and parent to detect cycle in subgraph reachable from vertex v. def isCyclicUtil(self, v, visited, parent): # Mark current node as visited visited[v] = True # Recur for all the vertices adjacent for this vertex for i in self.graph[v]: # If an adjacent is not visited, then recur for that adjacent if visited[i] == False: if self.isCyclicUtil(i, visited, v) == True: return True # If an adjacent is visited and not parent of current vertex, then there is a cycle. elif i != parent: return True return False # Returns true if the graph is a tree, else false. def isTree(self): # Mark all the vertices as not visited and not part of recursion stack visited = [False] * self.V # The call to isCyclicUtil serves multiple purposes. It returns true if graph reachable from vertex 0 is cyclic. # It also marks all vertices reachable from 0. if self.isCyclicUtil(0, visited, -1) == True: return False return all(visited[i] != False for i in range(self.V)) # Driver program to test above functions g1 = Graph(5) g1.addEdge(1, 0) g1.addEdge(0, 2) g1.addEdge(0, 3) g1.addEdge(3, 4) print (\"Graph is a Tree\" if g1.isTree() == True else \"Graph is a not a Tree\") g2 = Graph(5) g2.addEdge(1, 0) g2.addEdge(0, 2) g2.addEdge(2, 1) g2.addEdge(0, 3) g2.addEdge(3, 4) print (\"Graph is a Tree\" if g2.isTree() == True else \"Graph is a not a Tree\") Find Largest subtree sum in a tree # Function to create new tree node. class newNode: def __init__(self, key): self.key = key self.left = self.right = None # Helper function to find largest subtree sum recursively. def findLargestSubtreeSumUtil(root, ans): if (root == None): return 0 # Subtree sum rooted at current node. currSum = (root.key + findLargestSubtreeSumUtil(root.left, ans) + findLargestSubtreeSumUtil(root.right, ans)) # Update answer if current subtree sum is greater than answer so far. ans[0] = max(ans[0], currSum) # Return current subtree sum to its parent node. return currSum # Function to find largest subtree sum. def findLargestSubtreeSum(root): if (root == None): return 0 ans = [float('-inf')] findLargestSubtreeSumUtil(root, ans) return ans[0] # Constructed Tree # 1 # / \\ # / \\ # -2 3 # /\\ /\\ # / \\ / \\ # 4 5 -6 2 root = newNode(1) root.left = newNode(-2) root.right = newNode(3) root.left.left = newNode(4) root.left.right = newNode(5) root.right.left = newNode(-6) root.right.right = newNode(2) print(findLargestSubtreeSum(root)) Maximum Sum of nodes in Binary tree such that no two are adjacent \"\"\" Given a binary tree with a value associated with each node, we need to choose a subset of these nodes such that the sum of selected nodes is maximum under a constraint that no two chosen nodes in the subset should be directly connected, that is, if we have taken a node in our sum then we can’t take any of its children in consideration and vice versa. \"\"\" class newNode: def __init__(self, key): self.data = key self.left = None self.right = None def maxSumHelper(root) : if (root == None): sum = [0, 0] return sum sum1 = maxSumHelper(root.left) sum2 = maxSumHelper(root.right) sum = [0, 0] # This node is included (Left and right children are not included) sum[0] = sum1[1] + sum2[1] + root.data # This node is excluded (Either left or right child is included) sum[1] = (max(sum1[0], sum1[1]) + max(sum2[0], sum2[1])) return sum def maxSum(root) : res = maxSumHelper(root) return max(res[0], res[1]) root = newNode(10) root.left = newNode(1) root.left.left = newNode(2) root.left.left.left = newNode(1) root.left.right = newNode(3) root.left.right.left = newNode(4) root.left.right.right = newNode(5) print(maxSum(root)) Print all “K” Sum paths in a Binary tree \"\"\" A binary tree and a number k are given. Print every path in the tree with sum of the nodes in the path as k. A path can start from any node and end at any node and must be downward only, i.e. they need not be root node and leaf node; and negative numbers can also be there in the tree. \"\"\" def printVector(v, i): for j in range(i, len(v)): print(v[j], end = \" \") print() class newNode: def __init__(self, key): self.data = key self.left = None self.right = None # This function prints all paths that have sum k def printKPathUtil(root, path, k): if (not root) : return # add current node to the path path.append(root.data) # check if there's any k sum path in the left sub-tree. printKPathUtil(root.left, path, k) # check if there's any k sum path in the right sub-tree. printKPathUtil(root.right, path, k) # check if there's any k sum path that terminates at this node # Traverse the entire path as there can be negative elements too f = 0 for j in range(len(path) - 1, -1, -1): f += path[j] # If path sum is k, prthe path if (f == k) : printVector(path, j) # Remove the current element from the path path.pop(-1) # A wrapper over printKPathUtil() def printKPath(root, k): path =[] printKPathUtil(root, path, k) root = newNode(1) root.left = newNode(3) root.left.left = newNode(2) root.left.right = newNode(1) root.left.right.left = newNode(1) root.right = newNode(-1) root.right.left = newNode(4) root.right.left.left = newNode(1) root.right.left.right = newNode(2) root.right.right = newNode(5) root.right.right.right = newNode(2) k = 5 printKPath(root, k) Find Least Common Ancestor in a Binary tree class Node: def __init__(self, key): self.key = key self.left = None self.right = None # This function returns pointer to LCA of two given values n1 and n2 # This function assumes that n1 and n2 are present in Binary Tree def findLCA(root, n1, n2): if root is None: return None # If either n1 or n2 matches with root's key, report the presence by returning root (Note that if a key is # ancestor of other, then the ancestor key becomes LCA if root.key == n1 or root.key == n2: return root # Look for keys in left and right subtrees left_lca = findLCA(root.left, n1, n2) right_lca = findLCA(root.right, n1, n2) # If both of the above calls return Non-NULL, then one key is present in once subtree and other is present in other, # So this node is the LCA if left_lca and right_lca: return root # Otherwise check if left subtree or right subtree is LCA return left_lca if left_lca is not None else right_lca root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) print (\"LCA(4,5) = \", findLCA(root, 4, 5).key) print (\"LCA(4,6) = \", findLCA(root, 4, 6).key) print (\"LCA(3,4) = \", findLCA(root, 3, 4).key) print (\"LCA(2,4) = \", findLCA(root, 2, 4).key) Find distance between 2 nodes in a Binary tree \"\"\" A python program to find distance between n1 and n2 in binary tree \"\"\" class Node: def __init__(self, data): self.data = data self.left = self.right = None # This function returns pointer to LCA of two given values n1 and n2. def find_least_common_ancestor(root, n1, n2): if root is None: return root # If either n1 or n2 matches with root's key, report the presence by returning root if root.data == n1 or root.data == n2: return root # Look for keys in left and right subtrees left = find_least_common_ancestor(root.left, n1, n2) right = find_least_common_ancestor(root.right, n1, n2) if left and right: return root # Otherwise check if left subtree or right subtree is Least Common Ancestor if left: return left else: return right # function to find distance of any node from root def find_distance_from_ancestor_node(root, data): # case when we reach a beyond leaf node or when tree is empty if root is None: return -1 # Node is found then return 0 if root.data == data: return 0 left = find_distance_from_ancestor_node(root.left, data) right = find_distance_from_ancestor_node(root.right, data) distance = max(left, right) return distance+1 if distance \u003e= 0 else -1 # function to find distance between two nodes in a binary tree def find_distance_between_two_nodes(root: Node, n1: int, n2: int): lca = find_least_common_ancestor(root, n1, n2) return find_distance_from_ancestor_node(lca, n1) + find_distance_from_ancestor_node(lca, n2) if lca else -1 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) root.right.left.right = Node(8) print(\"Dist(4,5) = \", find_distance_between_two_nodes(root, 4, 5)) print(\"Dist(4,6) = \", find_distance_between_two_nodes(root, 4, 6)) print(\"Dist(3,4) = \", find_distance_between_two_nodes(root, 3, 4)) print(\"Dist(2,4) = \", find_distance_between_two_nodes(root, 2, 4)) print(\"Dist(8,5) = \", find_distance_between_two_nodes(root, 8, 5)) Kth Ancestor of node in a Binary tree \"\"\" Given a binary tree in which nodes are numbered from 1 to n. Given a node and a positive integer K. We have to print the Kth ancestor of the given node in the binary tree. If there does not exist any such ancestor then print -1. \"\"\" class newNode: def __init__(self, data): self.data = data self.left = None self.right = None # recursive function to calculate Kth ancestor def kthAncestorDFS(root, node, k): if (not root): return None if (root.data == node or (kthAncestorDFS(root.left, node, k)) or (kthAncestorDFS(root.right, node, k))): if (k[0] \u003e 0): k[0] -= 1 elif (k[0] == 0): # print the kth ancestor print(\"Kth ancestor is:\", root.data) # return None to stop further backtracking return None # return current node to previous call return root root = newNode(1) root.left = newNode(2) root.right = newNode(3) root.left.left = newNode(4) root.left.right = newNode(5) k = [2] node = 5 # print kth ancestor of given node parent = kthAncestorDFS(root,node,k) # check if parent is not None, it means there is no Kth ancestor of the node if (parent): print(\"-1\") Find all Duplicate subtrees in a Binary tree # Helper function that allocates a new node with the given data and None left and right pointers. class newNode: def __init__(self, data): self.data = data self.left = self.right = None def inorder(node, m): if (not node): return \"\" Str = \"(\" Str += inorder(node.left, m) Str += str(node.data) Str += inorder(node.right, m) Str += \")\" # Subtree already present (Note that we use unordered_map instead of unordered_set because we want to print # multiple duplicates only once, consider example of 4 in above subtree, it should be printed only once. if (Str in m and m[Str] == 1): print(node.data, end = \" \") if Str in m: m[Str] += 1 else: m[Str] = 1 return Str # Wrapper over inorder() def printAllDups(root): m = {} inorder(root, m) root = None root = newNode(1) root.left = newNode(2) root.right = newNode(3) root.left.left = newNode(4) root.right.left = newNode(2) root.right.left.left = newNode(4) root.right.right = newNode(4) printAllDups(root) Tree Isomorphism Problem \"\"\" Write a function to detect if two trees are isomorphic. Two trees are called isomorphic if one of them can be obtained from other by a series of flips, i.e. by swapping left and right children of a number of nodes. Any number of nodes at any level can have their children swapped. Two empty trees are isomorphic. \"\"\" class Node: def __init__(self, data): self.data = data self.left = None self.right = None # Check if the binary tree is isomorphic or not def isIsomorphic(n1, n2): # Both roots are None, trees isomorphic by definition if n1 is None and n2 is None: return True # Exactly one of the n1 and n2 is None, trees are not isomorphic if n1 is None or n2 is None: return False if n1.data != n2.data : return False # There are two possible cases for n1 and n2 to be isomorphic # Case 1: The subtrees rooted at these nodes have NOT been \"Flipped\". # Both of these subtrees have to be isomorphic, hence the \u0026\u0026 # Case 2: The subtrees rooted at these nodes have been \"Flipped\" return ((isIsomorphic(n1.left, n2.left)and isIsomorphic(n1.right, n2.right)) or (isIsomorphic(n1.left, n2.right) and isIsomorphic(n1.right, n2.left)) ) n1 = Node(1) n1.left = Node(2) n1.right = Node(3) n1.left.left = Node(4) n1.left.right = Node(5) n1.right.left = Node(6) n1.left.right.left = Node(7) n1.left.right.right = Node(8) n2 = Node(1) n2.left = Node(3) n2.right = Node(2) n2.right.left = Node(4) n2.right.right = Node(5) n2.left.right = Node(6) n2.right.right.left = Node(8) n2.right.right.right = Node(7) print (\"Yes\" if (isIsomorphic(n1, n2) == True) else \"No\") ",
  "wordCount" : "6987",
  "inLanguage": "en",
  "image":"https://atharvashah.netlify.app/blog/dsa/binary-tree.jpg","datePublished": "2022-07-08T13:18:34+05:30",
  "dateModified": "2022-07-08T13:18:34+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://atharvashah.netlify.app/blog/dsapython/binary-tree/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Atharva Shah",
    "logo": {
      "@type": "ImageObject",
      "url": "https://atharvashah.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://atharvashah.netlify.app/" accesskey="h" title="Atharva Shah (Alt + H)">
                <img src="https://atharvashah.netlify.app/profile/header_button.gif" alt="" aria-label="logo"
                    height="30">Atharva Shah</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://atharvashah.netlify.app/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://atharvashah.netlify.app/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://atharvashah.netlify.app/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://atharvashah.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://atharvashah.netlify.app/blog/">Blogs</a></div>
    <h1 class="post-title">
      DSA in Python - Binary Trees
    </h1>
    <div class="post-meta"><span title='2022-07-08 13:18:34 +0530 IST'>July 8, 2022</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;6987 words

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://atharvashah.netlify.app/blog/dsa/binary-tree.jpg" alt="Binary Tree">
        <p>Learn Binary Tree Algorithms in Python</p>
</figure>
  <div class="post-content"><ul>
<li><a href="#level-order-traversal-aka-bfs">Level order traversal AKA BFS</a></li>
<li><a href="#reverse-level-order-traversal">Reverse Level Order traversal</a></li>
<li><a href="#height-of-a-tree">Height of a tree</a></li>
<li><a href="#diameter-of-a-tree">Diameter of a tree</a></li>
<li><a href="#mirror-of-a-tree--invert-binary-tree">Mirror of a tree / Invert Binary Tree</a></li>
<li><a href="#inorder-preorder-and-postorder-tree-traversal-recursive-method">Inorder, Preorder and Postorder Tree Traversal (Recursive Method)</a></li>
<li><a href="#left-view-of-a-tree">Left View of a tree</a></li>
<li><a href="#right-view-of-tree">Right View of Tree</a></li>
<li><a href="#top-view-of-a-tree">Top View of a tree</a></li>
<li><a href="#bottom-view-of-a-tree">Bottom View of a tree</a></li>
<li><a href="#zig-zag-traversal-of-a-binary-tree">Zig-Zag traversal of a binary tree</a></li>
<li><a href="#check-if-a-tree-is-balanced-or-not">Check if a tree is balanced or not</a></li>
<li><a href="#diagonal-traversal-of-a-binary-tree">Diagonal Traversal of a Binary tree</a></li>
<li><a href="#boundary-traversal-of-a-binary-tree">Boundary traversal of a Binary tree</a></li>
<li><a href="#construct-binary-tree-from-string-with-bracket-representation">Construct Binary Tree from String with Bracket Representation</a></li>
<li><a href="#convert-binary-tree-into-doubly-linked-list">Convert Binary tree into Doubly Linked List</a></li>
<li><a href="#convert-binary-tree-into-sum-tree">Convert Binary tree into Sum tree</a></li>
<li><a href="#construct-binary-tree-from-inorder-and-preorder-traversal">Construct Binary tree from Inorder and preorder traversal</a></li>
<li><a href="#find-minimum-swaps-required-to-convert-a-binary-tree-into-bst">Find minimum swaps required to convert a Binary tree into BST</a></li>
<li><a href="#check-if-binary-tree-is-sum-tree-or-not">Check if Binary tree is Sum tree or not</a></li>
<li><a href="#check-if-all-leaf-nodes-are-at-same-level-or-not">Check if all leaf nodes are at same level or not</a></li>
<li><a href="#check-if-a-binary-tree-contains-duplicate-subtrees-of-size-2-or-more">Check if a Binary Tree contains duplicate subtrees of size 2 or more</a></li>
<li><a href="#check-if-2-trees-are-mirror-or-not">Check if 2 trees are mirror or not</a></li>
<li><a href="#sum-of-nodes-on-the-longest-path-from-root-to-leaf-node">Sum of Nodes on the Longest path from root to leaf node</a></li>
<li><a href="#check-if-given-graph-is-tree-or-not">Check if given graph is tree or not</a></li>
<li><a href="#find-largest-subtree-sum-in-a-tree">Find Largest subtree sum in a tree</a></li>
<li><a href="#maximum-sum-of-nodes-in-binary-tree-such-that-no-two-are-adjacent">Maximum Sum of nodes in Binary tree such that no two are adjacent</a></li>
<li><a href="#print-all-k-sum-paths-in-a-binary-tree">Print all &ldquo;K&rdquo; Sum paths in a Binary tree</a></li>
<li><a href="#find-least-common-ancestor-in-a-binary-tree">Find Least Common Ancestor in a Binary tree</a></li>
<li><a href="#find-distance-between-2-nodes-in-a-binary-tree">Find distance between 2 nodes in a Binary tree</a></li>
<li><a href="#kth-ancestor-of-node-in-a-binary-tree">Kth Ancestor of node in a Binary tree</a></li>
<li><a href="#find-all-duplicate-subtrees-in-a-binary-tree">Find all Duplicate subtrees in a Binary tree</a></li>
<li><a href="#tree-isomorphism-problem">Tree Isomorphism Problem</a></li>
</ul>
<h2 id="level-order-traversal-aka-bfs">Level order traversal AKA BFS<a hidden class="anchor" aria-hidden="true" href="#level-order-traversal-aka-bfs">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, key):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printLevelOrder</span>(root):
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Base Case</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Create an empty queue for level order traversal</span>
</span></span><span style="display:flex;"><span>  queue <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Enqueue Root and initialize height</span>
</span></span><span style="display:flex;"><span>  queue<span style="color:#f92672">.</span>append(root)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(len(queue) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Print front of queue and remove it from queue</span>
</span></span><span style="display:flex;"><span>    print(queue[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Enqueue left child</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>left <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>      queue<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Enqueue right child</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>right <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>      queue<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Level Order Traversal of binary tree is -&#34;</span>)
</span></span><span style="display:flex;"><span>printLevelOrder(root)
</span></span></code></pre></div><h2 id="reverse-level-order-traversal">Reverse Level Order traversal<a hidden class="anchor" aria-hidden="true" href="#reverse-level-order-traversal">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reverseLevelOrder</span>(root):
</span></span><span style="display:flex;"><span>  q <span style="color:#f92672">=</span> deque()
</span></span><span style="display:flex;"><span>  q<span style="color:#f92672">.</span>append(root)
</span></span><span style="display:flex;"><span>  ans <span style="color:#f92672">=</span> deque()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> q:
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ans<span style="color:#f92672">.</span>appendleft(node<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>      q<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>      q<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ans
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;Level Order traversal of binary tree is&#34;</span>, reverseLevelOrder(root))
</span></span></code></pre></div><h2 id="height-of-a-tree">Height of a tree<a hidden class="anchor" aria-hidden="true" href="#height-of-a-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a binary tree, find height of it. Height of empty tree is -1, height of tree with one node is 0
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Constructor to create a new node</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Compute the &#34;maxDepth&#34; of a tree -- the number of nodes along the longest path from the root node down to the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># farthest leaf node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxDepth</span>(node):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> :
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute the depth of each subtree</span>
</span></span><span style="display:flex;"><span>    lDepth <span style="color:#f92672">=</span> maxDepth(node<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    rDepth <span style="color:#f92672">=</span> maxDepth(node<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Use the larger one</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (lDepth <span style="color:#f92672">&gt;</span> rDepth):
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> lDepth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> rDepth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;Height of tree is </span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span>(maxDepth(root)))
</span></span></code></pre></div><h2 id="diameter-of-a-tree">Diameter of a tree<a hidden class="anchor" aria-hidden="true" href="#diameter-of-a-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">height</span>(node):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Base Case : Tree is empty</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If tree is not empty then height = 1 + max of left</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># height and right heights</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max(height(node<span style="color:#f92672">.</span>left), height(node<span style="color:#f92672">.</span>right))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to get the diameter of a binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">diameter</span>(root):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Base Case when tree is empty</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Get the height of left and right sub-trees</span>
</span></span><span style="display:flex;"><span>  lheight <span style="color:#f92672">=</span> height(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>  rheight <span style="color:#f92672">=</span> height(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Get the diameter of left and right sub-trees</span>
</span></span><span style="display:flex;"><span>  ldiameter <span style="color:#f92672">=</span> diameter(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>  rdiameter <span style="color:#f92672">=</span> diameter(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Return max of the following tree:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># 1) Diameter of left subtree</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># 2) Diameter of right subtree</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># 3) Height of left subtree + height of right subtree +1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> max(lheight <span style="color:#f92672">+</span> rheight <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, max(ldiameter, rdiameter))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Constructed binary tree is
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    2   3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">  4   5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>print(diameter(root))
</span></span></code></pre></div><h2 id="mirror-of-a-tree--invert-binary-tree">Mirror of a tree / Invert Binary Tree<a hidden class="anchor" aria-hidden="true" href="#mirror-of-a-tree--invert-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to perform preorder traversal on a given binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">preorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Utility function to swap left subtree with right subtree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">swap</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    temp <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> temp
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterative function to invert a given binary tree using a queue</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">invertBinaryTree</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case: if the tree is empty</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># maintain a queue and push the root node</span>
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> deque()
</span></span><span style="display:flex;"><span>    q<span style="color:#f92672">.</span>append(root)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># loop till queue is empty</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> q:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># dequeue front node</span>
</span></span><span style="display:flex;"><span>        curr <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># swap the left child with the right child</span>
</span></span><span style="display:flex;"><span>        swap(curr)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># enqueue left child of the popped node</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> curr<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>            q<span style="color:#f92672">.</span>append(curr<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># enqueue right child of the popped node</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> curr<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>            q<span style="color:#f92672">.</span>append(curr<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Construct the following tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       /     </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">      2       3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     / \     / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    4   5   6   7
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>invertBinaryTree(root)
</span></span><span style="display:flex;"><span>preorder(root)
</span></span></code></pre></div><h2 id="inorder-preorder-and-postorder-tree-traversal-recursive-method">Inorder, Preorder and Postorder Tree Traversal (Recursive Method)<a hidden class="anchor" aria-hidden="true" href="#inorder-preorder-and-postorder-tree-traversal-recursive-method">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">preorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">postorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    postorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    postorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; Construct the following tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        /     </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       2       3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      /      /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">     /      /     </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    4      5       6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">         /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        7     8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Preorder: &#34;</span>,preorder(root))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Inorder: &#34;</span>,inorder(root))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;PostOrder: &#34;</span>,postorder(root))
</span></span></code></pre></div><h2 id="left-view-of-a-tree">Left View of a tree<a hidden class="anchor" aria-hidden="true" href="#left-view-of-a-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, key, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">leftView</span>(root, level<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, last_level<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case: empty tree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> last_level
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the current node is the first node of the current level</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> last_level <span style="color:#f92672">&lt;</span> level:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># print the node&#39;s data</span>
</span></span><span style="display:flex;"><span>        print(root<span style="color:#f92672">.</span>key, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># update the last level to the current level</span>
</span></span><span style="display:flex;"><span>        last_level <span style="color:#f92672">=</span> level
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the left and right subtree by increasing the level by 1</span>
</span></span><span style="display:flex;"><span>    last_level <span style="color:#f92672">=</span> leftView(root<span style="color:#f92672">.</span>left, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, last_level)
</span></span><span style="display:flex;"><span>    last_level <span style="color:#f92672">=</span> leftView(root<span style="color:#f92672">.</span>right, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, last_level)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> last_level
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>leftView(root)
</span></span></code></pre></div><h2 id="right-view-of-tree">Right View of Tree<a hidden class="anchor" aria-hidden="true" href="#right-view-of-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, key, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">RightView</span>(root, level<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, lastLevel<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> lastLevel
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the current node is the last node of the current level</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lastLevel <span style="color:#f92672">&lt;</span> level:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># print the node&#39;s data</span>
</span></span><span style="display:flex;"><span>        print(root<span style="color:#f92672">.</span>key, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># update the last level to the current level</span>
</span></span><span style="display:flex;"><span>        lastLevel <span style="color:#f92672">=</span> level
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the right and left subtree by increasing level by 1</span>
</span></span><span style="display:flex;"><span>    lastLevel <span style="color:#f92672">=</span> RightView(root<span style="color:#f92672">.</span>right, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, lastLevel)
</span></span><span style="display:flex;"><span>    lastLevel <span style="color:#f92672">=</span> RightView(root<span style="color:#f92672">.</span>left, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, lastLevel)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lastLevel
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>RightView(root)
</span></span></code></pre></div><h2 id="top-view-of-a-tree">Top View of a tree<a hidden class="anchor" aria-hidden="true" href="#top-view-of-a-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, key<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to perform preorder traversal on the tree and fill the dictionary.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Here, the node has `dist` horizontal distance from the tree&#39;s root, and the level represents the node&#39;s level.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printTop</span>(root, dist, level, d):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the current level is less than the maximum level seen so far for the same horizontal distance, or if </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># the horizontal distance is seen for the first time, update the dictionary</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> dist <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> d <span style="color:#f92672">or</span> level <span style="color:#f92672">&lt;</span> d[dist][<span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># update value and level for current distance</span>
</span></span><span style="display:flex;"><span>        d[dist] <span style="color:#f92672">=</span> (root<span style="color:#f92672">.</span>key, level)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the left subtree by decreasing horizontal distance and increasing level by 1</span>
</span></span><span style="display:flex;"><span>    printTop(root<span style="color:#f92672">.</span>left, dist <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the right subtree by increasing both level and horizontal distance by 1</span>
</span></span><span style="display:flex;"><span>    printTop(root<span style="color:#f92672">.</span>right, dist <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printTopView</span>(root):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create a dictionary where</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># key —&gt; relative horizontal distance of the node from the root node, and</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># value —&gt; pair containing the node&#39;s value and its level</span>
</span></span><span style="display:flex;"><span>    d <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># perform preorder traversal on the tree and fill the dictionary</span>
</span></span><span style="display:flex;"><span>    printTop(root, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># traverse the dictionary in sorted order of keys and print the top view</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> sorted(d<span style="color:#f92672">.</span>keys()):
</span></span><span style="display:flex;"><span>        print(d<span style="color:#f92672">.</span>get(key)[<span style="color:#ae81ff">0</span>], end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>printTopView(root)
</span></span></code></pre></div><h2 id="bottom-view-of-a-tree">Bottom View of a tree<a hidden class="anchor" aria-hidden="true" href="#bottom-view-of-a-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, key<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to perform preorder traversal on the tree and fill the map.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Here, the node has `dist` horizontal distance from the tree&#39;s root, and the `level` represents the node&#39;s level.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printBottom</span>(root, dist, level, d):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case: empty tree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the current level is more than or equal to the maximum level seen so far for the same horizontal distance </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># or horizontal distance is seen for the first time, update the dictionary</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> dist <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> d <span style="color:#f92672">or</span> level <span style="color:#f92672">&gt;=</span> d[dist][<span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># update value and level for the current distance</span>
</span></span><span style="display:flex;"><span>        d[dist] <span style="color:#f92672">=</span> (root<span style="color:#f92672">.</span>key, level)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the left subtree by decreasing horizontal distance and increasing level by 1</span>
</span></span><span style="display:flex;"><span>    printBottom(root<span style="color:#f92672">.</span>left, dist <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the right subtree by increasing both level and horizontal distance by 1</span>
</span></span><span style="display:flex;"><span>    printBottom(root<span style="color:#f92672">.</span>right, dist <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to print the bottom view of a given binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printBottomView</span>(root):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create a dictionary where</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># key —&gt; relative horizontal distance of the node from the root node, and</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># value —&gt; pair containing the node&#39;s value and its level</span>
</span></span><span style="display:flex;"><span>    d <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># perform preorder traversal on the tree and fill the dictionary</span>
</span></span><span style="display:flex;"><span>    printBottom(root, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># traverse the dictionary in sorted order of their keys and print the bottom view</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> sorted(d<span style="color:#f92672">.</span>keys()):
</span></span><span style="display:flex;"><span>        print(d<span style="color:#f92672">.</span>get(key)[<span style="color:#ae81ff">0</span>], end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>printBottomView(root)
</span></span></code></pre></div><h2 id="zig-zag-traversal-of-a-binary-tree">Zig-Zag traversal of a binary tree<a hidden class="anchor" aria-hidden="true" href="#zig-zag-traversal-of-a-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, key<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Traverse the tree in a preorder fashion and store nodes in a dictionary corresponding to their level</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">preorder</span>(root, level, d):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># insert the current node and its level into the dictionary</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the level is odd, insert at the back; otherwise, search at front</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> level <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        d<span style="color:#f92672">.</span>setdefault(level, deque())<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        d<span style="color:#f92672">.</span>setdefault(level, deque())<span style="color:#f92672">.</span>appendleft(root<span style="color:#f92672">.</span>key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the left and right subtree by increasing the level by 1</span>
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>left, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, d)
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>right, level <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to print spiral order traversal of a given binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">SpiralOrderTraversal</span>(root):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create an empty dictionary to store nodes between given levels</span>
</span></span><span style="display:flex;"><span>    d <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># traverse the tree and insert its nodes into the dictionary corresponding to their level</span>
</span></span><span style="display:flex;"><span>    preorder(root, <span style="color:#ae81ff">1</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># iterate through the dictionary and print all nodes present at every level</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(d) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Level </span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">:&#39;</span>, list(d[i]))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">25</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">30</span>)
</span></span><span style="display:flex;"><span>SpiralOrderTraversal(root)
</span></span></code></pre></div><h2 id="check-if-a-tree-is-balanced-or-not">Check if a tree is balanced or not<a hidden class="anchor" aria-hidden="true" href="#check-if-a-tree-is-balanced-or-not">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a binary tree, write an efficient algorithm to check if it is height-balanced or not. In a height-balanced tree, the absolute difference between the height of the left and right subtree for every node is 0 or 1.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, key, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to check if a given binary tree is height-balanced or not</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isHeightBalanced</span>(root, isBalanced<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case: tree is empty or not balanced</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> isBalanced:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, isBalanced
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># get the height of the left subtree</span>
</span></span><span style="display:flex;"><span>    left_height, isBalanced <span style="color:#f92672">=</span> isHeightBalanced(root<span style="color:#f92672">.</span>left, isBalanced)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># get the height of the right subtree</span>
</span></span><span style="display:flex;"><span>    right_height, isBalanced <span style="color:#f92672">=</span> isHeightBalanced(root<span style="color:#f92672">.</span>right, isBalanced)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># tree is unbalanced if the absolute difference between the height of</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># its left and right subtree is more than 1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> abs(left_height <span style="color:#f92672">-</span> right_height) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        isBalanced <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return height of subtree rooted at the current node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> max(left_height, right_height) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, isBalanced
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Construct the following tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       /     </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">      2       3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     / \     /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    4   5   6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> isHeightBalanced(root)[<span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Binary tree is balanced&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Binary tree is not balanced&#39;</span>)
</span></span></code></pre></div><h2 id="diagonal-traversal-of-a-binary-tree">Diagonal Traversal of a Binary tree<a hidden class="anchor" aria-hidden="true" href="#diagonal-traversal-of-a-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to perform preorder traversal on the tree and</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># fill the dictionary with diagonal elements</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printDiagonal</span>(node, diagonal, d):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case: empty tree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># insert the current node into the current diagonal</span>
</span></span><span style="display:flex;"><span>    d<span style="color:#f92672">.</span>setdefault(diagonal, [])<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the left subtree by increasing diagonal by 1</span>
</span></span><span style="display:flex;"><span>    printDiagonal(node<span style="color:#f92672">.</span>left, diagonal <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the right subtree with the same diagonal</span>
</span></span><span style="display:flex;"><span>    printDiagonal(node<span style="color:#f92672">.</span>right, diagonal, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to print the diagonal elements of a given binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printDiagonalElements</span>(root):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create an empty dictionary to store the diagonal element in every slope</span>
</span></span><span style="display:flex;"><span>    d <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># perform preorder traversal on the tree and fill the dictionary</span>
</span></span><span style="display:flex;"><span>    printDiagonal(root, <span style="color:#ae81ff">0</span>, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># traverse the dictionary and print diagonal elements</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(d)):
</span></span><span style="display:flex;"><span>        print(d<span style="color:#f92672">.</span>get(i))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; Construct the following tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        /     </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">      2        3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     /        /  </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    /        /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">   4        5      6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">         /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        7      8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>printDiagonalElements(root)
</span></span></code></pre></div><h2 id="boundary-traversal-of-a-binary-tree">Boundary traversal of a Binary tree<a hidden class="anchor" aria-hidden="true" href="#boundary-traversal-of-a-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isLeaf</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>left <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> self<span style="color:#f92672">.</span>right <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to print the left boundary of the given binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># in a top-down fashion, except for the leaf nodes</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printLeftBoundary</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> node<span style="color:#f92672">.</span>isLeaf():
</span></span><span style="display:flex;"><span>        print(node<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># next process, the left child of `root` if it exists; otherwise, move to the right child</span>
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>left <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>left <span style="color:#66d9ef">else</span> node<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to print the right boundary of the given binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># in a bottom-up fashion, except for the leaf nodes</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printRightBoundary</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">or</span> root<span style="color:#f92672">.</span>isLeaf():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the right child of `root` if it exists; otherwise, recur for the left child</span>
</span></span><span style="display:flex;"><span>    printRightBoundary(root<span style="color:#f92672">.</span>right <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>right <span style="color:#66d9ef">else</span> root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># To ensure bottom-up order, print the value of the nodes after recursion unfolds</span>
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to print the leaf nodes of the given binary tree in an inorder fashion</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printLeafNodes</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    printLeafNodes(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># print only leaf nodes</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>isLeaf():
</span></span><span style="display:flex;"><span>        print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    printLeafNodes(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to perform the boundary traversal on a given tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">performBoundaryTraversal</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># print the root node</span>
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># print the left boundary (except leaf nodes)</span>
</span></span><span style="display:flex;"><span>    printLeftBoundary(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># print all leaf nodes</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>isLeaf():
</span></span><span style="display:flex;"><span>        printLeafNodes(root)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># print the right boundary (except leaf nodes)</span>
</span></span><span style="display:flex;"><span>    printRightBoundary(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">9</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">11</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">13</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">14</span>)
</span></span><span style="display:flex;"><span>performBoundaryTraversal(root)
</span></span></code></pre></div><h2 id="construct-binary-tree-from-string-with-bracket-representation">Construct Binary Tree from String with Bracket Representation<a hidden class="anchor" aria-hidden="true" href="#construct-binary-tree-from-string-with-bracket-representation">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">preOrder</span>(node):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    print(node<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>    preOrder(node<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    preOrder(node<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># function to return the index of close parenthesis</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findIndex</span>(Str, si, ei):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (si <span style="color:#f92672">&gt;</span> ei):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(si, ei <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if open parenthesis, push it</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (Str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>):
</span></span><span style="display:flex;"><span>            s<span style="color:#f92672">.</span>append(Str[i])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> (Str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>):
</span></span><span style="display:flex;"><span>                s<span style="color:#f92672">.</span>pop(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># if stack is empty, this is</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># the required index</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> len(s) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> i
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if not found return -1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># function to conStruct tree from String</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">treeFromString</span>(Str, si, ei):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Base case</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (si <span style="color:#f92672">&gt;</span> ei):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># new root</span>
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> newNode(ord(Str[si]) <span style="color:#f92672">-</span> ord(<span style="color:#e6db74">&#39;0&#39;</span>))
</span></span><span style="display:flex;"><span>    index <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if next char is &#39;(&#39; find the</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># index of its complement &#39;)&#39;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (si <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> ei <span style="color:#f92672">and</span> Str[si <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>):
</span></span><span style="display:flex;"><span>        index <span style="color:#f92672">=</span> findIndex(Str, si <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, ei)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if index found</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># call for left subtree</span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> treeFromString(Str, si <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># call for right subtree</span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> treeFromString(Str, index <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, ei <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;4(2(3)(1))(6(5))&#34;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> treeFromString(Str, <span style="color:#ae81ff">0</span>, len(Str) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>preOrder(root)
</span></span></code></pre></div><h2 id="convert-binary-tree-into-doubly-linked-list">Convert Binary tree into Doubly Linked List<a hidden class="anchor" aria-hidden="true" href="#convert-binary-tree-into-doubly-linked-list">#</a></h2>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>(object):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, item):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> item
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">BTToDLLUtil</span>(root):
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;This is a utility function to convert the binary tree to doubly linked list. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Most of the core task is done by this function.&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Convert left subtree and link to root</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Convert the left subtree</span>
</span></span><span style="display:flex;"><span>        left <span style="color:#f92672">=</span> BTToDLLUtil(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Find inorder predecessor, After this loop, left will point to the</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># inorder predecessor of root</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> left<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>            left <span style="color:#f92672">=</span> left<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Make root as next of predecessor</span>
</span></span><span style="display:flex;"><span>        left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Make predecessor as previous of root</span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Convert the right subtree and link to root</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Convert the right subtree</span>
</span></span><span style="display:flex;"><span>        right <span style="color:#f92672">=</span> BTToDLLUtil(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Find inorder successor, After this loop, right will point to the inorder successor of root</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> right<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>            right <span style="color:#f92672">=</span> right<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Make root as previous of successor</span>
</span></span><span style="display:flex;"><span>        right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Make successor as next of root</span>
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">BTToDLL</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Convert to doubly linked list using BLLToDLLUtil</span>
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> BTToDLLUtil(root)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># We need pointer to left most node which is head of the constructed Doubly Linked list</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> root<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>        root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print_list</span>(head):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> head:
</span></span><span style="display:flex;"><span>        print(head<span style="color:#f92672">.</span>data, end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>        head <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">25</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">30</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">36</span>)
</span></span><span style="display:flex;"><span>head <span style="color:#f92672">=</span> BTToDLL(root)
</span></span><span style="display:flex;"><span>print_list(head)
</span></span></code></pre></div><h2 id="convert-binary-tree-into-sum-tree">Convert Binary tree into Sum tree<a hidden class="anchor" aria-hidden="true" href="#convert-binary-tree-into-sum-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Given a Binary Tree where each node has positive and negative values. Convert this to a tree where each node contains the sum of the left and right sub trees in the original tree. The values of leaf nodes are changed to 0.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Convert a given tree to a tree where every node contains sum of values of</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># nodes in left and right subtrees in the original tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">toSumTree</span>(Node) :
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> Node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Store the old value</span>
</span></span><span style="display:flex;"><span>    old_val <span style="color:#f92672">=</span> Node<span style="color:#f92672">.</span>data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Recursively call for left and right subtrees and store the sum as new value of this node</span>
</span></span><span style="display:flex;"><span>    Node<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> toSumTree(Node<span style="color:#f92672">.</span>left) <span style="color:#f92672">+</span> toSumTree(Node<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Return the sum of values of nodes in left and right subtrees and old_value of this node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Node<span style="color:#f92672">.</span>data <span style="color:#f92672">+</span> old_val
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function to print inorder traversal of a Binary Tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printInorder</span>(Node):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> Node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    printInorder(Node<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    print(Node<span style="color:#f92672">.</span>data, end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>    printInorder(Node<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Utility function to create a new Binary Tree node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">newNode</span>(data) :
</span></span><span style="display:flex;"><span>    temp <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    temp<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>    temp<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    temp<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>toSumTree(root)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Inorder Traversal of the resultant tree is: &#34;</span>)
</span></span><span style="display:flex;"><span>printInorder(root)
</span></span></code></pre></div><h2 id="construct-binary-tree-from-inorder-and-preorder-traversal">Construct Binary tree from Inorder and preorder traversal<a hidden class="anchor" aria-hidden="true" href="#construct-binary-tree-from-inorder-and-preorder-traversal">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># A class to store a binary tree node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Constructor</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to perform inorder traversal on a given binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorderTraversal</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    inorderTraversal(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    inorderTraversal(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to perform postorder traversal on a given binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">preorderTraversal</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    preorderTraversal(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    preorderTraversal(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to construct a binary tree from a given inorder and preorder sequence</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">construct</span>(start, end, preorder, pIndex, d):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> start <span style="color:#f92672">&gt;</span> end:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>, pIndex
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># The next element in `preorder[]` will be the root node of subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># formed by sequence represented by `inorder[start, end]`</span>
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> Node(preorder[pIndex])
</span></span><span style="display:flex;"><span>    pIndex <span style="color:#f92672">=</span> pIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># get the index of the root node in inorder to determine the</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># left and right subtree boundary</span>
</span></span><span style="display:flex;"><span>    index <span style="color:#f92672">=</span> d[root<span style="color:#f92672">.</span>data]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively construct the left subtree</span>
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>left, pIndex <span style="color:#f92672">=</span> construct(start, index <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, preorder, pIndex, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively construct the right subtree</span>
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>right, pIndex <span style="color:#f92672">=</span> construct(index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, end, preorder, pIndex, d)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return current node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root, pIndex
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Construct a binary tree from inorder and preorder traversals.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This function assumes that the input is valid i.e., given inorder and preorder sequence forms a binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">constructTree</span>(inorder, preorder):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create a dictionary to efficiently find the index of any element in a given inorder sequence</span>
</span></span><span style="display:flex;"><span>    d <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i, e <span style="color:#f92672">in</span> enumerate(inorder):
</span></span><span style="display:flex;"><span>        d[e] <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># `pIndex` stores the index of the next unprocessed node in a preorder sequence;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># start with the root node (present at 0th index)</span>
</span></span><span style="display:flex;"><span>    pIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> construct(<span style="color:#ae81ff">0</span>, len(inorder) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, preorder, pIndex, d)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; Construct the following tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        /     </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       2       3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      /       / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">     /       /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    4       5     6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">          /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">         7     8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>inorder <span style="color:#f92672">=</span> [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>preorder <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> constructTree(inorder, preorder)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;The inorder traversal is &#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>inorderTraversal(root)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">The preorder traversal is &#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>preorderTraversal(root)
</span></span></code></pre></div><h2 id="find-minimum-swaps-required-to-convert-a-binary-tree-into-bst">Find minimum swaps required to convert a Binary tree into BST<a hidden class="anchor" aria-hidden="true" href="#find-minimum-swaps-required-to-convert-a-binary-tree-into-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The idea is to use the fact that inorder traversal of Binary Search Tree is in increasing order of their value. So, find the inorder traversal of the Binary Tree and store it in the array and try to sort the array. The minimum number of swap required to get the array sorted will be the answer.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder</span>(a, n, index):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> v
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If index is greater or equal to vector size</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&gt;=</span> n):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    inorder(a, n, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> index <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Push elements in vector</span>
</span></span><span style="display:flex;"><span>    v<span style="color:#f92672">.</span>append(a[index])
</span></span><span style="display:flex;"><span>    inorder(a, n, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> index <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minSwaps</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">global</span> v
</span></span><span style="display:flex;"><span>    t <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(len(v))]
</span></span><span style="display:flex;"><span>    ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(v)):
</span></span><span style="display:flex;"><span>        t[i][<span style="color:#ae81ff">0</span>], t[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> v[i], i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    t, i <span style="color:#f92672">=</span> sorted(t), <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> len(t):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> t[i][<span style="color:#ae81ff">1</span>]):
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Swapping of elements</span>
</span></span><span style="display:flex;"><span>            t[i][<span style="color:#ae81ff">0</span>], t[t[i][<span style="color:#ae81ff">1</span>]][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> t[t[i][<span style="color:#ae81ff">1</span>]][<span style="color:#ae81ff">0</span>], t[i][<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>            t[i][<span style="color:#ae81ff">1</span>], t[t[i][<span style="color:#ae81ff">1</span>]][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> t[t[i][<span style="color:#ae81ff">1</span>]][<span style="color:#ae81ff">1</span>], t[i][<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Second is not equal to i</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> t[i][<span style="color:#ae81ff">1</span>]):
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>v <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>]
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> len(a)
</span></span><span style="display:flex;"><span>inorder(a, n, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>print(minSwaps())
</span></span></code></pre></div><h2 id="check-if-binary-tree-is-sum-tree-or-not">Check if Binary tree is Sum tree or not<a hidden class="anchor" aria-hidden="true" href="#check-if-binary-tree-is-sum-tree-or-not">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">node</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, x):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> x
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isLeaf</span>(node):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>left <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> node<span style="color:#f92672">.</span>right <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># returns data if SumTree property holds for the given tree else return -1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isSumTree</span>(node):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  ls <span style="color:#f92672">=</span> isSumTree(node<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#To stop for further traversal of tree if found not sumTree</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ls <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):     
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  rs <span style="color:#f92672">=</span> isSumTree(node<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#To stop for further traversal of tree if found not sumTree</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(rs <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):     
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ls <span style="color:#f92672">+</span> rs <span style="color:#f92672">+</span> node<span style="color:#f92672">.</span>data <span style="color:#66d9ef">if</span> (isLeaf(node) <span style="color:#f92672">or</span> ls <span style="color:#f92672">+</span> rs <span style="color:#f92672">==</span> node<span style="color:#f92672">.</span>data) <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">26</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(isSumTree(root)):
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;The given tree is a SumTree &#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;The given tree is not a SumTree &#34;</span>)
</span></span></code></pre></div><h2 id="check-if-all-leaf-nodes-are-at-same-level-or-not">Check if all leaf nodes are at same level or not<a hidden class="anchor" aria-hidden="true" href="#check-if-all-leaf-nodes-are-at-same-level-or-not">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function which check whether all leaves are at same level</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">checkUtil</span>(root, level):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If a tree node is encountered</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>left <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># When a leaf node is found first time</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> check<span style="color:#f92672">.</span>leafLevel <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> :
</span></span><span style="display:flex;"><span>      check<span style="color:#f92672">.</span>leafLevel <span style="color:#f92672">=</span> level <span style="color:#75715e"># Set first leaf found</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If this is not first leaf node, compare its level  with first leaf&#39;s level</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> level <span style="color:#f92672">==</span> check<span style="color:#f92672">.</span>leafLevel
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If this is not first leaf node, compare its level with first leaf&#39;s level</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (checkUtil(root<span style="color:#f92672">.</span>left, level<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>      checkUtil(root<span style="color:#f92672">.</span>right, level<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">check</span>(root):
</span></span><span style="display:flex;"><span>  level <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  check<span style="color:#f92672">.</span>leafLevel <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (checkUtil(root, level))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">9</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(check(root)):
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Leaves are at same level&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>  print(<span style="color:#e6db74">&#34;Leaves are not at same level&#34;</span>)
</span></span></code></pre></div><h2 id="check-if-a-binary-tree-contains-duplicate-subtrees-of-size-2-or-more">Check if a Binary Tree contains duplicate subtrees of size 2 or more<a hidden class="anchor" aria-hidden="true" href="#check-if-a-binary-tree-contains-duplicate-subtrees-of-size-2-or-more">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Helper function that allocates a new node with the given data and None left and right pointers.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder</span>(node, m):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span> node):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(&#34;</span>
</span></span><span style="display:flex;"><span>  Str <span style="color:#f92672">+=</span> inorder(node<span style="color:#f92672">.</span>left, m)
</span></span><span style="display:flex;"><span>  Str <span style="color:#f92672">+=</span> str(node<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>  Str <span style="color:#f92672">+=</span> inorder(node<span style="color:#f92672">.</span>right, m)
</span></span><span style="display:flex;"><span>  Str <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;)&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Subtree already present (Note that we use unordered_map instead of unordered_set because we want to print multiple duplicates only once, consider example of 4 in above subtree, it should be printed only once.</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (Str <span style="color:#f92672">in</span> m <span style="color:#f92672">and</span> m[Str] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    print(node<span style="color:#f92672">.</span>data, end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> Str <span style="color:#f92672">in</span> m:
</span></span><span style="display:flex;"><span>    m[Str] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    m[Str] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Str
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Wrapper over inorder()</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printAllDups</span>(root):
</span></span><span style="display:flex;"><span>  m <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>  inorder(root, m)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>printAllDups(root)
</span></span></code></pre></div><h2 id="check-if-2-trees-are-mirror-or-not">Check if 2 trees are mirror or not<a hidden class="anchor" aria-hidden="true" href="#check-if-2-trees-are-mirror-or-not">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">checkMirrorTree</span>(M, N, u1, v1, u2, v2):
</span></span><span style="display:flex;"><span>  mp <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Traverse first tree nodes</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> u1[i] <span style="color:#f92672">in</span> mp:
</span></span><span style="display:flex;"><span>      mp[u1[i]]<span style="color:#f92672">.</span>append(v1[i])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>      mp[u1[i]] <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Traverse second tree nodes</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> u2[i] <span style="color:#f92672">in</span> mp <span style="color:#f92672">and</span> len(mp[u2[i]]) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(mp[u2[i]][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> v2[i]):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>      mp[u2[i]]<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>M, N <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Tree 1</span>
</span></span><span style="display:flex;"><span>u1 <span style="color:#f92672">=</span> [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span> ]
</span></span><span style="display:flex;"><span>v1 <span style="color:#f92672">=</span> [ <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span> ]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Tree 2</span>
</span></span><span style="display:flex;"><span>u2 <span style="color:#f92672">=</span> [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">10</span> ]
</span></span><span style="display:flex;"><span>v2 <span style="color:#f92672">=</span> [ <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span> ]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(checkMirrorTree(M, N, u1, v1, u2, v2)):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Yes&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span></code></pre></div><h2 id="sum-of-nodes-on-the-longest-path-from-root-to-leaf-node">Sum of Nodes on the Longest path from root to leaf node<a hidden class="anchor" aria-hidden="true" href="#sum-of-nodes-on-the-longest-path-from-root-to-leaf-node">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input : Binary tree:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        4        
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       / \       
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      2   5      
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     / \ / \     
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    7  1 2  3    
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : 13
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        4        
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       / \       
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      2   5      
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     / \ / \     
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    7  1 2  3 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The highlighted nodes (4, 2, 1, 6) above are 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">part of the longest root to leaf path having
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">sum = (4 + 2 + 1 + 6) = 13
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">getNode</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># function to find the Sum of nodes on the longest path from root to leaf node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">SumOfLongRootToLeafPath</span>(root, Sum, Len, maxLen, maxSum):
</span></span><span style="display:flex;"><span>                    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if true, then we have traversed a root to leaf path</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span> root):
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># update maximum Length and maximum Sum according to the given conditions</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (maxLen[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> Len):
</span></span><span style="display:flex;"><span>            maxLen[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> Len
</span></span><span style="display:flex;"><span>            maxSum[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> Sum
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> (maxLen[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">==</span> Len <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>            maxSum[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> Sum):
</span></span><span style="display:flex;"><span>            maxSum[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> Sum
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for left subtree</span>
</span></span><span style="display:flex;"><span>    SumOfLongRootToLeafPath(root<span style="color:#f92672">.</span>left, Sum <span style="color:#f92672">+</span> root<span style="color:#f92672">.</span>data, Len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, maxLen, maxSum)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for right subtree</span>
</span></span><span style="display:flex;"><span>    SumOfLongRootToLeafPath(root<span style="color:#f92672">.</span>right, Sum <span style="color:#f92672">+</span> root<span style="color:#f92672">.</span>data, Len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, maxLen, maxSum)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># utility function to find the Sum of nodes on the longest path from root to leaf node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">SumOfLongRootToLeafPathUtil</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if tree is NULL, then Sum is 0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span> root):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    maxSum <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">999999999999</span>]
</span></span><span style="display:flex;"><span>    maxLen <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># finding the maximum Sum &#39;maxSum&#39; for the maximum Length root to leaf path</span>
</span></span><span style="display:flex;"><span>    SumOfLongRootToLeafPath(root, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, maxLen, maxSum)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> maxSum[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> getNode(<span style="color:#ae81ff">4</span>)       
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> getNode(<span style="color:#ae81ff">2</span>)   
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> getNode(<span style="color:#ae81ff">5</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> getNode(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> getNode(<span style="color:#ae81ff">1</span>) 
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> getNode(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> getNode(<span style="color:#ae81ff">3</span>) 
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> getNode(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Sum = &#34;</span>, SumOfLongRootToLeafPathUtil(root))
</span></span></code></pre></div><h2 id="check-if-given-graph-is-tree-or-not">Check if given graph is tree or not<a hidden class="anchor" aria-hidden="true" href="#check-if-given-graph-is-tree-or-not">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Graph</span>():
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> __init__(self, V):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>V <span style="color:#f92672">=</span> V
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> defaultdict(list)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addEdge</span>(self, v, w):
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>graph[v]<span style="color:#f92672">.</span>append(w)
</span></span><span style="display:flex;"><span>    self<span style="color:#f92672">.</span>graph[w]<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># A recursive function that uses visited[] and parent to detect cycle in subgraph reachable from vertex v.</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isCyclicUtil</span>(self, v, visited, parent):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Mark current node as visited</span>
</span></span><span style="display:flex;"><span>    visited[v] <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Recur for all the vertices adjacent for this vertex</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[v]:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># If an adjacent is not visited, then recur for that adjacent</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> visited[i] <span style="color:#f92672">==</span> <span style="color:#66d9ef">False</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>isCyclicUtil(i, visited, v) <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># If an adjacent is visited and not parent of current vertex, then there is a cycle.</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">elif</span> i <span style="color:#f92672">!=</span> parent:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Returns true if the graph is a tree, else false.</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isTree</span>(self):
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Mark all the vertices as not visited and not part of recursion stack</span>
</span></span><span style="display:flex;"><span>    visited <span style="color:#f92672">=</span> [<span style="color:#66d9ef">False</span>] <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>V
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># The call to isCyclicUtil serves multiple purposes. It returns true if graph reachable from vertex 0 is cyclic. </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># It also marks all vertices reachable from 0.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>isCyclicUtil(<span style="color:#ae81ff">0</span>, visited, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> all(visited[i] <span style="color:#f92672">!=</span> <span style="color:#66d9ef">False</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>V))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Driver program to test above functions</span>
</span></span><span style="display:flex;"><span>g1 <span style="color:#f92672">=</span> Graph(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>g1<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;Graph is a Tree&#34;</span> <span style="color:#66d9ef">if</span> g1<span style="color:#f92672">.</span>isTree() <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;Graph is a not a Tree&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>g2 <span style="color:#f92672">=</span> Graph(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>g2<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>g2<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g2<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>g2<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>g2<span style="color:#f92672">.</span>addEdge(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;Graph is a Tree&#34;</span> <span style="color:#66d9ef">if</span> g2<span style="color:#f92672">.</span>isTree() <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span> <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;Graph is a not a Tree&#34;</span>)
</span></span></code></pre></div><h2 id="find-largest-subtree-sum-in-a-tree">Find Largest subtree sum in a tree<a hidden class="anchor" aria-hidden="true" href="#find-largest-subtree-sum-in-a-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Function to create new tree node.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, key):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Helper function to find largest subtree sum recursively.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findLargestSubtreeSumUtil</span>(root, ans):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Subtree sum rooted at current node.</span>
</span></span><span style="display:flex;"><span> currSum <span style="color:#f92672">=</span> (root<span style="color:#f92672">.</span>key <span style="color:#f92672">+</span> findLargestSubtreeSumUtil(root<span style="color:#f92672">.</span>left, ans) <span style="color:#f92672">+</span> findLargestSubtreeSumUtil(root<span style="color:#f92672">.</span>right, ans))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Update answer if current subtree sum is greater than answer so far.</span>
</span></span><span style="display:flex;"><span> ans[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> max(ans[<span style="color:#ae81ff">0</span>], currSum)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Return current subtree sum to its parent node.</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> currSum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find largest subtree sum.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findLargestSubtreeSum</span>(root):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">None</span>): 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> ans <span style="color:#f92672">=</span> [float(<span style="color:#e6db74">&#39;-inf&#39;</span>)]
</span></span><span style="display:flex;"><span> findLargestSubtreeSumUtil(root, ans)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> ans[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Constructed Tree</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    / \</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#      /  \</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     -2   3</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     /\   /\</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#    / \    / \</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#      4  5  -6  2</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#f92672">-</span><span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>print(findLargestSubtreeSum(root))
</span></span></code></pre></div><h2 id="maximum-sum-of-nodes-in-binary-tree-such-that-no-two-are-adjacent">Maximum Sum of nodes in Binary tree such that no two are adjacent<a hidden class="anchor" aria-hidden="true" href="#maximum-sum-of-nodes-in-binary-tree-such-that-no-two-are-adjacent">#</a></h2>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a binary tree with a value associated with each node, we need to choose a subset of these nodes such that the sum of 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">selected nodes is maximum under a constraint that no two chosen nodes in the subset should be directly connected, that is, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">if we have taken a node in our sum then we can’t take any of its children in consideration and vice versa. 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, key):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxSumHelper</span>(root) :
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>  sum <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> sum
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> sum1 <span style="color:#f92672">=</span> maxSumHelper(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span> sum2 <span style="color:#f92672">=</span> maxSumHelper(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> sum <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># This node is included (Left and right children are not included)</span>
</span></span><span style="display:flex;"><span> sum[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> sum1[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> sum2[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> root<span style="color:#f92672">.</span>data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># This node is excluded (Either left or right child is included)</span>
</span></span><span style="display:flex;"><span> sum[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> (max(sum1[<span style="color:#ae81ff">0</span>], sum1[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> max(sum2[<span style="color:#ae81ff">0</span>], sum2[<span style="color:#ae81ff">1</span>]))
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> sum
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxSum</span>(root) :
</span></span><span style="display:flex;"><span> res <span style="color:#f92672">=</span> maxSumHelper(root)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> max(res[<span style="color:#ae81ff">0</span>], res[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>print(maxSum(root))
</span></span></code></pre></div><h2 id="print-all-k-sum-paths-in-a-binary-tree">Print all &ldquo;K&rdquo; Sum paths in a Binary tree<a hidden class="anchor" aria-hidden="true" href="#print-all-k-sum-paths-in-a-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">A binary tree and a number k are given. Print every path in the tree with sum of the nodes in the path as k.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">A path can start from any node and end at any node and must be downward only,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">i.e. they need not be root node and leaf node; and negative numbers can also be there in the tree.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printVector</span>(v, i):  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i, len(v)): 
</span></span><span style="display:flex;"><span>        print(v[j], end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>) 
</span></span><span style="display:flex;"><span>    print() 
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, key):  
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> key 
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This function prints all paths   that have sum k  </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printKPathUtil</span>(root, path, k):  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span> root) : 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># add current node to the path  </span>
</span></span><span style="display:flex;"><span>    path<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>data)  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># check if there&#39;s any k sum path in the left sub-tree.  </span>
</span></span><span style="display:flex;"><span>    printKPathUtil(root<span style="color:#f92672">.</span>left, path, k)  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># check if there&#39;s any k sum path in the right sub-tree.  </span>
</span></span><span style="display:flex;"><span>    printKPathUtil(root<span style="color:#f92672">.</span>right, path, k)  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># check if there&#39;s any k sum path that terminates at this node  </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Traverse the entire path as there can be negative elements too  </span>
</span></span><span style="display:flex;"><span>    f <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(path) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):      
</span></span><span style="display:flex;"><span>        f <span style="color:#f92672">+=</span> path[j]  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># If path sum is k, prthe path  </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (f <span style="color:#f92672">==</span> k) : 
</span></span><span style="display:flex;"><span>            printVector(path, j)  
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Remove the current element from the path  </span>
</span></span><span style="display:flex;"><span>    path<span style="color:#f92672">.</span>pop(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A wrapper over printKPathUtil()  </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printKPath</span>(root, k): 
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span>[] 
</span></span><span style="display:flex;"><span>    printKPathUtil(root, path, k)  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">3</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">5</span>)  
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)  
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>printKPath(root, k)
</span></span></code></pre></div><h2 id="find-least-common-ancestor-in-a-binary-tree">Find Least Common Ancestor in a Binary tree<a hidden class="anchor" aria-hidden="true" href="#find-least-common-ancestor-in-a-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, key):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This function returns pointer to LCA of two given values n1 and n2</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This function assumes that n1 and n2 are present in Binary Tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findLCA</span>(root, n1, n2):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># If either n1 or n2 matches with root&#39;s key, report the presence by returning root (Note that if a key is</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># ancestor of other, then the ancestor key becomes LCA</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>key <span style="color:#f92672">==</span> n1 <span style="color:#f92672">or</span> root<span style="color:#f92672">.</span>key <span style="color:#f92672">==</span> n2:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Look for keys in left and right subtrees</span>
</span></span><span style="display:flex;"><span> left_lca <span style="color:#f92672">=</span> findLCA(root<span style="color:#f92672">.</span>left, n1, n2)
</span></span><span style="display:flex;"><span> right_lca <span style="color:#f92672">=</span> findLCA(root<span style="color:#f92672">.</span>right, n1, n2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># If both of the above calls return Non-NULL, then one key is present in once subtree and other is present in other, </span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># So this node is the LCA</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> left_lca <span style="color:#f92672">and</span> right_lca:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Otherwise check if left subtree or right subtree is LCA</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> left_lca <span style="color:#66d9ef">if</span> left_lca <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span> <span style="color:#66d9ef">else</span> right_lca
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;LCA(4,5) = &#34;</span>, findLCA(root, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)<span style="color:#f92672">.</span>key)
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;LCA(4,6) = &#34;</span>, findLCA(root, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>)<span style="color:#f92672">.</span>key)
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;LCA(3,4) = &#34;</span>, findLCA(root, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)<span style="color:#f92672">.</span>key)
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;LCA(2,4) = &#34;</span>, findLCA(root, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>)<span style="color:#f92672">.</span>key)
</span></span></code></pre></div><h2 id="find-distance-between-2-nodes-in-a-binary-tree">Find distance between 2 nodes in a Binary tree<a hidden class="anchor" aria-hidden="true" href="#find-distance-between-2-nodes-in-a-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">A python program to find distance between n1 and n2 in binary tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This function returns pointer to LCA of two given values n1 and n2.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_least_common_ancestor</span>(root, n1, n2):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># If either n1 or n2 matches with root&#39;s key, report the presence by returning root</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">==</span> n1 <span style="color:#f92672">or</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">==</span> n2:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Look for keys in left and right subtrees</span>
</span></span><span style="display:flex;"><span> left <span style="color:#f92672">=</span> find_least_common_ancestor(root<span style="color:#f92672">.</span>left, n1, n2)
</span></span><span style="display:flex;"><span> right <span style="color:#f92672">=</span> find_least_common_ancestor(root<span style="color:#f92672">.</span>right, n1, n2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> left <span style="color:#f92672">and</span> right:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Otherwise check if left subtree or right subtree is Least Common Ancestor</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> left:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> left
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># function to find distance of any node from root</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_distance_from_ancestor_node</span>(root, data):
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># case when we reach a beyond leaf node or when tree is empty</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Node is found then return 0</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">==</span> data:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> left <span style="color:#f92672">=</span> find_distance_from_ancestor_node(root<span style="color:#f92672">.</span>left, data)
</span></span><span style="display:flex;"><span> right <span style="color:#f92672">=</span> find_distance_from_ancestor_node(root<span style="color:#f92672">.</span>right, data)
</span></span><span style="display:flex;"><span> distance <span style="color:#f92672">=</span> max(left, right)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> distance<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> distance <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># function to find distance between two nodes in a binary tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_distance_between_two_nodes</span>(root: Node, n1: int, n2: int):
</span></span><span style="display:flex;"><span> lca <span style="color:#f92672">=</span> find_least_common_ancestor(root, n1, n2)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> find_distance_from_ancestor_node(lca, n1) <span style="color:#f92672">+</span> find_distance_from_ancestor_node(lca, n2) <span style="color:#66d9ef">if</span> lca <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Dist(4,5) = &#34;</span>, find_distance_between_two_nodes(root, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Dist(4,6) = &#34;</span>, find_distance_between_two_nodes(root, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Dist(3,4) = &#34;</span>, find_distance_between_two_nodes(root, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Dist(2,4) = &#34;</span>, find_distance_between_two_nodes(root, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Dist(8,5) = &#34;</span>, find_distance_between_two_nodes(root, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">5</span>))
</span></span></code></pre></div><h2 id="kth-ancestor-of-node-in-a-binary-tree">Kth Ancestor of node in a Binary tree<a hidden class="anchor" aria-hidden="true" href="#kth-ancestor-of-node-in-a-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a binary tree in which nodes are numbered from 1 to n. Given a node and a positive integer K.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">We have to print the Kth ancestor of the given node in the binary tree.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">If there does not exist any such ancestor then print -1.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># recursive function to calculate Kth ancestor</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kthAncestorDFS</span>(root, node, k):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span> root):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">.</span>data <span style="color:#f92672">==</span> node <span style="color:#f92672">or</span>
</span></span><span style="display:flex;"><span>       (kthAncestorDFS(root<span style="color:#f92672">.</span>left, node, k)) <span style="color:#f92672">or</span>
</span></span><span style="display:flex;"><span>       (kthAncestorDFS(root<span style="color:#f92672">.</span>right, node, k))):
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (k[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>            k[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>         
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> (k[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>             
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># print the kth ancestor</span>
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;Kth ancestor is:&#34;</span>, root<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>             
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># return None to stop further backtracking</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>             
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># return current node to previous call</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>node <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># print kth ancestor of given node</span>
</span></span><span style="display:flex;"><span>parent <span style="color:#f92672">=</span> kthAncestorDFS(root,node,k)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># check if parent is not None, it means there is no Kth ancestor of the node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (parent):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;-1&#34;</span>)
</span></span></code></pre></div><h2 id="find-all-duplicate-subtrees-in-a-binary-tree">Find all Duplicate subtrees in a Binary tree<a hidden class="anchor" aria-hidden="true" href="#find-all-duplicate-subtrees-in-a-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Helper function that allocates a new node with the given data and None left and right pointers.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder</span>(node, m):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">not</span> node):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> Str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;(&#34;</span>
</span></span><span style="display:flex;"><span> Str <span style="color:#f92672">+=</span> inorder(node<span style="color:#f92672">.</span>left, m)
</span></span><span style="display:flex;"><span> Str <span style="color:#f92672">+=</span> str(node<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span> Str <span style="color:#f92672">+=</span> inorder(node<span style="color:#f92672">.</span>right, m)
</span></span><span style="display:flex;"><span> Str <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;)&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Subtree already present (Note that we use unordered_map instead of unordered_set because we want to print</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># multiple duplicates only once, consider example of 4 in above subtree, it should be printed only once.</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (Str <span style="color:#f92672">in</span> m <span style="color:#f92672">and</span> m[Str] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>  print(node<span style="color:#f92672">.</span>data, end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> Str <span style="color:#f92672">in</span> m:
</span></span><span style="display:flex;"><span>  m[Str] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>  m[Str] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> Str
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Wrapper over inorder()</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printAllDups</span>(root):
</span></span><span style="display:flex;"><span> m <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span> inorder(root, m)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>printAllDups(root)
</span></span></code></pre></div><h2 id="tree-isomorphism-problem">Tree Isomorphism Problem<a hidden class="anchor" aria-hidden="true" href="#tree-isomorphism-problem">#</a></h2>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Write a function to detect if two trees are isomorphic. Two trees are called isomorphic if one of them can be obtained from 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">other by a series of flips, i.e. by swapping left and right children of a number of nodes.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Any number of nodes at any level can have their children swapped. Two empty trees are isomorphic.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Check if the binary tree is isomorphic or not</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isIsomorphic</span>(n1, n2):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Both roots are None, trees isomorphic by definition</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> n1 <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> n2 <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Exactly one of the n1 and n2 is None, trees are not isomorphic</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> n1 <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">or</span> n2 <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> n1<span style="color:#f92672">.</span>data <span style="color:#f92672">!=</span> n2<span style="color:#f92672">.</span>data :
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># There are two possible cases for n1 and n2 to be isomorphic</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Case 1: The subtrees rooted at these nodes have NOT been &#34;Flipped&#34;. </span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e"># Both of these subtrees have to be isomorphic, hence the &amp;&amp;</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Case 2: The subtrees rooted at these nodes have been &#34;Flipped&#34;</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> ((isIsomorphic(n1<span style="color:#f92672">.</span>left, n2<span style="color:#f92672">.</span>left)<span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>   isIsomorphic(n1<span style="color:#f92672">.</span>right, n2<span style="color:#f92672">.</span>right)) <span style="color:#f92672">or</span>
</span></span><span style="display:flex;"><span>   (isIsomorphic(n1<span style="color:#f92672">.</span>left, n2<span style="color:#f92672">.</span>right) <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>   isIsomorphic(n1<span style="color:#f92672">.</span>right, n2<span style="color:#f92672">.</span>left))
</span></span><span style="display:flex;"><span>   )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n1 <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>n1<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>n1<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>n1<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>n1<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>n1<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>n1<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>n1<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n2 <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>n2<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>n2<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>n2<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>n2<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>n2<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>n2<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>n2<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print (<span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#66d9ef">if</span> (isIsomorphic(n1, n2) <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>) <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#34;No&#34;</span>)
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://atharvashah.netlify.app/tags/dsa-python/">DSA-Python</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://atharvashah.netlify.app/blog/dsapython/binary-search-tree/">
    <span class="title">« Prev</span>
    <br>
    <span>DSA in Python - Binary Search Trees</span>
  </a>
  <a class="next" href="https://atharvashah.netlify.app/blog/dsapython/trie/">
    <span class="title">Next »</span>
    <br>
    <span>DSA in Python - Trie</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Trees on twitter"
        href="https://twitter.com/intent/tweet/?text=DSA%20in%20Python%20-%20Binary%20Trees&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-tree%2f&amp;hashtags=DSA-Python">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Trees on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-tree%2f&amp;title=DSA%20in%20Python%20-%20Binary%20Trees&amp;summary=DSA%20in%20Python%20-%20Binary%20Trees&amp;source=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-tree%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Trees on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-tree%2f&title=DSA%20in%20Python%20-%20Binary%20Trees">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Trees on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-tree%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Trees on whatsapp"
        href="https://api.whatsapp.com/send?text=DSA%20in%20Python%20-%20Binary%20Trees%20-%20https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-tree%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Trees on telegram"
        href="https://telegram.me/share/url?text=DSA%20in%20Python%20-%20Binary%20Trees&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-tree%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-atharvashah-netlify-app" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    (function() {
        
        
        if (window.location.hostname == "localhost")
            return;

        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        var disqus_shortname = 'https-atharvashah-netlify-app';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://atharvashah.netlify.app/">Atharva Shah</a></span> 
    | <span><a href="/privacy-policy/" target="_blank">Privacy Policy</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function() {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function(e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function() {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {};
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
