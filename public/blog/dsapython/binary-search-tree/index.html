<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DSA in Python - Binary Search Trees | Atharva Shah</title>
<meta name="keywords" content="DSA-Python">
<meta name="description" content="Find a value in a BST Deletion of a node in a BST Find min and max value in a BST Find inorder successor and inorder predecessor in a BST Check if a tree is a BST or not Populate Inorder successor of all nodes Find LCA of 2 nodes in a BST Construct BST from preorder traversal Convert Binary tree into BST Convert a normal BST into a Balanced BST Merge two BST Find Kth largest element and Kth smallest element in a BST Count pairs from 2 BST whose sum is equal to given value &ldquo;X&rdquo; Find the median of BST in O(n) time and O(1) space Count BST nodes that lie in a given range Replace every element with the least greater element on its right Given &ldquo;n&rdquo; appointments, find the conflicting appointments Preorder to Postorder Check whether BST contains Dead end Largest BST in a Binary Tree Flatten BST to sorted list Find a value in a BST class Node: def __init__(self, data, left=None, right=None): self.">
<meta name="author" content="">
<link rel="canonical" href="https://atharvashah.netlify.app/blog/dsapython/binary-search-tree/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.c1a57f9a48dd49bab0703659ec92ef9980e4cbac2bd524742439e68d260d9d27.css" integrity="sha256-waV/mkjdSbqwcDZZ7JLvmYDky6wr1SR0JDnmjSYNnSc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://atharvashah.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://atharvashah.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://atharvashah.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://atharvashah.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://atharvashah.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9913536001930134" crossorigin="anonymous"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-216150796-2', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="DSA in Python - Binary Search Trees" />
<meta property="og:description" content="Find a value in a BST Deletion of a node in a BST Find min and max value in a BST Find inorder successor and inorder predecessor in a BST Check if a tree is a BST or not Populate Inorder successor of all nodes Find LCA of 2 nodes in a BST Construct BST from preorder traversal Convert Binary tree into BST Convert a normal BST into a Balanced BST Merge two BST Find Kth largest element and Kth smallest element in a BST Count pairs from 2 BST whose sum is equal to given value &ldquo;X&rdquo; Find the median of BST in O(n) time and O(1) space Count BST nodes that lie in a given range Replace every element with the least greater element on its right Given &ldquo;n&rdquo; appointments, find the conflicting appointments Preorder to Postorder Check whether BST contains Dead end Largest BST in a Binary Tree Flatten BST to sorted list Find a value in a BST class Node: def __init__(self, data, left=None, right=None): self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://atharvashah.netlify.app/blog/dsapython/binary-search-tree/" />
<meta property="og:image" content="https://atharvashah.netlify.app/blog/dsa/bst.jpg" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-07-09T13:10:34+05:30" />
<meta property="article:modified_time" content="2022-07-09T13:10:34+05:30" /><meta property="og:site_name" content="Atharva Shah" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://atharvashah.netlify.app/blog/dsa/bst.jpg" />
<meta name="twitter:title" content="DSA in Python - Binary Search Trees"/>
<meta name="twitter:description" content="Find a value in a BST Deletion of a node in a BST Find min and max value in a BST Find inorder successor and inorder predecessor in a BST Check if a tree is a BST or not Populate Inorder successor of all nodes Find LCA of 2 nodes in a BST Construct BST from preorder traversal Convert Binary tree into BST Convert a normal BST into a Balanced BST Merge two BST Find Kth largest element and Kth smallest element in a BST Count pairs from 2 BST whose sum is equal to given value &ldquo;X&rdquo; Find the median of BST in O(n) time and O(1) space Count BST nodes that lie in a given range Replace every element with the least greater element on its right Given &ldquo;n&rdquo; appointments, find the conflicting appointments Preorder to Postorder Check whether BST contains Dead end Largest BST in a Binary Tree Flatten BST to sorted list Find a value in a BST class Node: def __init__(self, data, left=None, right=None): self."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://atharvashah.netlify.app/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "DSA in Python - Binary Search Trees",
      "item": "https://atharvashah.netlify.app/blog/dsapython/binary-search-tree/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DSA in Python - Binary Search Trees",
  "name": "DSA in Python - Binary Search Trees",
  "description": "Find a value in a BST Deletion of a node in a BST Find min and max value in a BST Find inorder successor and inorder predecessor in a BST Check if a tree is a BST or not Populate Inorder successor of all nodes Find LCA of 2 nodes in a BST Construct BST from preorder traversal Convert Binary tree into BST Convert a normal BST into a Balanced BST Merge two BST Find Kth largest element and Kth smallest element in a BST Count pairs from 2 BST whose sum is equal to given value \u0026ldquo;X\u0026rdquo; Find the median of BST in O(n) time and O(1) space Count BST nodes that lie in a given range Replace every element with the least greater element on its right Given \u0026ldquo;n\u0026rdquo; appointments, find the conflicting appointments Preorder to Postorder Check whether BST contains Dead end Largest BST in a Binary Tree Flatten BST to sorted list Find a value in a BST class Node: def __init__(self, data, left=None, right=None): self.",
  "keywords": [
    "DSA-Python"
  ],
  "articleBody": " Find a value in a BST Deletion of a node in a BST Find min and max value in a BST Find inorder successor and inorder predecessor in a BST Check if a tree is a BST or not Populate Inorder successor of all nodes Find LCA of 2 nodes in a BST Construct BST from preorder traversal Convert Binary tree into BST Convert a normal BST into a Balanced BST Merge two BST Find Kth largest element and Kth smallest element in a BST Count pairs from 2 BST whose sum is equal to given value “X” Find the median of BST in O(n) time and O(1) space Count BST nodes that lie in a given range Replace every element with the least greater element on its right Given “n” appointments, find the conflicting appointments Preorder to Postorder Check whether BST contains Dead end Largest BST in a Binary Tree Flatten BST to sorted list Find a value in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Recursive function to insert a key into a BST def insert(root, key): # if the root is None, create a new node and return it if root is None: return Node(key) # if the given key is less than the root node, recur for the left subtree if key \u003c root.data: root.left = insert(root.left, key) # if the given key is more than the root node, recur for the right subtree else: root.right = insert(root.right, key) return root # Recursive function to search in a given BST def search(root, key, parent): # if the key is not present in the key if root is None: print('Key not found') return # if the key is found if root.data == key: if parent is None: print(f'The node with key {key} is root node') elif key \u003c parent.data: print('The given key is the left node of the node with key', parent.data) else: print('The given key is the right node of the node with key', parent.data) return # if the given key is less than the root node, recur for the left subtree; # otherwise, recur for the right subtree if key \u003c root.data: search(root.left, key, root) else: search(root.right, key, root) keys = [15, 10, 20, 8, 12, 16, 25] root = None for key in keys: root = insert(root, key) search(root, 25, None) Deletion of a node in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform inorder traversal on the BST def inorder(root): if root is None: return inorder(root.left) print(root.data, end=' ') inorder(root.right) # Function to find the maximum value node in the subtree rooted at `ptr` def findMaximumKey(ptr): while ptr.right: ptr = ptr.right return ptr # Recursive function to insert a key into a BST def insert(root, key): if root is None: return Node(key) # if the given key is less than the root node, recur for the left subtree if key \u003c root.data: root.left = insert(root.left, key) # if the given key is more than the root node, recur for the right subtree else: root.right = insert(root.right, key) return root # Function to delete a node from a BST def deleteNode(root, key): if root is None: return root # if the given key is less than the root node, recur for the left subtree if key \u003c root.data: root.left = deleteNode(root.left, key) # if the given key is more than the root node, recur for the right subtree elif key \u003e root.data: root.right = deleteNode(root.right, key) # key found else: # Case 1: node to be deleted has no children (it is a leaf node) if root.left is None and root.right is None: # update root to None return None # Case 2: node to be deleted has two children elif root.left and root.right: # find its inorder predecessor node predecessor = findMaximumKey(root.left) # copy value of the predecessor to the current node root.data = predecessor.data # recursively delete the predecessor. Note that the # predecessor will have at most one child (left child) root.left = deleteNode(root.left, predecessor.data) # Case 3: node to be deleted has only one child else: # choose a child node child = root.left if root.left else root.right root = child return root keys = [15, 10, 20, 8, 12, 25] root = None for key in keys: root = insert(root, key) root = deleteNode(root, 12) inorder(root) Find min and max value in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform inorder traversal on the BST def inorder(root): if root is None: return inorder(root.left) print(root.data, end=' ') inorder(root.right) # Function to find the maximum value node in the subtree rooted at `ptr` def findMaximumKey(ptr): while ptr.right: ptr = ptr.right return ptr.data # Function to find the maximum value node in the subtree rooted at `ptr` def findMinimumKey(ptr): while ptr.left: ptr = ptr.left return ptr.data # Recursive function to insert a key into a BST def insert(root, key): if root is None: return Node(key) # if the given key is less than the root node, recur for the left subtree if key \u003c root.data: root.left = insert(root.left, key) # if the given key is more than the root node, recur for the right subtree else: root.right = insert(root.right, key) return root keys = [15, 10, 20, 8, 12, 25] root = None for key in keys: root = insert(root, key) inorder(root) print() print(\"Minimum: \",findMinimumKey(root)) print(\"Maximum: \",findMaximumKey(root)) Find inorder successor and inorder predecessor in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) if key \u003c root.data: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def findMinimum(root): while root.left: root = root.left return root def findMaximum(root): while root.right: root = root.right return root def findSuccessor(root, succ, key): if root is None: return succ # if a node with the desired value is found, the successor is the minimum value # node in its right subtree (if any) if root.data == key: if root.right: return findMinimum(root.right) # if the given key is less than the root node, recur for the left subtree elif key \u003c root.data: # update successor to the current node before recursing in the left subtree succ = root return findSuccessor(root.left, succ, key) # if the given key is more than the root node, recur for the right subtree else: return findSuccessor(root.right, succ, key) return succ def findPredecessor(root, prec, key): if root is None: return prec # if a node with the desired value is found, the predecessor is the maximum value # node in its left subtree (if any) if root.data == key: if root.left: return findMaximum(root.left) # if the given key is less than the root node, recur for the left subtree elif key \u003c root.data: return findPredecessor(root.left, prec, key) # if the given key is more than the root node, recur for the right subtree else: # update predecessor to the current node before recursing in the right subtree prec = root return findPredecessor(root.right, prec, key) return prec keys = [15, 10, 20, 8, 12, 16, 25] ''' Construct the following BST 15 / \\ / \\ 10 20 / \\ / \\ / \\ / \\ 8 12 16 25 ''' root = None for key in keys: root = insert(root, key) print(\"SUCCESSOR\") # find inorder successor for each key for key in keys: succ = findSuccessor(root, None, key) if succ: print(f'The successor of node {key} is {succ.data}') else: print(f'No Successor exists for node {key}') print(\"PREDECESSOR\") # find inorder predecessor for each key for key in keys: prec = findPredecessor(root, None, key) if prec: print(f'Predecessor of node {key} is {prec.data}') else: print('The predecessor doesn\\'t exist for node', key) Check if a tree is a BST or not import sys class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) if key \u003c root.data: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root # Function to perform inorder traversal on the given binary tree and # check if it is a BST or not. Here, `prev` is the previously processed node def isBST(root, prev): # base case: empty tree is a BST if root is None: return True # check if the left subtree is BST or not left = isBST(root.left, prev) # value of the current node should be more than that of the previous node if root.data \u003c= prev.data: return False # update previous node data and check if the right subtree is BST or not prev.data = root.data return left and isBST(root.right, prev) # Function to determine whether a given binary tree is a BST def checkForBST(node): # pointer to store previously processed node in the inorder traversal prev = Node(-sys.maxsize) # check if nodes are processed in sorted order if isBST(node, prev): print('The tree is a BST!') else: print('The tree is not a BST!') def swap(root): left = root.left root.left = root.right root.right = left # keys = [15, 10, 20, 8, 12, 16, 25] keys=[8,3,1,6,7,10,14,4] root = None for key in keys: root = insert(root, key) # swap nodes swap(root) checkForBST(root) Populate Inorder successor of all nodes class Node: def __init__(self, data, left=None, right=None, next=None): self.data = data self.left = left self.right = right self.next = next # Function to set the next pointer of all nodes in a binary tree. # curr —\u003e current node # prev —\u003e previously processed node def setNextNode(curr, prev=None): if curr is None: return prev # recur for the left subtree prev = setNextNode(curr.left, prev) # set the previous node's next pointer to the current node if prev: prev.next = curr # update the previous node to the current node prev = curr # recur for the right subtree return setNextNode(curr.right, prev) # Function to print inorder successor of all nodes of binary tree using the next pointer def printInorderSuccessors(root): # go to the leftmost node curr = root while curr.left: curr = curr.left # print inorder successor of all nodes while curr.next: print(f'The inorder successor of {curr.data} is {curr.next.data}') curr = curr.next ''' Construct the following tree 1 / \\ / \\ 2 3 / / \\ / / \\ 4 5 6 / \\ / \\ 7 8 ''' root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) setNextNode(root) printInorderSuccessors(root) Find LCA of 2 nodes in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) # if the given key is less than the root node, recur for the left subtree if key \u003c root.data: root.left = insert(root.left, key) # if the given key is more than the root node, recur for the right subtree else: root.right = insert(root.right, key) return root # Iterative function to search a given node in a BST def search(root, key): # traverse the tree and search for the key while root: # if the given key is less than the current node, go to the left # subtree; otherwise, go to the right subtree if key.data \u003c root.data: root = root.left elif key.data \u003e root.data: root = root.right # if the key is found, return true elif key == root: return True else: return False # we reach here if the key is not present in the BST return False # Recursive function to find the lowest common ancestor of given nodes # `x` and `y`, where both `x` and `y` are present in a BST def LCARecursive(root, x, y): if root is None: return None # if both `x` and `y` is smaller than the root, LCA exists in the left subtree if root.data \u003e max(x.data, y.data): return LCARecursive(root.left, x, y) # if both `x` and `y` are greater than the root, LCA exists in the right subtree elif root.data \u003c min(x.data, y.data): return LCARecursive(root.right, x, y) # if one key is greater (or equal) than the root and one key is smaller # (or equal) than the root, then the current node is LCA return root # Print lowest common ancestor of two nodes in a BST def LCA(root, x, y): # return if the tree is empty, or `x` or `y` is not present in the tree if not root or not search(root, x) or not search(root, y): return # `lca` stores the lowest common ancestor of `x` and `y` lca = LCARecursive(root, x, y) # if the lowest common ancestor exists, print it if lca: print('LCA is', lca.data) else: print('LCA does not exist') keys = [15, 10, 20, 8, 12, 16, 25] ''' Construct the following tree 15 / \\ / \\ 10 20 / \\ / \\ / \\ / \\ 8 12 16 25 ''' root = None for key in keys: root = insert(root, key) LCA(root, root.left.left, root.left.right) Construct BST from preorder traversal import sys class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right def inorder(root): if root is None: return inorder(root.left) print(root.key, end=' ') inorder(root.right) # Recursive function to build a BST from a preorder sequence. # start from the root node (the first element in a preorder sequence) # set the root node's range as [-INFINITY, INFINITY] def buildBST(preorder, pIndex=0, min=-sys.maxsize, max=sys.maxsize): # Base case if pIndex == len(preorder): return None, pIndex # Return if the next element of preorder traversal is not in the valid range val = preorder[pIndex] if val \u003c min or val \u003e max: return None, pIndex # Construct the root node and increment `pIndex` root = Node(val) pIndex = pIndex + 1 # Since all elements in the left subtree of a BST must be less # than the root node's value, set range as `[min, val-1]` and recur root.left, pIndex = buildBST(preorder, pIndex, min, val - 1) # Since all elements in the right subtree of a BST must be greater # than the root node's value, set range as `[val+1…max]` and recur root.right, pIndex = buildBST(preorder, pIndex, val + 1, max) return root, pIndex ''' Construct the following BST 15 / \\ / \\ 10 20 / \\ / \\ / \\ / \\ 8 12 16 25 ''' preorder = [15, 10, 8, 12, 20, 16, 25] root = buildBST(preorder)[0] print('Inorder traversal of BST is:', end=' ') inorder(root) Convert Binary tree into BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform inorder traversal on the tree def inorder(root): if root is None: return inorder(root.left) print(root.data, end=' ') inorder(root.right) # Function to traverse the binary tree and store its keys in a set def extractKeys(root, keys): # base case if root is None: return extractKeys(root.left, keys) keys.append(root.data) extractKeys(root.right, keys) # Function to put keys back into a set in their correct order in a BST # by doing inorder traversal def convertToBST(root, it): if root is None: return convertToBST(root.left, it) root.data = next(it) convertToBST(root.right, it) # Function to convert a binary tree to BST by maintaining its original structure def convert(root): # traverse the binary tree and store its keys in a set keys = [] extractKeys(root, keys) # put back keys present in the set to their correct order in the BST it = iter(sorted(keys)) convertToBST(root, it) ''' Construct the following tree 8 / \\ / \\ 3 5 / \\ / \\ / \\ / \\ 10 2 4 6 ''' root = Node(8) root.left = Node(3) root.right = Node(5) root.left.left = Node(10) root.left.right = Node(2) root.right.left = Node(4) root.right.right = Node(6) convert(root) inorder(root) Convert a normal BST into a Balanced BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform the preorder traversal on a BST def preorder(root): if root is None: return print(root.data, end=' ') preorder(root.left) preorder(root.right) # Recursive function to push nodes of a given binary search tree into a # list in an inorder fashion def pushTreeNodes(root, nodes): if root is None: return pushTreeNodes(root.left, nodes) nodes.append(root) pushTreeNodes(root.right, nodes) # Recursive function to construct a height-balanced BST from # given nodes in sorted order def buildBalancedBST(nodes, start, end): if start \u003e end: return None # find the middle index mid = (start + end) // 2 # The root node will be a node present at the mid-index root = nodes[mid] # recursively construct left and right subtree root.left = buildBalancedBST(nodes, start, mid - 1) root.right = buildBalancedBST(nodes, mid + 1, end) # return root node return root # Function to construct a height-balanced BST from an unbalanced BST def constructBalancedBST(root): # Push nodes of a given binary search tree into a list in sorted order nodes = [] pushTreeNodes(root, nodes) # Construct a height-balanced BST from sorted BST nodes return buildBalancedBST(nodes, 0, len(nodes) - 1) root = Node(20) root.left = Node(15) root.left.left = Node(10) root.left.left.left = Node(5) root.left.left.left.left = Node(2) root.left.left.left.right = Node(8) root = constructBalancedBST(root) print('Preorder traversal of the constructed BST is ', end='') preorder(root) Merge two BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to push a BST node at the front of a doubly linked list def push(root, head): root.right = head if head: head.left = root head = root return head # Function to print and count the total number of nodes in a doubly-linked list def size(node): counter = 0 while node: node = node.right counter = counter + 1 return counter # Function to print preorder traversal of the BST def preorder(root): if root is None: return print(root.data, end=' ') preorder(root.left) preorder(root.right) # Recursive method to construct a balanced BST from a sorted doubly linked list def convertSortedDLLToBalancedBST(head, n): if n \u003c= 0: return None, head # recursively construct the left subtree leftSubTree, head = convertSortedDLLToBalancedBST(head, n // 2) # `head` now points to the middle node of the sorted DDL # make the middle node of the sorted DDL as the root node of the BST root = head # update left child of the root node root.left = leftSubTree # update the head reference of the doubly linked list head = head.right # recursively construct the right subtree with the remaining nodes root.right, head = convertSortedDLLToBalancedBST(head, n - (n // 2 + 1)) # +1 for the root # return the root node return root, head # Recursive method to convert a BST into a doubly-linked list. It takes # the BST's root node and the head node of the doubly linked list as an argument def convertBSTtoSortedDLL(root, head=None): if root is None: return head # recursively convert the right subtree head = convertBSTtoSortedDLL(root.right, head) # push the current node at the front of the doubly linked list head = push(root, head) # recursively convert the left subtree head = convertBSTtoSortedDLL(root.left, head) return head # Recursive method to merge two doubly-linked lists into a # single doubly linked list in sorted order def sortedMerge(first, second): # if the first list is empty, return the second list if first is None: return second # if the second list is empty, return the first list if second is None: return first # if the head node of the first list is smaller if first.data \u003c second.data: first.right = sortedMerge(first.right, second) first.right.left = first return first # if the head node of the second list is smaller else: second.right = sortedMerge(first, second.right) second.right.left = second return second # Function to merge two balanced BSTs into a single balanced BST def merge(first, second): # merge both BSTs into a sorted doubly linked list head = sortedMerge(convertBSTtoSortedDLL(first), convertBSTtoSortedDLL(second)) # construct a balanced BST from a sorted doubly linked list root, head = convertSortedDLLToBalancedBST(head, size(head)) return root ''' Construct the first BST 20 / \\ 10 30 / \\ 25 100 ''' first = Node(20) first.left = Node(10) first.right = Node(30) first.right.left = Node(25) first.right.right = Node(100) ''' Construct the second BST 50 / \\ 5 70 ''' second = Node(50) second.left = Node(5) second.right = Node(70) # merge both BSTs root = merge(first, second) preorder(root) Find Kth largest element and Kth smallest element in a BST import sys class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) if key \u003c root.data: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root # Function to find the k'th largest node in a BST. Here, `i` denotes the total number of nodes processed so far def kthLargest(root, i, k): if root is None: return None, i # search in the right subtree left, i = kthLargest(root.right, i, k) # if k'th largest is found in the left subtree, return it if left: return left, i i = i + 1 # if the current node is k'th largest, return its value if i == k: return root, i # otherwise, search in the left subtree return kthLargest(root.left, i, k) def findKthLargest(root, k): i = 0 # traverse the tree in an inorder fashion and return k'th node return kthLargest(root, i, k)[0] def kthSmallest(root, counter, k): if root is None: return None, counter # recur for the left subtree left, counter = kthSmallest(root.left, counter, k) # if k'th smallest node is found if left: return left, counter # if the root is k'th smallest node counter = counter + 1 if counter == k: return root, counter # recur for the right subtree only if k'th smallest node is not found # in the right subtree ret, counter = kthSmallest(root.right, counter, k) return ret, counter def findKthSmallest(root, k): counter = 0 # recursively find the k'th smallest node return kthSmallest(root, counter, k)[0] keys = [15, 10, 20, 8, 12, 16, 25] root = None for key in keys: root = insert(root, key) k = 2 print(f\"{k}th LARGEST NODE\") result = findKthLargest(root, k) if result != sys.maxsize: print(result.data) else: print('Invalid Input') k = 4 print(f\"{k}th SMALLEST NODE\") result = findKthSmallest(root, k) if result: print(result.data) else: print(f'{k}\\'th smallest node does not exist.') Count pairs from 2 BST whose sum is equal to given value “X” class Node: def __init__(self,data): self.data = data self.left = None self.right = None root1,root2 = None,None # def to count pairs from two BSTs whose sum is equal to a given value x pairCount = 0 def traverseTree(root1, root2, sum): if root1 is None or root2 is None: return traverseTree(root1.left, root2, sum) traverseTree(root1.right, root2, sum) diff = sum - root1.data findPairs(root2, diff) def findPairs(root2 , diff): global pairCount if root2 is None: return if (diff \u003e root2.data) : findPairs(root2.right, diff) else : findPairs(root2.left, diff) if (root2.data == diff): pairCount += 1 def countPairs(root1, root2, sum): global pairCount traverseTree(root1, root2, sum) return pairCount root1 = Node(5) root1.left = Node(3) root1.right = Node(7) root1.left.left = Node(2) root1.left.right = Node(4) root1.right.left = Node(6) root1.right.right = Node(8) # formation of BST 2 root2 = Node(10) root2.left = Node(6) root2.right = Node(15) root2.left.left = Node(3) root2.left.right = Node(8) root2.right.left = Node(11) root2.right.right = Node(18) x = 16 print(f\"Pairs = {countPairs(root1, root2, x)}\") Find the median of BST in O(n) time and O(1) space _MIN=float('-inf') _MAX=float('inf') # Helper function that allocates a new node with the given data and None left and right pointers. class newNode: def __init__(self, data): self.data = data self.left = None self.right = None # A utility function to insert a new node with given key in BST def insert(node,key): if node is None: return newNode(key) # Otherwise, recur down the tree if (key \u003c node.data): node.left = insert(node.left, key) elif (key \u003e node.data): node.right = insert(node.right, key) # return the (unchanged) node pointer return node #Function to count nodes in a binary search tree using Morris Inorder traversal def counNodes(root): count = 0 if root is None: return count current = root while (current != None): if current.left is None: # Count node if its left is None count+=1 # Move to its right current = current.right else: # Find the inorder predecessor of current pre = current.left while pre.right not in [None, current]: pre = pre.right #Make current as right child of its inorder predecessor if pre.right is None: pre.right = current current = current.left else: pre.right = None # Increment count if the current node is to be visited count += 1 current = current.right return count def findMedian(root): if root is None: return 0 count = counNodes(root) currCount = 0 current = root while (current != None): if current.left is None: # count current node currCount += 1 # check if current node is the median # Odd case if (count % 2 != 0 and currCount == (count + 1)//2): return prev.data # Even case elif (count % 2 == 0 and currCount == (count//2)+1): return (prev.data + current.data)//2 # Update prev for even no. of nodes prev = current #Move to the right current = current.right else: # Find the inorder predecessor of current pre = current.left while pre.right not in [None, current]: pre = pre.right # Make current as right child of its inorder predecessor if pre.right is None: pre.right = current current = current.left else: pre.right = None prev = pre # Count current node currCount+= 1 # Check if the current node is the median if (count % 2 != 0 and currCount == (count + 1) // 2 ): return current.data elif (count%2 == 0 and currCount == (count // 2) + 1): return (prev.data+current.data)//2 # update prev node for the case of even # no. of nodes prev = current current = current.right \"\"\" Constructed binary tree is 50 / \\ 30 70 / \\ / \\ 20 40 60 80 \"\"\" root = newNode(50) insert(root, 30) insert(root, 20) insert(root, 40) insert(root, 70) insert(root, 60) insert(root, 80) print(\"Median of BST is \",findMedian(root)) Count BST nodes that lie in a given range class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) if key \u003c root.data: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def countNodes(root, low, high): if root is None: return 0 # keep track of the total number of nodes in the tree rooted with `root`. # that lies within the current range [low, high] count = 0 # increment count if the current node lies within the current range if low \u003c= root.data \u003c= high: count += 1 # recur for the left subtree count += countNodes(root.left, low, high) # recur for the right subtree and return the total count return count + countNodes(root.right, low, high) low, high = 12, 20 keys = [15, 25, 20, 22, 30, 18, 10, 8, 9, 12, 6] root = None for key in keys: root = insert(root, key) print('The total number of nodes is', countNodes(root, low, high)) Replace every element with the least greater element on its right \"\"\" Given an array of integers, replace every element with the least greater element on its right side in the array. If there are no greater elements on the right side, replace it with -1. Examples: Input: [8, 58, 71, 18, 31, 32, 63, 92, 43, 3, 91, 93, 25, 80, 28] Output: [18, 63, 80, 25, 32, 43, 80, 93, 80, 25, 93, -1, 28, -1, -1] \"\"\" class Node: def __init__(self, d): self.data = d self.left = None self.right = None # A utility function to insert a new node with given data in BST and find its successor def insert(node, data): global succ # If the tree is empty, return a new node root = node if node is None: return Node(data) # If key is smaller than root's key, go to left subtree and set successor as current node if (data \u003c node.data): #print(\"1\") succ = node root.left = insert(node.left, data) # Go to right subtree elif (data \u003e node.data): root.right = insert(node.right, data) return root # Function to replace every element with the least greater element on its right def replace(arr, n): global succ root = None # Start from right to left for i in range(n - 1, -1, -1): succ = None # Insert current element into BST and find its inorder successor root = insert(root, arr[i]) # Replace element by its inorder successor in BST arr[i] = succ.data if succ else -1 return arr arr = [ 8, 58, 71, 18, 31, 32, 63, 92, 43, 3, 91, 93, 25, 80, 28 ] n = len(arr) succ = None arr = replace(arr, n) print(*arr) Given “n” appointments, find the conflicting appointments \"\"\" Input: appointments[] = { {1, 5} {3, 7}, {2, 6}, {10, 15}, {5, 6}, {4, 100}} Output: Following are conflicting intervals [3,7] Conflicts with [1,5] [2,6] Conflicts with [1,5] [5,6] Conflicts with [3,7] [4,100] Conflicts with [1,5] \"\"\" class Interval: def __init__(self): self.low = None self.high = None # Structure to represent a node in Interval Search Tree class ITNode: def __init__(self): self.max = None self.i = None self.left = None self.right = None def newNode(j): #print(j) temp = ITNode() temp.i = j temp.max = j[1] return temp # A utility function to check if given two intervals overlap def doOVerlap(i1, i2): if (i1[0] \u003c i2[1] and i2[0] \u003c i1[1]): return True return False # Function to create a new node def insert(node, data): global succ # If the tree is empty, return a new node root = node if node is None: return newNode(data) # If key is smaller than root's key, go to left subtree and set successor as current node print(node) if (data[0] \u003c node.i[0]): root.left = insert(node.left, data) # Go to right subtree else: root.right = insert(node.right, data) if root.max \u003c data[1]: root.max = data[1] return root # The main function that searches a given interval i in a given Interval Tree. def overlapSearch(root, i): if root is None: return None # If given interval overlaps with root if (doOVerlap(root.i, i)): return root.i # If left child of root is present and max of left child is greater than or # equal to given interval, then i may overlap with an interval is left subtree if (root.left != None and root.left.max \u003e= i[0]): return overlapSearch(root.left, i) # Else interval can only overlap with right subtree return overlapSearch(root.right, i) # This function prints all conflicting appointments in a given array of appointments. def printConflicting(appt, n): # Create an empty Interval Search Tree, add first appointment root = None root = insert(root, appt[0]) # Process rest of the intervals for i in range(1, n): # If current appointment conflicts with any of the existing intervals, print it res = overlapSearch(root, appt[i]) if (res != None): print(\"[\", appt[i][0], \",\", appt[i][1], \"] Conflicts with [\", res[0], \",\", res[1], \"]\") # Insert this appointment root = insert(root, appt[i]) appt = [ [ 1, 5 ], [ 3, 7 ], [ 2, 6 ], [ 10, 15 ], [ 5, 6 ], [ 4, 100 ] ] n = len(appt) print(\"Following are conflicting intervals\") printConflicting(appt, n) Preorder to Postorder # A class to store a binary tree node class Node: def __init__(self, key): self.key = key def postorder(root): if root is None: return postorder(root.left) postorder(root.right) print(root.key, end=' ') # Recursive function to build a BST from a preorder sequence. def constructBST(preorder, start, end): # base case if start \u003e end: return None # Construct the root node of the subtree formed by keys of the # preorder sequence in range `[start, end]` node = Node(preorder[start]) # search the index of the first element in the current range of preorder # sequence larger than the root node's value i = start while i \u003c= end: if preorder[i] \u003e node.key: break i = i + 1 # recursively construct the left subtree node.left = constructBST(preorder, start + 1, i - 1) # recursively construct the right subtree node.right = constructBST(preorder, i, end) # return current node return node ''' Construct the following BST 15 / \\ / \\ 10 20 / \\ / \\ / \\ / \\ 8 12 16 25 ''' preorder = [15, 10, 8, 12, 20, 16, 25] root = constructBST(preorder, 0, len(preorder) - 1) print('Postorder traversal of BST is ', end='') postorder(root) Check whether BST contains Dead end \"\"\" Given a Binary search Tree that contains positive integer values greater than 0. The task is to check whether the BST contains a dead end or not. Here Dead End means, we are not able to insert any element after that node. Examples: Input : 8 / \\ 5 9 / \\ 2 7 / 1 Output : Yes Explanation : Node \"1\" is the dead End because after that we cant insert any element. Input : 8 / \\ 7 10 / / \\ 2 9 13 Output : Yes Explanation : We can't insert any element at node 9. \"\"\" all_nodes = set() leaf_nodes = set() # A BST node class newNode: def __init__(self, data): self.data = data self.left = None self.right = None # A utility function to insert a new Node with given key in BST def insert(node, key): if node is None: return newNode(key) # Otherwise, recur down the tree if (key \u003c node.data): node.left = insert(node.left, key) elif (key \u003e node.data): node.right = insert(node.right, key) # return the (unchanged) Node pointer return node # Function to store all node of given binary search tree def storeNodes(root): global all_nodes global leaf_nodes if root is None: return # store all node of binary search tree all_nodes.add(root.data) # store leaf node in leaf_hash if root.left is None and root.right is None: leaf_nodes.add(root.data) return # recur call rest tree storeNodes(root. left) storeNodes(root.right) # Returns true if there is a dead end in tree, else false. def isDeadEnd(root): global all_nodes global leaf_nodes if root is None: return False # create two empty hash sets that store all BST elements and leaf nodes respectively. # insert 0 in 'all_nodes' for handle case if bst contain value 1 all_nodes.add(0) # Call storeNodes function to store all BST Node storeNodes(root) return any(((x + 1) in all_nodes and (x - 1) in all_nodes) for x in leaf_nodes) root = None root = insert(root, 8) root = insert(root, 5) root = insert(root, 2) root = insert(root, 3) root = insert(root, 7) root = insert(root, 11) root = insert(root, 4) if(isDeadEnd(root) == True): print(\"Yes\") else: print(\"No\") Largest BST in a Binary Tree import sys sys.setrecursionlimit(1000000) from collections import deque IMIN = float('-inf') IMAX = float('inf') class newNode: def __init__(self, val): self.right = None self.data = val self.left = None def largestBst(root): if root is None: return IMAX,IMIN,0 if root.left is None and root.right is None: return root.data,root.data,1 left=largestBst(root.left) right=largestBst(root.right) ans=[0,0,0] if left[1]\u003croot.data and right[0]\u003eroot.data: ans[0]=min(left[0],right[0],root.data) ans[1]=max(right[1],left[1],root.data) ans[2]=1+left[2]+right[2] return ans ans[0]=IMIN ans[1]=IMAX ans[2]=max(left[2],right[2]) return ans[2] \"\"\" 50 / \\ 75 45 / 40 \"\"\" root = newNode(50) root.left = newNode(75) root.right = newNode(45) root.left.left = newNode(40) print(\"Size of the largest BST is\",largestBst(root)) Flatten BST to sorted list global prev class node : def __init__(self, data): self.data = data self.left = None self.right = None def printTree(parent): root = parent while root is not None: print(root.data,end=' ') root = root.right def inorder(root): global prev if root is None: return inorder(root.left) print(root.data,end=' ') inorder(root.right) # Function to flatten binary tree using level order traversal BFS def flatten(parent): global prev # Dummy node dummy = node(-1) # Pointer to previous element prev = dummy # Calling in-order traversal inorder(parent) prev.left = None prev.right = None # Delete dummy node return dummy.right root = node(5) root.left = node(3) root.right = node(7) root.left.left = node(2) root.left.right = node(4) root.right.left = node(6) root.right.right = node(8) printTree(flatten(root)) ",
  "wordCount" : "5985",
  "inLanguage": "en",
  "image":"https://atharvashah.netlify.app/blog/dsa/bst.jpg","datePublished": "2022-07-09T13:10:34+05:30",
  "dateModified": "2022-07-09T13:10:34+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://atharvashah.netlify.app/blog/dsapython/binary-search-tree/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Atharva Shah",
    "logo": {
      "@type": "ImageObject",
      "url": "https://atharvashah.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://atharvashah.netlify.app/" accesskey="h" title="Atharva Shah (Alt + H)">
                <img src="https://atharvashah.netlify.app/profile/header_button.gif" alt="Atharva Shah logo" aria-label="logo"
                    height="30">Atharva Shah</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://atharvashah.netlify.app/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://atharvashah.netlify.app/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://atharvashah.netlify.app/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://atharvashah.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://atharvashah.netlify.app/blog/">Blogs</a></div>
    <h1 class="post-title">
      DSA in Python - Binary Search Trees
    </h1>
    <div class="post-meta"><span title='2022-07-09 13:10:34 +0530 IST'>July 9, 2022</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;5985 words

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://atharvashah.netlify.app/blog/dsa/bst.jpg" alt="Binary Search Trees">
        <p>Learn BST Algorithms in Python</p>
</figure>
  <div class="post-content"><ul>
<li><a href="#find-a-value-in-a-bst">Find a value in a BST</a></li>
<li><a href="#deletion-of-a-node-in-a-bst">Deletion of a node in a BST</a></li>
<li><a href="#find-min-and-max-value-in-a-bst">Find min and max value in a BST</a></li>
<li><a href="#find-inorder-successor-and-inorder-predecessor-in-a-bst">Find inorder successor and inorder predecessor in a BST</a></li>
<li><a href="#check-if-a-tree-is-a-bst-or-not">Check if a tree is a BST or not</a></li>
<li><a href="#populate-inorder-successor-of-all-nodes">Populate Inorder successor of all nodes</a></li>
<li><a href="#find-lca--of-2-nodes-in-a-bst">Find LCA  of 2 nodes in a BST</a></li>
<li><a href="#construct-bst-from-preorder-traversal">Construct BST from preorder traversal</a></li>
<li><a href="#convert-binary-tree-into-bst">Convert Binary tree into BST</a></li>
<li><a href="#convert-a-normal-bst-into-a-balanced-bst">Convert a normal BST into a Balanced BST</a></li>
<li><a href="#merge-two-bst">Merge two BST</a></li>
<li><a href="#find-kth-largest-element-and-kth-smallest-element-in-a-bst">Find Kth largest element and Kth smallest element in a BST</a></li>
<li><a href="#count-pairs-from-2-bst-whose-sum-is-equal-to-given-value-x">Count pairs from 2 BST whose sum is equal to given value &ldquo;X&rdquo;</a></li>
<li><a href="#find-the-median-of-bst-in-on-time-and-o1-space">Find the median of BST in O(n) time and O(1) space</a></li>
<li><a href="#count-bst-nodes-that-lie-in-a-given-range">Count BST nodes that lie in a given range</a></li>
<li><a href="#replace-every-element-with-the-least-greater-element-on-its-right">Replace every element with the least greater element on its right</a></li>
<li><a href="#given-n-appointments-find-the-conflicting-appointments">Given &ldquo;n&rdquo; appointments, find the conflicting appointments</a></li>
<li><a href="#preorder-to-postorder">Preorder to Postorder</a></li>
<li><a href="#check-whether-bst-contains-dead-end">Check whether BST contains Dead end</a></li>
<li><a href="#largest-bst-in-a-binary-tree">Largest BST in a Binary Tree</a></li>
<li><a href="#flatten-bst-to-sorted-list">Flatten BST to sorted list</a></li>
</ul>
<h2 id="find-a-value-in-a-bst">Find a value in a BST<a hidden class="anchor" aria-hidden="true" href="#find-a-value-in-a-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to insert a key into a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(root, key):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the root is None, create a new node and return it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Node(key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is less than the root node, recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is more than the root node, recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>right, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to search in a given BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">search</span>(root, key, parent):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the key is not present in the key</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;Key not found&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the key is found</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">==</span> key:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> parent <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;The node with key </span><span style="color:#e6db74">{</span>key<span style="color:#e6db74">}</span><span style="color:#e6db74"> is root node&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> key <span style="color:#f92672">&lt;</span> parent<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;The given key is the left node of the node with key&#39;</span>, parent<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;The given key is the right node of the node with key&#39;</span>, parent<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is less than the root node, recur for the left subtree;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># otherwise, recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        search(root<span style="color:#f92672">.</span>left, key, root)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        search(root<span style="color:#f92672">.</span>right, key, root)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>keys <span style="color:#f92672">=</span> [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">25</span>]
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> insert(root, key)
</span></span><span style="display:flex;"><span>search(root, <span style="color:#ae81ff">25</span>, <span style="color:#66d9ef">None</span>)
</span></span></code></pre></div><h2 id="deletion-of-a-node-in-a-bst">Deletion of a node in a BST<a hidden class="anchor" aria-hidden="true" href="#deletion-of-a-node-in-a-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to perform inorder traversal on the BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find the maximum value node in the subtree rooted at `ptr`</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMaximumKey</span>(ptr):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ptr<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>        ptr <span style="color:#f92672">=</span> ptr<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ptr
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to insert a key into a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(root, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Node(key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is less than the root node, recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is more than the root node, recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>right, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to delete a node from a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">deleteNode</span>(root, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is less than the root node, recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> deleteNode(root<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is more than the root node, recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> key <span style="color:#f92672">&gt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> deleteNode(root<span style="color:#f92672">.</span>right, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># key found</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Case 1: node to be deleted has no children (it is a leaf node)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>left <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># update root to None</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Case 2: node to be deleted has two children</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> root<span style="color:#f92672">.</span>left <span style="color:#f92672">and</span> root<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># find its inorder predecessor node</span>
</span></span><span style="display:flex;"><span>            predecessor <span style="color:#f92672">=</span> findMaximumKey(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># copy value of the predecessor to the current node</span>
</span></span><span style="display:flex;"><span>            root<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> predecessor<span style="color:#f92672">.</span>data
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># recursively delete the predecessor. Note that the</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># predecessor will have at most one child (left child)</span>
</span></span><span style="display:flex;"><span>            root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> deleteNode(root<span style="color:#f92672">.</span>left, predecessor<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Case 3: node to be deleted has only one child</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># choose a child node</span>
</span></span><span style="display:flex;"><span>            child <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>left <span style="color:#66d9ef">else</span> root<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>            root <span style="color:#f92672">=</span> child
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>keys <span style="color:#f92672">=</span> [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">25</span>]
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> insert(root, key)
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> deleteNode(root, <span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>inorder(root)
</span></span></code></pre></div><h2 id="find-min-and-max-value-in-a-bst">Find min and max value in a BST<a hidden class="anchor" aria-hidden="true" href="#find-min-and-max-value-in-a-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to perform inorder traversal on the BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find the maximum value node in the subtree rooted at `ptr`</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMaximumKey</span>(ptr):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ptr<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>        ptr <span style="color:#f92672">=</span> ptr<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ptr<span style="color:#f92672">.</span>data
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find the maximum value node in the subtree rooted at `ptr`</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMinimumKey</span>(ptr):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ptr<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>        ptr <span style="color:#f92672">=</span> ptr<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ptr<span style="color:#f92672">.</span>data
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to insert a key into a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(root, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Node(key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is less than the root node, recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is more than the root node, recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>right, key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>keys <span style="color:#f92672">=</span> [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">25</span>]
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> insert(root, key)
</span></span><span style="display:flex;"><span>inorder(root)
</span></span><span style="display:flex;"><span>print()
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Minimum: &#34;</span>,findMinimumKey(root))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Maximum: &#34;</span>,findMaximumKey(root)) 
</span></span></code></pre></div><h2 id="find-inorder-successor-and-inorder-predecessor-in-a-bst">Find inorder successor and inorder predecessor in a BST<a hidden class="anchor" aria-hidden="true" href="#find-inorder-successor-and-inorder-predecessor-in-a-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(root, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Node(key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>right, key) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMinimum</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> root<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>        root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMaximum</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> root<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>        root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findSuccessor</span>(root, succ, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> succ
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if a node with the desired value is found, the successor is the minimum value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># node in its right subtree (if any)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">==</span> key:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>right:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> findMinimum(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is less than the root node, recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># update successor to the current node before recursing in the left subtree</span>
</span></span><span style="display:flex;"><span>        succ <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> findSuccessor(root<span style="color:#f92672">.</span>left, succ, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is more than the root node, recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> findSuccessor(root<span style="color:#f92672">.</span>right, succ, key) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> succ
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findPredecessor</span>(root, prec, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> prec
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if a node with the desired value is found, the predecessor is the maximum value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># node in its left subtree (if any)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">==</span> key:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> findMaximum(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is less than the root node, recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> findPredecessor(root<span style="color:#f92672">.</span>left, prec, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is more than the root node, recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># update predecessor to the current node before recursing in the right subtree</span>
</span></span><span style="display:flex;"><span>        prec <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> findPredecessor(root<span style="color:#f92672">.</span>right, prec, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> prec
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>keys <span style="color:#f92672">=</span> [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">25</span>]
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; Construct the following BST
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           15
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        /      </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       10       20
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      / \      /  </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">     /   \    /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    8    12  16    25
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> insert(root, key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;SUCCESSOR&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># find inorder successor for each key</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    succ <span style="color:#f92672">=</span> findSuccessor(root, <span style="color:#66d9ef">None</span>, key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> succ:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;The successor of node </span><span style="color:#e6db74">{</span>key<span style="color:#e6db74">}</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">{</span>succ<span style="color:#f92672">.</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;No Successor exists for node </span><span style="color:#e6db74">{</span>key<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;PREDECESSOR&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># find inorder predecessor for each key</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    prec <span style="color:#f92672">=</span> findPredecessor(root, <span style="color:#66d9ef">None</span>, key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> prec:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Predecessor of node </span><span style="color:#e6db74">{</span>key<span style="color:#e6db74">}</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">{</span>prec<span style="color:#f92672">.</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;The predecessor doesn</span><span style="color:#ae81ff">\&#39;</span><span style="color:#e6db74">t exist for node&#39;</span>, key)
</span></span></code></pre></div><h2 id="check-if-a-tree-is-a-bst-or-not">Check if a tree is a BST or not<a hidden class="anchor" aria-hidden="true" href="#check-if-a-tree-is-a-bst-or-not">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(root, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Node(key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>right, key) 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to perform inorder traversal on the given binary tree and</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># check if it is a BST or not. Here, `prev` is the previously processed node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isBST</span>(root, prev):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case: empty tree is a BST</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># check if the left subtree is BST or not</span>
</span></span><span style="display:flex;"><span>    left <span style="color:#f92672">=</span> isBST(root<span style="color:#f92672">.</span>left, prev)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># value of the current node should be more than that of the previous node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">&lt;=</span> prev<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># update previous node data and check if the right subtree is BST or not</span>
</span></span><span style="display:flex;"><span>    prev<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>data
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> left <span style="color:#f92672">and</span> isBST(root<span style="color:#f92672">.</span>right, prev)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to determine whether a given binary tree is a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">checkForBST</span>(node):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># pointer to store previously processed node in the inorder traversal</span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> Node(<span style="color:#f92672">-</span>sys<span style="color:#f92672">.</span>maxsize)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># check if nodes are processed in sorted order</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> isBST(node, prev):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;The tree is a BST!&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;The tree is not a BST!&#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">swap</span>(root): 
</span></span><span style="display:flex;"><span>    left <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># keys = [15, 10, 20, 8, 12, 16, 25]</span>
</span></span><span style="display:flex;"><span>keys<span style="color:#f92672">=</span>[<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">14</span>,<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> insert(root, key)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># swap nodes</span>
</span></span><span style="display:flex;"><span>swap(root)
</span></span><span style="display:flex;"><span>checkForBST(root)
</span></span></code></pre></div><h2 id="populate-inorder-successor-of-all-nodes">Populate Inorder successor of all nodes<a hidden class="anchor" aria-hidden="true" href="#populate-inorder-successor-of-all-nodes">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, next<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> next
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to set the next pointer of all nodes in a binary tree.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># curr —&gt; current node</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># prev —&gt; previously processed node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">setNextNode</span>(curr, prev<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> curr <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> prev
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> setNextNode(curr<span style="color:#f92672">.</span>left, prev)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># set the previous node&#39;s next pointer to the current node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> prev:
</span></span><span style="display:flex;"><span>        prev<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> curr
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># update the previous node to the current node</span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> curr
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> setNextNode(curr<span style="color:#f92672">.</span>right, prev)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to print inorder successor of all nodes of binary tree using the next pointer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printInorderSuccessors</span>(root):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># go to the leftmost node</span>
</span></span><span style="display:flex;"><span>    curr <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> curr<span style="color:#f92672">.</span>left:
</span></span><span style="display:flex;"><span>        curr <span style="color:#f92672">=</span> curr<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># print inorder successor of all nodes</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> curr<span style="color:#f92672">.</span>next:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;The inorder successor of </span><span style="color:#e6db74">{</span>curr<span style="color:#f92672">.</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74"> is </span><span style="color:#e6db74">{</span>curr<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>        curr <span style="color:#f92672">=</span> curr<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; Construct the following tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       /     </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">      2       3
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     /      /  </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    /      /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">   4      5      6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       7     8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>setNextNode(root)
</span></span><span style="display:flex;"><span>printInorderSuccessors(root)
</span></span></code></pre></div><h2 id="find-lca--of-2-nodes-in-a-bst">Find LCA  of 2 nodes in a BST<a hidden class="anchor" aria-hidden="true" href="#find-lca--of-2-nodes-in-a-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(root, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Node(key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is less than the root node, recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the given key is more than the root node, recur for the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>right, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Iterative function to search a given node in a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">search</span>(root, key):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># traverse the tree and search for the key</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> root:
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if the given key is less than the current node, go to the left</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># subtree; otherwise, go to the right subtree</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> key<span style="color:#f92672">.</span>data <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>            root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> key<span style="color:#f92672">.</span>data <span style="color:#f92672">&gt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>            root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if the key is found, return true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> key <span style="color:#f92672">==</span> root:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># we reach here if the key is not present in the BST</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to find the lowest common ancestor of given nodes</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># `x` and `y`, where both `x` and `y` are present in a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">LCARecursive</span>(root, x, y):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if both `x` and `y` is smaller than the root, LCA exists in the left subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">&gt;</span> max(x<span style="color:#f92672">.</span>data, y<span style="color:#f92672">.</span>data):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LCARecursive(root<span style="color:#f92672">.</span>left, x, y)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if both `x` and `y` are greater than the root, LCA exists in the right subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">&lt;</span> min(x<span style="color:#f92672">.</span>data, y<span style="color:#f92672">.</span>data):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LCARecursive(root<span style="color:#f92672">.</span>right, x, y)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if one key is greater (or equal) than the root and one key is smaller</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># (or equal) than the root, then the current node is LCA</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Print lowest common ancestor of two nodes in a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">LCA</span>(root, x, y):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return if the tree is empty, or `x` or `y` is not present in the tree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> search(root, x) <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> search(root, y):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># `lca` stores the lowest common ancestor of `x` and `y`</span>
</span></span><span style="display:flex;"><span>    lca <span style="color:#f92672">=</span> LCARecursive(root, x, y)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the lowest common ancestor exists, print it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> lca:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;LCA is&#39;</span>, lca<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#39;LCA does not exist&#39;</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>keys <span style="color:#f92672">=</span> [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">25</span>]
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; Construct the following tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         15
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /  </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">      10     20
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     / \     / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    /   \   /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">   8    12 16   25
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> insert(root, key)
</span></span><span style="display:flex;"><span>LCA(root, root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left, root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right)
</span></span></code></pre></div><h2 id="construct-bst-from-preorder-traversal">Construct BST from preorder traversal<a hidden class="anchor" aria-hidden="true" href="#construct-bst-from-preorder-traversal">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, key, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder</span>(root): 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>key, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to build a BST from a preorder sequence.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># start from the root node (the first element in a preorder sequence)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># set the root node&#39;s range as [-INFINITY, INFINITY]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">buildBST</span>(preorder, pIndex<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, min<span style="color:#f92672">=-</span>sys<span style="color:#f92672">.</span>maxsize, max<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>maxsize):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Base case</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> pIndex <span style="color:#f92672">==</span> len(preorder):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>, pIndex
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Return if the next element of preorder traversal is not in the valid range</span>
</span></span><span style="display:flex;"><span>    val <span style="color:#f92672">=</span> preorder[pIndex]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> val <span style="color:#f92672">&lt;</span> min <span style="color:#f92672">or</span> val <span style="color:#f92672">&gt;</span> max:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>, pIndex
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Construct the root node and increment `pIndex`</span>
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> Node(val)
</span></span><span style="display:flex;"><span>    pIndex <span style="color:#f92672">=</span> pIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Since all elements in the left subtree of a BST must be less</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># than the root node&#39;s value, set range as `[min, val-1]` and recur</span>
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>left, pIndex <span style="color:#f92672">=</span> buildBST(preorder, pIndex, min, val <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Since all elements in the right subtree of a BST must be greater</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># than the root node&#39;s value, set range as `[val+1…max]` and recur</span>
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>right, pIndex <span style="color:#f92672">=</span> buildBST(preorder, pIndex, val <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, max)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root, pIndex
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; Construct the following BST
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          15
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       /      </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">      10       20
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     /  \     /  </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    /    \   /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">   8     12 16    25
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>preorder <span style="color:#f92672">=</span> [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">25</span>]
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> buildBST(preorder)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Inorder traversal of BST is:&#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>inorder(root)
</span></span></code></pre></div><h2 id="convert-binary-tree-into-bst">Convert Binary tree into BST<a hidden class="anchor" aria-hidden="true" href="#convert-binary-tree-into-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to perform inorder traversal on the tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    inorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to traverse the binary tree and store its keys in a set</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">extractKeys</span>(root, keys):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    extractKeys(root<span style="color:#f92672">.</span>left, keys)
</span></span><span style="display:flex;"><span>    keys<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>    extractKeys(root<span style="color:#f92672">.</span>right, keys)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to put keys back into a set in their correct order in a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># by doing inorder traversal</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">convertToBST</span>(root, it):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    convertToBST(root<span style="color:#f92672">.</span>left, it)
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> next(it)
</span></span><span style="display:flex;"><span>    convertToBST(root<span style="color:#f92672">.</span>right, it)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to convert a binary tree to BST by maintaining its original structure</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">convert</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># traverse the binary tree and store its keys in a set</span>
</span></span><span style="display:flex;"><span>    keys <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    extractKeys(root, keys)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># put back keys present in the set to their correct order in the BST</span>
</span></span><span style="display:flex;"><span>    it <span style="color:#f92672">=</span> iter(sorted(keys))
</span></span><span style="display:flex;"><span>    convertToBST(root, it)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Construct the following tree
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        /     </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       3       5
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      / \     / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">     /   \   /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    10    2 4     6
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>convert(root)
</span></span><span style="display:flex;"><span>inorder(root)
</span></span></code></pre></div><h2 id="convert-a-normal-bst-into-a-balanced-bst">Convert a normal BST into a Balanced BST<a hidden class="anchor" aria-hidden="true" href="#convert-a-normal-bst-into-a-balanced-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>: 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to perform the preorder traversal on a BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">preorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to push nodes of a given binary search tree into a</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># list in an inorder fashion</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pushTreeNodes</span>(root, nodes):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    pushTreeNodes(root<span style="color:#f92672">.</span>left, nodes)
</span></span><span style="display:flex;"><span>    nodes<span style="color:#f92672">.</span>append(root)
</span></span><span style="display:flex;"><span>    pushTreeNodes(root<span style="color:#f92672">.</span>right, nodes)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to construct a height-balanced BST from</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># given nodes in sorted order</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">buildBalancedBST</span>(nodes, start, end):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> start <span style="color:#f92672">&gt;</span> end:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># find the middle index</span>
</span></span><span style="display:flex;"><span>    mid <span style="color:#f92672">=</span> (start <span style="color:#f92672">+</span> end) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># The root node will be a node present at the mid-index</span>
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> nodes[mid]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively construct left and right subtree</span>
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> buildBalancedBST(nodes, start, mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> buildBalancedBST(nodes, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, end)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return root node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to construct a height-balanced BST from an unbalanced BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">constructBalancedBST</span>(root):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Push nodes of a given binary search tree into a list in sorted order</span>
</span></span><span style="display:flex;"><span>    nodes <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    pushTreeNodes(root, nodes)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Construct a height-balanced BST from sorted BST nodes</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> buildBalancedBST(nodes, <span style="color:#ae81ff">0</span>, len(nodes) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> constructBalancedBST(root)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Preorder traversal of the constructed BST is &#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>preorder(root)
</span></span></code></pre></div><h2 id="merge-two-bst">Merge two BST<a hidden class="anchor" aria-hidden="true" href="#merge-two-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to push a BST node at the front of a doubly linked list</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">push</span>(root, head):
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> head
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> head:
</span></span><span style="display:flex;"><span>        head<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> head
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to print and count the total number of nodes in a doubly-linked list</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">size</span>(node):
</span></span><span style="display:flex;"><span>    counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> node:
</span></span><span style="display:flex;"><span>        node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>        counter <span style="color:#f92672">=</span> counter <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> counter
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to print preorder traversal of the BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">preorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>data, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    preorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive method to construct a balanced BST from a sorted doubly linked list</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">convertSortedDLLToBalancedBST</span>(head, n):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>, head
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively construct the left subtree</span>
</span></span><span style="display:flex;"><span>    leftSubTree, head <span style="color:#f92672">=</span> convertSortedDLLToBalancedBST(head, n <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># `head` now points to the middle node of the sorted DDL </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># make the middle node of the sorted DDL as the root node of the BST</span>
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> head
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># update left child of the root node</span>
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> leftSubTree
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># update the head reference of the doubly linked list</span>
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively construct the right subtree with the remaining nodes</span>
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">.</span>right, head <span style="color:#f92672">=</span> convertSortedDLLToBalancedBST(head, n <span style="color:#f92672">-</span> (n <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># +1 for the root</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return the root node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root, head
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive method to convert a BST into a doubly-linked list. It takes</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the BST&#39;s root node and the head node of the doubly linked list as an argument</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">convertBSTtoSortedDLL</span>(root, head<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> head
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively convert the right subtree</span>
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> convertBSTtoSortedDLL(root<span style="color:#f92672">.</span>right, head)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># push the current node at the front of the doubly linked list</span>
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> push(root, head)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively convert the left subtree</span>
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> convertBSTtoSortedDLL(root<span style="color:#f92672">.</span>left, head)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> head
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive method to merge two doubly-linked lists into a</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># single doubly linked list in sorted order</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sortedMerge</span>(first, second):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the first list is empty, return the second list</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> first <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> second
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the second list is empty, return the first list</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> second <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> first
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the head node of the first list is smaller</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> first<span style="color:#f92672">.</span>data <span style="color:#f92672">&lt;</span> second<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        first<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> sortedMerge(first<span style="color:#f92672">.</span>right, second)
</span></span><span style="display:flex;"><span>        first<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> first
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> first
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the head node of the second list is smaller</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        second<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> sortedMerge(first, second<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>        second<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> second
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> second
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to merge two balanced BSTs into a single balanced BST</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">merge</span>(first, second):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># merge both BSTs into a sorted doubly linked list</span>
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> sortedMerge(convertBSTtoSortedDLL(first), convertBSTtoSortedDLL(second))
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># construct a balanced BST from a sorted doubly linked list</span>
</span></span><span style="display:flex;"><span>    root, head <span style="color:#f92672">=</span> convertSortedDLLToBalancedBST(head, size(head))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Construct the first BST
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      20
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     /  </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    10  30
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       25 100
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>first <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>first<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>first<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">30</span>)
</span></span><span style="display:flex;"><span>first<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">25</span>)
</span></span><span style="display:flex;"><span>first<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Construct the second BST
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      50
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     /  </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    5   70
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>second <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">50</span>)
</span></span><span style="display:flex;"><span>second<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>second<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">70</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># merge both BSTs</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> merge(first, second)
</span></span><span style="display:flex;"><span>preorder(root)
</span></span></code></pre></div><h2 id="find-kth-largest-element-and-kth-smallest-element-in-a-bst">Find Kth largest element and Kth smallest element in a BST<a hidden class="anchor" aria-hidden="true" href="#find-kth-largest-element-and-kth-smallest-element-in-a-bst">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(root, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Node(key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>right, key)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to find the k&#39;th largest node in a BST. Here, `i` denotes the total number of nodes processed so far</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kthLargest</span>(root, i, k):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>, i
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># search in the right subtree</span>
</span></span><span style="display:flex;"><span>    left, i <span style="color:#f92672">=</span> kthLargest(root<span style="color:#f92672">.</span>right, i, k)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if k&#39;th largest is found in the left subtree, return it</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> left:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> left, i
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the current node is k&#39;th largest, return its value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> k:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root, i
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># otherwise, search in the left subtree</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> kthLargest(root<span style="color:#f92672">.</span>left, i, k)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findKthLargest</span>(root, k):
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># traverse the tree in an inorder fashion and return k&#39;th node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> kthLargest(root, i, k)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kthSmallest</span>(root, counter, k):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>, counter
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    left, counter <span style="color:#f92672">=</span> kthSmallest(root<span style="color:#f92672">.</span>left, counter, k)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if k&#39;th smallest node is found</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> left:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> left, counter
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if the root is k&#39;th smallest node</span>
</span></span><span style="display:flex;"><span>    counter <span style="color:#f92672">=</span> counter <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> counter <span style="color:#f92672">==</span> k:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root, counter
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the right subtree only if k&#39;th smallest node is not found</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># in the right subtree</span>
</span></span><span style="display:flex;"><span>    ret, counter <span style="color:#f92672">=</span> kthSmallest(root<span style="color:#f92672">.</span>right, counter, k)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret, counter
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findKthSmallest</span>(root, k):
</span></span><span style="display:flex;"><span>    counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively find the k&#39;th smallest node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> kthSmallest(root, counter, k)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>keys <span style="color:#f92672">=</span> [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">25</span>]
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> insert(root, key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>k<span style="color:#e6db74">}</span><span style="color:#e6db74">th LARGEST NODE&#34;</span>)  
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> findKthLargest(root, k)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> result <span style="color:#f92672">!=</span> sys<span style="color:#f92672">.</span>maxsize:
</span></span><span style="display:flex;"><span>    print(result<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#39;Invalid Input&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>k <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>k<span style="color:#e6db74">}</span><span style="color:#e6db74">th SMALLEST NODE&#34;</span>)
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> findKthSmallest(root, k)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> result:
</span></span><span style="display:flex;"><span>    print(result<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>k<span style="color:#e6db74">}</span><span style="color:#ae81ff">\&#39;</span><span style="color:#e6db74">th smallest node does not exist.&#39;</span>)
</span></span></code></pre></div><h2 id="count-pairs-from-2-bst-whose-sum-is-equal-to-given-value-x">Count pairs from 2 BST whose sum is equal to given value &ldquo;X&rdquo;<a hidden class="anchor" aria-hidden="true" href="#count-pairs-from-2-bst-whose-sum-is-equal-to-given-value-x">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self,data):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root1,root2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>,<span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># def to count pairs from two BSTs whose sum is equal to a given value x</span>
</span></span><span style="display:flex;"><span>pairCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">traverseTree</span>(root1, root2, sum):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root1 <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">or</span> root2 <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> traverseTree(root1<span style="color:#f92672">.</span>left, root2, sum)
</span></span><span style="display:flex;"><span> traverseTree(root1<span style="color:#f92672">.</span>right, root2, sum)
</span></span><span style="display:flex;"><span> diff <span style="color:#f92672">=</span> sum <span style="color:#f92672">-</span> root1<span style="color:#f92672">.</span>data
</span></span><span style="display:flex;"><span> findPairs(root2, diff)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findPairs</span>(root2 , diff):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> pairCount
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root2 <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (diff <span style="color:#f92672">&gt;</span> root2<span style="color:#f92672">.</span>data) :
</span></span><span style="display:flex;"><span>  findPairs(root2<span style="color:#f92672">.</span>right, diff)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span> :
</span></span><span style="display:flex;"><span>  findPairs(root2<span style="color:#f92672">.</span>left, diff)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (root2<span style="color:#f92672">.</span>data <span style="color:#f92672">==</span> diff):
</span></span><span style="display:flex;"><span>  pairCount <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countPairs</span>(root1, root2, sum):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> pairCount
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> traverseTree(root1, root2, sum)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> pairCount
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root1 <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">5</span>) 
</span></span><span style="display:flex;"><span>root1<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root1<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root1<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root1<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root1<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root1<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># formation of BST 2</span>
</span></span><span style="display:flex;"><span>root2 <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>root2<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root2<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">15</span>)
</span></span><span style="display:flex;"><span>root2<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root2<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>root2<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">11</span>)
</span></span><span style="display:flex;"><span>root2<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">18</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Pairs = </span><span style="color:#e6db74">{</span>countPairs(root1, root2, x)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><h2 id="find-the-median-of-bst-in-on-time-and-o1-space">Find the median of BST in O(n) time and O(1) space<a hidden class="anchor" aria-hidden="true" href="#find-the-median-of-bst-in-on-time-and-o1-space">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>_MIN<span style="color:#f92672">=</span>float(<span style="color:#e6db74">&#39;-inf&#39;</span>)
</span></span><span style="display:flex;"><span>_MAX<span style="color:#f92672">=</span>float(<span style="color:#e6db74">&#39;inf&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Helper function that allocates a new node with the given data and None left and right pointers.         </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function to insert a new node with given key in BST </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(node,key):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> newNode(key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Otherwise, recur down the tree </span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">.</span>data):
</span></span><span style="display:flex;"><span>  node<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">elif</span> (key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">.</span>data):
</span></span><span style="display:flex;"><span>  node<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">.</span>right, key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># return the (unchanged) node pointer </span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> node
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Function to count nodes in a binary search tree using Morris Inorder traversal</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">counNodes</span>(root):
</span></span><span style="display:flex;"><span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> current <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">while</span> (current <span style="color:#f92672">!=</span> <span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> current<span style="color:#f92672">.</span>left <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Count node if its left is None</span>
</span></span><span style="display:flex;"><span>   count<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Move to its right</span>
</span></span><span style="display:flex;"><span>   current <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>: 
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Find the inorder predecessor of current </span>
</span></span><span style="display:flex;"><span>   pre <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">while</span> pre<span style="color:#f92672">.</span>right <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> [<span style="color:#66d9ef">None</span>, current]:
</span></span><span style="display:flex;"><span>    pre <span style="color:#f92672">=</span> pre<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">#Make current as right child of its inorder predecessor </span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> pre<span style="color:#f92672">.</span>right <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    pre<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> current
</span></span><span style="display:flex;"><span>    current <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    pre<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Increment count if the current node is to be visited</span>
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    current <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> count
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMedian</span>(root):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> count <span style="color:#f92672">=</span> counNodes(root)
</span></span><span style="display:flex;"><span> currCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> current <span style="color:#f92672">=</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">while</span> (current <span style="color:#f92672">!=</span> <span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> current<span style="color:#f92672">.</span>left <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># count current node</span>
</span></span><span style="display:flex;"><span>   currCount <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># check if current node is the median</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Odd case</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>    currCount <span style="color:#f92672">==</span> (count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> prev<span style="color:#f92672">.</span>data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Even case</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">elif</span> (count <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>     currCount <span style="color:#f92672">==</span> (count<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (prev<span style="color:#f92672">.</span>data <span style="color:#f92672">+</span> current<span style="color:#f92672">.</span>data)<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Update prev for even no. of nodes</span>
</span></span><span style="display:flex;"><span>   prev <span style="color:#f92672">=</span> current
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">#Move to the right</span>
</span></span><span style="display:flex;"><span>   current <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Find the inorder predecessor of current </span>
</span></span><span style="display:flex;"><span>   pre <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">while</span> pre<span style="color:#f92672">.</span>right <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> [<span style="color:#66d9ef">None</span>, current]:
</span></span><span style="display:flex;"><span>    pre <span style="color:#f92672">=</span> pre<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># Make current as right child of its inorder predecessor </span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> pre<span style="color:#f92672">.</span>right <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pre<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> current
</span></span><span style="display:flex;"><span>    current <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span>left
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pre<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> pre
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Count current node</span>
</span></span><span style="display:flex;"><span>    currCount<span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Check if the current node is the median</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>     currCount <span style="color:#f92672">==</span> (count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> ):
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> current<span style="color:#f92672">.</span>data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> (count<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>     currCount <span style="color:#f92672">==</span> (count <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> (prev<span style="color:#f92672">.</span>data<span style="color:#f92672">+</span>current<span style="color:#f92672">.</span>data)<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># update prev node for the case of even</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># no. of nodes</span>
</span></span><span style="display:flex;"><span>    prev <span style="color:#f92672">=</span> current
</span></span><span style="display:flex;"><span>    current <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Constructed binary tree is
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 50
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    30 70
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    / \ / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    20 40 60 80
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">50</span>)
</span></span><span style="display:flex;"><span>insert(root, <span style="color:#ae81ff">30</span>)
</span></span><span style="display:flex;"><span>insert(root, <span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>insert(root, <span style="color:#ae81ff">40</span>)
</span></span><span style="display:flex;"><span>insert(root, <span style="color:#ae81ff">70</span>)
</span></span><span style="display:flex;"><span>insert(root, <span style="color:#ae81ff">60</span>)
</span></span><span style="display:flex;"><span>insert(root, <span style="color:#ae81ff">80</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Median of BST is &#34;</span>,findMedian(root))
</span></span></code></pre></div><h2 id="count-bst-nodes-that-lie-in-a-given-range">Count BST nodes that lie in a given range<a hidden class="anchor" aria-hidden="true" href="#count-bst-nodes-that-lie-in-a-given-range">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, data, left<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, right<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(root, key):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Node(key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> key <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>left, key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(root<span style="color:#f92672">.</span>right, key)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countNodes</span>(root, low, high):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># keep track of the total number of nodes in the tree rooted with `root`.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># that lies within the current range [low, high]</span>
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># increment count if the current node lies within the current range</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> low <span style="color:#f92672">&lt;=</span> root<span style="color:#f92672">.</span>data <span style="color:#f92672">&lt;=</span> high:
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the left subtree</span>
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">+=</span> countNodes(root<span style="color:#f92672">.</span>left, low, high)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recur for the right subtree and return the total count</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> count <span style="color:#f92672">+</span> countNodes(root<span style="color:#f92672">.</span>right, low, high)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>low, high <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>keys <span style="color:#f92672">=</span> [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">22</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">6</span>]
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> key <span style="color:#f92672">in</span> keys:
</span></span><span style="display:flex;"><span>    root <span style="color:#f92672">=</span> insert(root, key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;The total number of nodes is&#39;</span>, countNodes(root, low, high))
</span></span></code></pre></div><h2 id="replace-every-element-with-the-least-greater-element-on-its-right">Replace every element with the least greater element on its right<a hidden class="anchor" aria-hidden="true" href="#replace-every-element-with-the-least-greater-element-on-its-right">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34; 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given an array of integers, replace every element with the least greater element on its right side in the array. If there are no greater elements on the right side, replace it with -1.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Examples: 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: [8, 58, 71, 18, 31, 32, 63, 92, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         43, 3, 91, 93, 25, 80, 28]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: [18, 63, 80, 25, 32, 43, 80, 93, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         80, 25, 93, -1, 28, -1, -1]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>: 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, d):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> d
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function to insert a new node with given data in BST and find its successor</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(node, data): 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> succ
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># If the tree is empty, return a new node</span>
</span></span><span style="display:flex;"><span> root <span style="color:#f92672">=</span> node
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Node(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># If key is smaller than root&#39;s key, go to left subtree and set successor as current node</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (data <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">.</span>data):
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#print(&#34;1&#34;)</span>
</span></span><span style="display:flex;"><span>  succ <span style="color:#f92672">=</span> node
</span></span><span style="display:flex;"><span>  root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">.</span>left, data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Go to right subtree</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">elif</span> (data <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">.</span>data):
</span></span><span style="display:flex;"><span>  root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">.</span>right, data)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to replace every element with the least greater element on its right</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">replace</span>(arr, n):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> succ
</span></span><span style="display:flex;"><span> root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Start from right to left</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>  succ <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Insert current element into BST and find its inorder successor</span>
</span></span><span style="display:flex;"><span>  root <span style="color:#f92672">=</span> insert(root, arr[i])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Replace element by its inorder successor in BST</span>
</span></span><span style="display:flex;"><span>  arr[i] <span style="color:#f92672">=</span> succ<span style="color:#f92672">.</span>data <span style="color:#66d9ef">if</span> succ <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> arr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">=</span> [ <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">58</span>, <span style="color:#ae81ff">71</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">63</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">92</span>, <span style="color:#ae81ff">43</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">91</span>, <span style="color:#ae81ff">93</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">80</span>, <span style="color:#ae81ff">28</span> ]
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> len(arr)
</span></span><span style="display:flex;"><span>succ <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">=</span> replace(arr, n)
</span></span><span style="display:flex;"><span>print(<span style="color:#f92672">*</span>arr)
</span></span></code></pre></div><h2 id="given-n-appointments-find-the-conflicting-appointments">Given &ldquo;n&rdquo; appointments, find the conflicting appointments<a hidden class="anchor" aria-hidden="true" href="#given-n-appointments-find-the-conflicting-appointments">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input: appointments[] = { {1, 5} {3, 7}, {2, 6}, {10, 15}, {5, 6}, {4, 100}}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output: Following are conflicting intervals
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[3,7] Conflicts with [1,5]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[2,6] Conflicts with [1,5]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[5,6] Conflicts with [3,7]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[4,100] Conflicts with [1,5]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Interval</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>low <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>high <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Structure to represent a node in Interval Search Tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ITNode</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>max <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>i <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">newNode</span>(j):
</span></span><span style="display:flex;"><span> <span style="color:#75715e">#print(j)</span>
</span></span><span style="display:flex;"><span> temp <span style="color:#f92672">=</span> ITNode()
</span></span><span style="display:flex;"><span> temp<span style="color:#f92672">.</span>i <span style="color:#f92672">=</span> j
</span></span><span style="display:flex;"><span> temp<span style="color:#f92672">.</span>max <span style="color:#f92672">=</span> j[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function to check if given two intervals overlap</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">doOVerlap</span>(i1, i2):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (i1[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> i2[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> i2[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> i1[<span style="color:#ae81ff">1</span>]):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to create a new node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(node, data):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> succ
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># If the tree is empty, return a new node</span>
</span></span><span style="display:flex;"><span> root <span style="color:#f92672">=</span> node
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> newNode(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># If key is smaller than root&#39;s key, go to left subtree and set successor as current node print(node)</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (data[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">.</span>i[<span style="color:#ae81ff">0</span>]):
</span></span><span style="display:flex;"><span>  root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">.</span>left, data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Go to right subtree</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>  root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">.</span>right, data)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>max <span style="color:#f92672">&lt;</span> data[<span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>  root<span style="color:#f92672">.</span>max <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The main function that searches a given interval i in a given Interval Tree.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">overlapSearch</span>(root, i):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># If given interval overlaps with root</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (doOVerlap(root<span style="color:#f92672">.</span>i, i)):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> root<span style="color:#f92672">.</span>i
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># If left child of root is present and max of left child is greater than or</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># equal to given interval, then i may overlap with an interval is left subtree</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">.</span>left <span style="color:#f92672">!=</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>max <span style="color:#f92672">&gt;=</span> i[<span style="color:#ae81ff">0</span>]):
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> overlapSearch(root<span style="color:#f92672">.</span>left, i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Else interval can only overlap with right subtree</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> overlapSearch(root<span style="color:#f92672">.</span>right, i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This function prints all conflicting appointments in a given array of appointments.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printConflicting</span>(appt, n):
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Create an empty Interval Search Tree, add first appointment</span>
</span></span><span style="display:flex;"><span> root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span> root <span style="color:#f92672">=</span> insert(root, appt[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Process rest of the intervals</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># If current appointment conflicts with any of the existing intervals, print it</span>
</span></span><span style="display:flex;"><span>  res <span style="color:#f92672">=</span> overlapSearch(root, appt[i])
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">!=</span> <span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>   print(<span style="color:#e6db74">&#34;[&#34;</span>, appt[i][<span style="color:#ae81ff">0</span>], <span style="color:#e6db74">&#34;,&#34;</span>, appt[i][<span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;] Conflicts with [&#34;</span>, res[<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;,&#34;</span>, res[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;]&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Insert this appointment</span>
</span></span><span style="display:flex;"><span>  root <span style="color:#f92672">=</span> insert(root, appt[i])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>appt <span style="color:#f92672">=</span> [ [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span> ], [ <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span> ],
</span></span><span style="display:flex;"><span>  [ <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span> ], [ <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">15</span> ],
</span></span><span style="display:flex;"><span>  [ <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span> ], [ <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">100</span> ] 
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> len(appt)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Following are conflicting intervals&#34;</span>)
</span></span><span style="display:flex;"><span>printConflicting(appt, n)
</span></span></code></pre></div><h2 id="preorder-to-postorder">Preorder to Postorder<a hidden class="anchor" aria-hidden="true" href="#preorder-to-postorder">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#  A class to store a binary tree node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, key):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">postorder</span>(root):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    postorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span>    postorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>    print(root<span style="color:#f92672">.</span>key, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Recursive function to build a BST from a preorder sequence.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">constructBST</span>(preorder, start, end):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># base case</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> start <span style="color:#f92672">&gt;</span> end:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Construct the root node of the subtree formed by keys of the</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># preorder sequence in range `[start, end]`</span>
</span></span><span style="display:flex;"><span>    node <span style="color:#f92672">=</span> Node(preorder[start])
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># search the index of the first element in the current range of preorder</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># sequence larger than the root node&#39;s value</span>
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> start
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;=</span> end:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> preorder[i] <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">.</span>key:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively construct the left subtree</span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> constructBST(preorder, start <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># recursively construct the right subtree</span>
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> constructBST(preorder, i, end)
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># return current node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> node
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39; 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Construct the following BST
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          15
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">       /      </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">      10       20
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     /  \     /  </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">    /    \   /    </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">   8     12 16    25
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>preorder <span style="color:#f92672">=</span> [<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">25</span>]
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> constructBST(preorder, <span style="color:#ae81ff">0</span>, len(preorder) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Postorder traversal of BST is &#39;</span>, end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span>)
</span></span><span style="display:flex;"><span>postorder(root)
</span></span></code></pre></div><h2 id="check-whether-bst-contains-dead-end">Check whether BST contains Dead end<a hidden class="anchor" aria-hidden="true" href="#check-whether-bst-contains-dead-end">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Given a Binary search Tree that contains positive integer values greater than 0. The task is to check whether the BST contains a dead end or not. Here Dead End means, we are not able to insert any element after that node.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Examples:  
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input :        8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             /   \ 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           5      9
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        2     7
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">       /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      1               
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : Yes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation : Node &#34;1&#34; is the dead End because after that we cant insert any element.       
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Input :       8
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /   \ 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           7     10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         /      /   </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">        2      9     13
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Output : Yes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Explanation : We can&#39;t insert any element at node 9.  
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>all_nodes <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>leaf_nodes <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A BST node</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A utility function to insert a new Node with given key in BST </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(node, key):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> node <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> newNode(key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Otherwise, recur down the tree</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&lt;</span> node<span style="color:#f92672">.</span>data):
</span></span><span style="display:flex;"><span>  node<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">.</span>left,
</span></span><span style="display:flex;"><span>      key)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">elif</span> (key <span style="color:#f92672">&gt;</span> node<span style="color:#f92672">.</span>data):
</span></span><span style="display:flex;"><span>  node<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> insert(node<span style="color:#f92672">.</span>right,
</span></span><span style="display:flex;"><span>       key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># return the (unchanged) Node pointer</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> node
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to store all node of given binary search tree</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">storeNodes</span>(root):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> all_nodes
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> leaf_nodes
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># store all node of binary search tree</span>
</span></span><span style="display:flex;"><span> all_nodes<span style="color:#f92672">.</span>add(root<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># store leaf node in leaf_hash</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>left <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  leaf_nodes<span style="color:#f92672">.</span>add(root<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># recur call rest tree</span>
</span></span><span style="display:flex;"><span> storeNodes(root<span style="color:#f92672">.</span> left)
</span></span><span style="display:flex;"><span> storeNodes(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Returns true if there is a dead end in tree, else false.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isDeadEnd</span>(root):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> all_nodes
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> leaf_nodes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># create two empty hash sets that store all BST elements and leaf nodes respectively.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># insert 0 in &#39;all_nodes&#39; for handle case if bst contain value 1</span>
</span></span><span style="display:flex;"><span> all_nodes<span style="color:#f92672">.</span>add(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Call storeNodes function to store all BST Node</span>
</span></span><span style="display:flex;"><span> storeNodes(root)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> any(((x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">in</span> all_nodes <span style="color:#f92672">and</span> (x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">in</span> all_nodes) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> leaf_nodes)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> insert(root, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> insert(root, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> insert(root, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> insert(root, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> insert(root, <span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> insert(root, <span style="color:#ae81ff">11</span>)
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> insert(root, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(isDeadEnd(root) <span style="color:#f92672">==</span> <span style="color:#66d9ef">True</span>):
</span></span><span style="display:flex;"><span> print(<span style="color:#e6db74">&#34;Yes&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span> print(<span style="color:#e6db74">&#34;No&#34;</span>)
</span></span></code></pre></div><h2 id="largest-bst-in-a-binary-tree">Largest BST in a Binary Tree<a hidden class="anchor" aria-hidden="true" href="#largest-bst-in-a-binary-tree">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>sys<span style="color:#f92672">.</span>setrecursionlimit(<span style="color:#ae81ff">1000000</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>IMIN <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#39;-inf&#39;</span>)
</span></span><span style="display:flex;"><span>IMAX <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#39;inf&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">newNode</span>:
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, val):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> val
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">largestBst</span>(root):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> IMAX,IMIN,<span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>left <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">and</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> root<span style="color:#f92672">.</span>data,root<span style="color:#f92672">.</span>data,<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> left<span style="color:#f92672">=</span>largestBst(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span> right<span style="color:#f92672">=</span>largestBst(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> ans<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> left[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">&lt;</span>root<span style="color:#f92672">.</span>data <span style="color:#f92672">and</span> right[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&gt;</span>root<span style="color:#f92672">.</span>data:
</span></span><span style="display:flex;"><span>  ans[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>min(left[<span style="color:#ae81ff">0</span>],right[<span style="color:#ae81ff">0</span>],root<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>  ans[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>max(right[<span style="color:#ae81ff">1</span>],left[<span style="color:#ae81ff">1</span>],root<span style="color:#f92672">.</span>data)
</span></span><span style="display:flex;"><span>  ans[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>left[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span>right[<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ans
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> ans[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>IMIN
</span></span><span style="display:flex;"><span> ans[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>IMAX
</span></span><span style="display:flex;"><span> ans[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">=</span>max(left[<span style="color:#ae81ff">2</span>],right[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> ans[<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> 50
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> / </span><span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#e6db74">  75  45
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> /
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">40 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">50</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">75</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">45</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> newNode(<span style="color:#ae81ff">40</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Size of the largest BST is&#34;</span>,largestBst(root))
</span></span></code></pre></div><h2 id="flatten-bst-to-sorted-list">Flatten BST to sorted list<a hidden class="anchor" aria-hidden="true" href="#flatten-bst-to-sorted-list">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">global</span> prev
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">node</span> :
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">def</span> __init__(self, data):
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>  self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">printTree</span>(parent):
</span></span><span style="display:flex;"><span> root <span style="color:#f92672">=</span> parent
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">while</span> root <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  print(root<span style="color:#f92672">.</span>data,end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span>  root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">inorder</span>(root):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> prev
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> root <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span> inorder(root<span style="color:#f92672">.</span>left)
</span></span><span style="display:flex;"><span> print(root<span style="color:#f92672">.</span>data,end<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span> inorder(root<span style="color:#f92672">.</span>right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Function to flatten binary tree using level order traversal BFS</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">flatten</span>(parent):
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">global</span> prev
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Dummy node</span>
</span></span><span style="display:flex;"><span> dummy <span style="color:#f92672">=</span> node(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Pointer to previous element</span>
</span></span><span style="display:flex;"><span> prev <span style="color:#f92672">=</span> dummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Calling in-order traversal</span>
</span></span><span style="display:flex;"><span> inorder(parent)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> prev<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span> prev<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e"># Delete dummy node</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> dummy<span style="color:#f92672">.</span>right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">7</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span>root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> node(<span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>printTree(flatten(root))
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://atharvashah.netlify.app/tags/dsa-python/">DSA-Python</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://atharvashah.netlify.app/blog/dsapython/string/">
    <span class="title">« Prev</span>
    <br>
    <span>DSA in Python - Strings</span>
  </a>
  <a class="next" href="https://atharvashah.netlify.app/blog/dsapython/binary-tree/">
    <span class="title">Next »</span>
    <br>
    <span>DSA in Python - Binary Trees</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Search Trees on twitter"
        href="https://twitter.com/intent/tweet/?text=DSA%20in%20Python%20-%20Binary%20Search%20Trees&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-search-tree%2f&amp;hashtags=DSA-Python">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Search Trees on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-search-tree%2f&amp;title=DSA%20in%20Python%20-%20Binary%20Search%20Trees&amp;summary=DSA%20in%20Python%20-%20Binary%20Search%20Trees&amp;source=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-search-tree%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Search Trees on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-search-tree%2f&title=DSA%20in%20Python%20-%20Binary%20Search%20Trees">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Search Trees on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-search-tree%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Search Trees on whatsapp"
        href="https://api.whatsapp.com/send?text=DSA%20in%20Python%20-%20Binary%20Search%20Trees%20-%20https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-search-tree%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share DSA in Python - Binary Search Trees on telegram"
        href="https://telegram.me/share/url?text=DSA%20in%20Python%20-%20Binary%20Search%20Trees&amp;url=https%3a%2f%2fatharvashah.netlify.app%2fblog%2fdsapython%2fbinary-search-tree%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "https-atharvashah-netlify-app" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    (function() {
        
        
        if (window.location.hostname == "localhost")
            return;

        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        var disqus_shortname = 'https-atharvashah-netlify-app';
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://atharvashah.netlify.app/">Atharva Shah</a></span> 
    | <span><a href="/privacy-policy/" target="_blank">Privacy Policy</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function() {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function(e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function() {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {};
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
