[{"content":" Introduction Brief overview of accelerationism The advent of AI and its impact on society Theories of Accelerationism Historical context of accelerationism Left and right-wing accelerationism Critiques of accelerationism AI and the Future of Society Advancements in AI technology Potential consequences of widespread AI integration Ethical considerations of AI development Accelerationism and Transhumanism: A Complex Intersection The intersection of accelerationism and transhumanism Potential benefits and drawbacks of merging technology with humanity Final thoughts on the Post-AI Society Introduction Yo, what\u0026rsquo;s good, internet? Welcome to my blog post about the wild, wild world of accelerationism. Now, I know some of you might be thinking, \u0026ldquo;Ugh, another boring article about some fancy words I don\u0026rsquo;t understand?\u0026rdquo; But hear me out, fam. This stuff is actually pretty cool, I promise.\nBrief overview of accelerationism Now, I know some of you might be thinking, \u0026ldquo;But wait, I thought accelerationism was just a fancy way of saying \u0026rsquo;let\u0026rsquo;s go faster\u0026rsquo;?\u0026rdquo; And you\u0026rsquo;d be right, my dear Watson. But it\u0026rsquo;s so much more than that. It\u0026rsquo;s about taking things to the next level, pushing boundaries, and making things happen faster than ever before. It\u0026rsquo;s like that meme where the guy is running down the street with his arms out and the caption says, \u0026ldquo;I\u0026rsquo;m living my best life.\u0026rdquo; That\u0026rsquo;s what accelerationism is all about.\nBut enough about the boring stuff, let\u0026rsquo;s talk about the good stuff. Imagine being able to download all the books in the world into your brain, or having a robotic arm that can lift a car. It\u0026rsquo;s like having your own personal Ironman suit, except without the annoying AI assistant. Or, if you\u0026rsquo;re more of a \u0026ldquo;Ghost in the Shell\u0026rdquo; type, you could have a robotic body that can run faster than Usain Bolt. The possibilities are endless, my friends.\nThe advent of AI and its impact on society Accelerationism, the belief that society should actively accelerate the pace of technological progress in order to bring about a desired outcome, has gained increasing attention in recent years. With the advent of AI and its potential to drastically alter the course of human civilization, the concept of accelerationism has become increasingly relevant. Whether we should actively push for the development of AI and other technologies, and the implications of such actions, is one that demands attention.\nSo, without further ado, let\u0026rsquo;s dive in and talk about the future of human society with the advent of AI. Just remember, as always, to keep an open mind and be ready for the unexpected. We\u0026rsquo;ll be gazing into the abyss and examining theories of accelerationism, the current state and future possibilities of AI, and the intersection of accelerationism and transhumanism. We will examine the potential consequences of widespread AI integration and discuss the ethical considerations of AI development. Our goal is to provide a comprehensive understanding of the complex and nuanced topic of accelerationism and its relationship to the future of human society. We will explore the potential benefits and drawbacks of accelerating technological progress and the impact it could have on humanity\u0026rsquo;s future.\nTL;DR: Introduction to accelerationism, where we\u0026rsquo;re going faster and stronger with AI technology and the future of human society\nTheories of Accelerationism Historical context of accelerationism The idea of accelerationism can be traced back to the 19th century, with thinkers such as Friedrich Nietzsche and Henri de Saint-Simon proposing the acceleration of technological progress as a means to bring about societal change. However, it wasn\u0026rsquo;t until the 1960s and 1970s that the term \u0026ldquo;accelerationism\u0026rdquo; was first coined, with the publication of books like \u0026ldquo;The Acceleration of History\u0026rdquo; by John Zerzan and \u0026ldquo;The Acceleration of Change\u0026rdquo; by Brian Pearce.\nLeft and right-wing accelerationism Accelerationism can be broken down into two main branches: left-wing and right-wing. Left-wing accelerationism, also known as \u0026ldquo;progressive accelerationism,\u0026rdquo; argues that accelerating technological progress will ultimately lead to a more equitable and just society. This branch of accelerationism is often associated with Marxist and socialist ideologies. On the other hand, right-wing accelerationism, also known as \u0026ldquo;neoliberal accelerationism,\u0026rdquo; argues that accelerating technological progress will lead to a more efficient and capitalist society. This branch of accelerationism is often associated with libertarian and capitalist ideologies.\nCritiques of accelerationism Accelerationism has not been without its critics. Some argue that accelerationism ignores the potential negative consequences of rapidly advancing technology, such as increased inequality and loss of privacy. Others argue that accelerationism is too optimistic about the ability of technology to solve societal problems and that it ignores the need for structural changes in society. Additionally, some argue that accelerationism is a form of technofascism, in which technology is used as a means of control and oppression. It\u0026rsquo;s important to note that critiques of accelerationism come from both the left and right wings, and the topic is complex and requires deeper understanding.\nAI and the Future of Society Advancements in AI technology The field of artificial intelligence has seen incredible advancements in recent years, and the potential of AI to revolutionize various industries and improve our daily lives is astounding. From self-driving cars to intelligent virtual assistants, AI technology is already being integrated into many aspects of our lives. Advancements in machine learning and deep learning have also led to the creation of AI systems that can perform tasks that were previously thought to be the exclusive domain of humans, such as image and speech recognition. With these advancements, the capabilities of AI are only set to increase in the future, and the possibilities for what AI can achieve are endless.\nPotential consequences of widespread AI integration As we continue to push the boundaries of what is possible with AI, it is important to consider the potential consequences of widespread AI integration. One of the most commonly discussed potential consequences is the potential loss of jobs, as many tasks that are currently performed by humans may be automated in the future. However, it\u0026rsquo;s also possible that the integration of AI technology could lead to the creation of new jobs, as well as increased efficiency and productivity across various industries. Additionally, AI can also help to address some of the world\u0026rsquo;s most pressing issues, such as climate change and healthcare.\nEthical considerations of AI development As we continue to develop AI technology, it is crucial that we consider the ethical implications of its integration into society. One of the most pressing ethical considerations is the issue of bias in AI, as AI systems can inadvertently perpetuate societal biases and discrimination. It\u0026rsquo;s also important to consider the issue of transparency, as the inner workings of many AI systems are complex and difficult to understand. Additionally, we must consider the issue of accountability, as AI systems can make decisions that have significant impacts on individuals and society as a whole.\nIn conclusion, while there are certainly challenges to be faced in the integration of AI into society, the potential benefits are immense. With careful consideration of the ethical implications of AI development, we can work towards a future in which AI technology is used to improve the lives of all individuals and to address some of the world\u0026rsquo;s most pressing issues. And as we progress, we can have a positive, hopeful, and inspiring future for the human society.\nAccelerationism and Transhumanism: A Complex Intersection The intersection of accelerationism and transhumanism Accelerationism and transhumanism are both ideologies that seek to push the boundaries of what is possible with technology, but they differ in their ultimate goals. Accelerationism is primarily focused on using technology to accelerate societal change, while transhumanism is focused on using technology to enhance and transcend human capabilities. However, the two ideologies intersect in their shared belief that technology can be used to improve the human condition.\nWhen examining the intersection of accelerationism and transhumanism, it\u0026rsquo;s important to consider the potential benefits and drawbacks of merging technology with humanity. The merging of technology and humanity has the potential to bring about numerous benefits, such as an increased lifespan, enhanced physical and cognitive capabilities, and an improved overall quality of life. However, there are also potential drawbacks. One of the most significant concerns is the potential for inequality, as access to these technologies may not be evenly distributed among the population. Additionally, there are also concerns about the potential for unintended consequences, as the merging of technology and humanity could lead to unforeseen ethical dilemmas. Furthermore, the idea of merging technology with humanity raises the question of what it means to be human and what the implications are for human identity and agency.\nPotential benefits and drawbacks of merging technology with humanity It\u0026rsquo;s crucial to engage in a critical and nuanced examination of the intersection of accelerationism and transhumanism. This includes considering the ethical and societal implications of these technologies and ensuring that they are developed and used responsibly. It\u0026rsquo;s also important to consider the long-term impact of these technologies on human society and humanity as a whole. As such, it\u0026rsquo;s important to approach the intersection of accelerationism and transhumanism with a balanced perspective, considering both the potential benefits and drawbacks, and taking a proactive stance to minimize any negative impacts.\nIn conclusion, the intersection of accelerationism and transhumanism is a complex topic that requires a multidisciplinary approach. This includes considering the potential benefits and drawbacks, and taking a proactive stance to minimize any negative impacts. It\u0026rsquo;s important to approach this intersection with a balanced perspective and a deep understanding of the implications for the future of humanity.\nFinal thoughts on the Post-AI Society Alright folks, it\u0026rsquo;s time to end this rant. I know, I know, it all sounds like a bunch of fancy words that you\u0026rsquo;d only hear in a sci-fi movie. But hear me out, because this stuff is actually pretty important.\nFirst off, let\u0026rsquo;s break it down. Accelerationism is all about making things happen faster, and transhumanism is all about merging technology with humans. Put those two together, and you get a bunch of people talking about how we should all be cyborgs by now.\nNow, I know some of you are thinking, \u0026ldquo;Oh great, just what we need—more robots taking our jobs,\u0026rdquo; but hear me out. There are definitely some benefits to all this techy stuff. Imagine being able to download all the books in the world into your brain, or having a robotic arm that can lift a car. It\u0026rsquo;s like having your own personal Ironman suit, except without the annoying AI assistant.\nBut with all the benefits come some potential drawbacks. We\u0026rsquo;ve all seen the movies like \u0026ldquo;Blade Runner\u0026rdquo; or \u0026ldquo;Ex Machina\u0026rdquo; and we know how things can turn out if we\u0026rsquo;re not careful. It\u0026rsquo;s important that we consider the ethical implications of all this tech before we go full steam ahead.\nSo in conclusion, let\u0026rsquo;s not get too caught up in the hype. Sure, having a robotic arm would be pretty cool, but let\u0026rsquo;s make sure we\u0026rsquo;re doing it for the right reasons. And if you do end up with a robotic arm, please, for the love of god, don\u0026rsquo;t use it to hack the Pentagon.\nTL;DR: accelerationism and transhumanism are important topics to consider, but let\u0026rsquo;s be careful with how we implement it and not get too caught up in the hype.\n","permalink":"https://atharvashah.netlify.app/blog/effective-accelerationism/","summary":"Introduction Brief overview of accelerationism The advent of AI and its impact on society Theories of Accelerationism Historical context of accelerationism Left and right-wing accelerationism Critiques of accelerationism AI and the Future of Society Advancements in AI technology Potential consequences of widespread AI integration Ethical considerations of AI development Accelerationism and Transhumanism: A Complex Intersection The intersection of accelerationism and transhumanism Potential benefits and drawbacks of merging technology with humanity Final thoughts on the Post-AI Society Introduction Yo, what\u0026rsquo;s good, internet?","title":"Accelerating into the Future: An Exploration of Effective Accelerationism and its Impact on AI and Society"},{"content":"Winning a hackathon is an incredible feeling, and it\u0026rsquo;s even more special when it\u0026rsquo;s your very first one. The adrenaline rush of competing against some of the brightest minds in the industry, the satisfaction of solving complex problems, and the thrill of being recognized for your hard work are all emotions that are hard to put into words. In this article, I\u0026rsquo;ll walk you through the journey of our team who recently won their first ever hackathon, the CRIF Hackathon 2023. From the initial idea to the final presentation, we\u0026rsquo;ll explore the ups and downs of the experience, and the valuable lessons that were learned along the way. So join us as we relive the excitement of a hackathon victory, and learn what it takes to come out on top.\nWant to jump right into the code? Check out the GitHub repo.\nProblem Statement We were give five problem statements to choose from. The first one was to build a framework/utility that takes a company name as an input. The utility should search all the media articles about the input company and present any reputational threatening data on a concise dashboard. With the help of NLP, we were able to build a framework that could scrape news articles from search engines like Google, Yahoo, Duckduckgo and present any reputational threatening data on a concise dashboard.\nYou can read more about other problem statements here.\nMedia Analytics Build a framework/utility that takes a company name as an input. The utility should search all the media articles about the input company and present any reputational threatening data on a concise dashboard.\nFollowing are the functionalities that need to be achieved in order to build a complete solution -\nDownloader - Download news articles using company name from search engines (Google, Yahoo, Duckduckgo) - Selenium, News API\nNER module - Named Entity Recognition (Organization + Risk Entity) - Out of the box Spacy NLP models / Taxonomy searches\nRelationship module - Analyze the articles and carve out sentences(context) where reputation risk elements and company names are present. Can use dependency parsing or predicate classifiers to establish relationships between risk elements and company names\nDashboard - Display these relationships in an appropriate Dashboard ⇒ PowerBI / Tableau\nTeam Atharva Shah (Yours Truly) - Implementation of the first three modules leveraging NLP, Text Processing, Web Scraping and Debugging. In-charge of leading the team and making the presentation in the final round\nGurjas Gandhi - Administration, Management, Insightful Feedback\nAli Asger Saifee - Problem-Solving, Curating Word Lists and Generating Tableau Dashboards\nAditya Patil - Documentation, Testing and Generating Tableau Dashboards\nThe Team (Code Giants) L to R: Gurjas, Aditya, Ali and Atharva 24-Hour Code Sprint Since the project heavily relies on Web Scraping, Text Processing, NLP and Data Analysis using Python was an obvious choice for it.\nHaving prior experience with BeautifulSoup, APIs and Spacy for NLP I immediately got to work and got the first two modules up and running within the first few hours of the hackathon.\nNewsAPI - Scraping the latest and relevant news about an organization based on the input query\nRegex, BeautifulSoup, Trifulatura - To parse the main content from the webpages and discard irrelevant data. Cleaning up news articles.\nTensorflow - Sentiment Analysis (returning a logit score between 1 to 5)\nSpacy - pre-trained roBERta model for improving sentiment analysis and tagging of Named Entity Relationships\nCustom Word Stores - to employ a \u0026ldquo;weighted list\u0026rdquo; score system based on the word count of negative and offensive words. Three other lists (harassment.txt, countries.txt, lawsuits.txt) were used to tag the articles if repeated words related to it were detected.\nProcessing CSVs - A lot of file handling was performed. The pipeline consisted of 3 CSVs.\nCommon.csv that simply stores the scraped articles Common-processed.csv that performs sentiment analysis on headline and stores the tags, offensive/negative words with the score based on the SpaCy NER module Common-Analysis.csv that used pandas to join all the fields together and prepare a final CSV for automating the Tableau dashboard. Spent the most time with this. Most CSVs that made the final\nCustom CLI Tool to Scrape Relevant News Articles based on user input Sanitization, cleanup and pre-processing with Sentiment Analysis being written to CSV files Named Entity Relationship Mapping with DisplaCy Tableau - Taking input of the COMMON-ANALYSIS.csv file, we designed 8 dashboards to present or narrate a story with all our data. Since we had plenty of fields like Article Count, Title,Description, Content (which holds the entire article text), URL, Publisher, Published Date, Headline, Headline Sentiment, Offensive Rating, Negative Words, Offensive Words and Tags it was not much of a hassle. We made good use of several plotting and graphing methods and presented a diverse yet insightful story. Each Tableau report updates after looking up a new organization.\nTableau Dashboard #1 Tableau Dashboard #2 Tableau Dashboard #3 Tableau Dashboard #4 Tableau Dashboard #5 Tableau Dashboard #6 Tableau Dashboard #7 Tableau Dashboard #8 Obstacles, Setbacks and Challenges faced Cleaning up the article body and parsing proper text.\nExtrapolating the context to base the negative score on.\nOptimizing NLP processing and reducing the scraping time.\nTableau was a completely new tool for us, nonetheless we took a 2-hour crash course and got our hands dirty thanks to which we could quickly get ahead of the game and visualize our gathered data seamlessly.\nHandling exceptions, 403, 404, Date Parsing, Tagging and taking care of API throttling.\nModule 3 felt to be the most challenging since we had to add our own \u0026ldquo;risk-entity\u0026rdquo; NER support to the SpaCy \u0026ldquo;roBERTa\u0026rdquo; model while also not losing application efficiency.\nRewards We worked around the clock in an organized manner and secured the first rank competing against 36 other teams (nearly 140+ participants). All the effort paid off at the end as we secured the first position after an exhaustive and interview-based project presentation with the panel of judges.\nWith the prestige and recognition we also received:-\n50K Cash Prize Goodies for each team member Victory Certificate for each team member A \u0026ldquo;winner takes it all\u0026rdquo; trophy The taste of victory ","permalink":"https://atharvashah.netlify.app/blog/crif-hackathon-2023/","summary":"Winning a hackathon is an incredible feeling, and it\u0026rsquo;s even more special when it\u0026rsquo;s your very first one. The adrenaline rush of competing against some of the brightest minds in the industry, the satisfaction of solving complex problems, and the thrill of being recognized for your hard work are all emotions that are hard to put into words. In this article, I\u0026rsquo;ll walk you through the journey of our team who recently won their first ever hackathon, the CRIF Hackathon 2023.","title":"Celebrating victory at CRIF Hackathon 2023"},{"content":"The Blade Itself Once you\u0026rsquo;ve got a task to do, it\u0026rsquo;s better to do it than live with the fear of it. The more you learn, the more you realize how little you know. Still, the struggle itself is worthwhile. Knowledge is the root of power, after all. You have to learn to love the small things in life, like a hot bath. You have to love the small things, when you have nothing else. There are few men with more blood on their hands than me. None, that I know of. The Bloody-Nine they call me, my enemies, and there’s a lot of ’em. Always more enemies, and fewer friends. Blood gets you nothing but more blood. I’m trying to put things in the best light, but a turd’s a turd, whatever light it’s in! The seeds of the past bear fruit in the present. Broken hearts heal with time, but broken teeth never do. Life – the way it really is – is a battle not between good and bad, but between bad and worse. Treat a man like a dog and sooner or later he’ll bite you, The tongueless torturer and the flower of chivalry. An unlikely alliance. The blade itself incites to deeds of violence. If a man seeks to change the world, he should first understand it.’ The apprentice trotted the words out as if by rote, evidently relieved to be asked a question he knew the answer to. ‘The smith must learn the ways of metals, the carpenter the ways o. As far as I’m concerned you can fuck whomever you please, though my general observation has been that, as far as the reputations of young women are concerned, the less fucking the better. The reverse is true for young men of course. Hardly fair, but that\u0026rsquo;s life. Walk in God’s footsteps, Ferro Maljinn. “Huh. They have no God here. “Say rather that they have many. “Many? “Had you not noticed? Here, each man worships himself. The difference between misery and happiness was the right word from her. Either you are a part of my future, or a relic of the past Before They Are Hanged The mistakes of old, intoned Bayaz with the highest pomposity, “should be made only once. Any worthwhile education, therefore, must be founded on a sound understanding of history Self-pity was for children and half-wits. Few indeed are those who get a choice. We do as we are told. We stand or fall beside those who were born near to us, who look as we do, who speak the same words, and all the while we know as little of the reasons why as does the dust we return to. Rules are for children. This is war, and in war the only crime is to lose. Travel brings wisdom only to the wise. It renders the ignorant more ignorant than ever Proof is boring. Proof is tiresome. Proof is an irrelevance. People would far rather be handed an easy lie than search for a difficult truth, especially if it suits their own purposes. Sometimes it doesn\u0026rsquo;t matter too much what choice you make, as long as you make it quick and stick to it. The only difference between war and murder is the number of dead. Round and round in circles we go, clutching at successes we never grasp, endlessly tripping over the same old failures. Truly, life is the misery we endure between disappointments. Fear has made them sloppy. The world teeters at a precipe. All scared to take a step in case they put a foot into empty air. The instinct of self-preservation. It can destroy a man\u0026rsquo;s efficiency The lowly have small ambitions, and are satisfied with small indulgences. They need not get fair treatment. They need only think that they do. Because the vast majority of men would far rather be told what to do than make their own choices. Obedience is easy. Cleverness is no guarantee of sensible behavior Rising early. Of course. The second greatest virtue. It comes just behind ruthlessness. In my experience, a friend is merely an acquaintance who has yet to betray you. The Last Argument of The Kings The Great Leveller,\u0026rsquo; Dogman whispered to himself, since he was in a thoughtful frame of mind. That\u0026rsquo;s what the hillmen call him. Death, that is. He levels all differences. Named Men and nobodies, south or north. He catches everyone in the end. You get what you give, in the long run, and manners cost nothing Expect nothing and you won\u0026rsquo;t be disappointed. Expect nothing and you\u0026rsquo;ll get nothing. An excessive and a brutal act, but better to act with too much force than too little. Better to be held in fear, than in contempt. There is no place for sentiment in politics. Men must sometimes do what they do not like if they are to be remembered We should forgive our enemies, but not before they are hanged. Honour, eh? What the hell is that anyway? Every man thinks it\u0026rsquo;s something different. You can\u0026rsquo;t drink it. You can\u0026rsquo;t fuck it. The more of it you have the less good it does you, and if you\u0026rsquo;ve got none at all you don\u0026rsquo;t miss it. People love to see death. It reminds them that however mean, however low, however horrible their lives become… at least they have one. Fearlessness is a fool\u0026rsquo;s boast, to my mind. The only men with no fear in them are dead, or the soon to be dead, maybe. Fear teaches you caution, and respect for your enemy, and to avoid sharp edges used in anger. All good things in their place, believ. An open mind is like to an open wound,\u0026rsquo; growled Glokta. \u0026lsquo;Vulnerable to poison.\u0026rsquo; Strange, isn\u0026rsquo;t it,\u0026rsquo; mused Glokta as he watched him struggle for air. \u0026lsquo;Big men, small men, thin men, fat men, clever men, stupid men, they all respond the same to a fist in the guts. One minute you think you\u0026rsquo;re the most powerful man in the world. A man lost in the desert must take such water as he is offered, no matter who it comes from. One should learn the lessons of history. The mistakes of the past need only be made once. Unless there are no other choices There was no such thing as luck. Luck was a word idiots used to explain the consequences of their own rashness, and selfishness, and stupidity. More often than not bad luck meant bad plans Don’t deceive yourself. Everyone is guilty of something, and even the innocent can be a threat. Perhaps it takes small crimes to prevent bigger ones, Colonel West, but it’s up to bigger men than us to decide. We are leaders. War is what happens when we fail. Or are pushed into failure by the rash and the foolish. Victory is better than defeat, but not by much. Men must sometimes do what they do not like if they are to be remembered. It is through struggle, not ease, that fame and honor are won. It is through conflict, not peace, that wealth and power are gained. The seeds of the past bear fruit in the present This was a place of learning, and wonder, and great beauty.\u0026rsquo; Time has not been kind to the place. Time is never kind. ","permalink":"https://atharvashah.netlify.app/blog/book-quotes/the-best-quotes-from-first-law-trilogy-by-joe-abercrombie/","summary":"The Blade Itself Once you\u0026rsquo;ve got a task to do, it\u0026rsquo;s better to do it than live with the fear of it. The more you learn, the more you realize how little you know. Still, the struggle itself is worthwhile. Knowledge is the root of power, after all. You have to learn to love the small things in life, like a hot bath. You have to love the small things, when you have nothing else.","title":"The Best Quotes from First Law Trilogy by Joe Abercrombie"},{"content":" Let\u0026rsquo;s not mess around here. This series has just more than quotes to offer so I have included rich descriptive texts that boil the blood and wake something deep inside. Here\u0026rsquo;s to the good times fellas. Read on for some savage blood-curdling brutalism.\nThe deed is done. The war is won. And at the last, gentlefriend, her song is sung. I suppose you can say you know her now, at least as well as I did. The ugly parts and the selfish parts and the everything in between. A girl some called Pale Daughter. Or Kingmaker. A Queen of Scoundrels. A Lady of Blades. I like little Crow best of all. A girl who never knelt, who never broke, who never, ever allowed fear to be her fate. A girl I loved as much as you did. Look now upon the ruins in her wake. As pale light glitters on the waters that drank a city of bridges and bones, and a Republic’s ashes dance in the dark above your head. Stare mute at the broken sky and taste the iron on your tongue and listen as lonely winds whisper her name as if they knew her, too. I gave you all I promised, gentlefriend. I gave it to you in spades. And if her death didn’t unfold in the way you dreaded, I hope you’ll not name me liar for it. She did die, just as I said she would. But even the Moon loved our girl too much to let her die for long. The ink is drying upon the page. The tale is ending before your eyes. And if you feel some sorrow at this, our last farewell, know your narrator feels it, too. We are not made more by the stories we read, but by the stories we share. And in this, in her, I think we’ve shared more than most. I shall miss it when it’s gone. But to live in the hearts of those we leave behind is to never die. And to burn in the memories of our friends is to never say goodbye. So let me say this instead. Goodnight, gentlefriend. Goodnight. Never flinch. Never fear. And never, ever forget. “It’s finished,” she sighed. And she was gone. His father was on his knees, bleeding from the places his eyes should have been. His sisters knelt before him, their heads bowed low. His mother spread her gowns across the heavens, the bonds of her prison forever broken. And Anais ascended his throne. One sun. One night. One moon. Balance. “All is as it should be,” the Night declared. “The scales weigh even at last.” The prince of dawn and dusk looked to the infinity above them. He shook his head. “One tithe remains,” he said. And with black and burning hands, he reached for a piece of forever. She was dressed all in black: a corset and long skirts flowing like a river about her feet. A gravebone longblade waited in her hands. A golden mask covered her face, black paint on her lips, parting now as she spoke with a voice that shook the world. She could understand that—the impulse to tread closer to the cliff to peer over the edge. The need to skip ahead a few chapters and learn how the story ends. But Spiderkiller herself had no desire to know how the tale of Itreya’s first imperator finished. Only that she be alive to read about it afterward. The shadows lifted a fallen mask, leafed in gold, placing it over her eyes. It was shaped like a crescent. Like a moon not yet full. The dark was alive about her. Inside her. Pale and beautiful, she walked on. She wore the night, gentlefriends. And all the night came with her. The city about her trembling, this tomb of a fallen divinity too long profaned by the tread of mortal feet. The grave of a fallen god, set now to become the grave of an empire. She wore the night. Her gown was silken black. The jewels at her throat, darkling stars. Long skirts billowed out from her waist, flowed down to her bare feet, a corset of midnight cinched tight across ghost-pale skin. White powder on her cheeks. Black paint on her lips. Legions in her eyes. “Still your rage, Adonai,” Scaeva said. “This was but a well-earned reminder to your sister of her place in my order. You and Marielle served me well for many years, and I am not a man who squanders gifts such as yours. There is a place for you at my side. So take your knee. Swear your allegiance. Beg my forgiveness.” The shadows at Scaeva’s feet rippled. “And I will grant it.” Adonai’s eyes flashed, the blood storm about him swirling, seething. “Speak ye of gifts?” he spat. “As if I found them in a pretty box on Great Tithe?” Adonai shook his head, long pale hair come loose from its ties and draped about crimson eyes. “Paid for my power be, bastard. With blood and agony. But thou art thief of a power unearned.” He narrowed his eyes, pointing at Scaeva. “Usurper, I name thee. Wretch and villain. Already I see how thy theft takes its tithe upon thee. But I have not the patience nor desire to await the descent of fate’s cold hand. I promised thee suffering, Julius.” “There’s a tithe to be paid for power,” Mercurio said. “Sometimes it’s measured in conscience or coin. Sometimes we pay with pieces of our own souls. But whatever we owe, this much is true—sooner or later, the debt always comes due.” “We’re not leaving without the weaver,” Mercurio said. “You have my word. But there’s one captain in this company, Adonai. And I’m giving the orders aboard this ship.” “Boat,” Bladesinger murmured from the gondola’s bow. Mercurio sighed, tired in his bones. “Everyone’s a critic.” The faintest blood-red of Saan’s fallen glow, like blush on a courtesan’s cheek. Saai’s pale blue, like the eye of a newborn babe, falling into sleep. A magnificent watercolor portrait, glittering on the ocean’s face and reaching up into the gables of heaven. Dark stains leaking across the edges of the canvas. It takes three turns for the light to fully die. All the Republic is washed in the stink of blood as Aa’s ministers sacrifice animals by the hundreds, the thousands, beseeching their Everseeing to return quick as he may. Long shadows fall across the streets of Godsgrave like funeral shrouds. As the Night creeps closer on pale, bare feet, the citizenry is gripped with a kind of hysteria. Purchasing their pretty dominos and fearsome voltos and smiling punchinellos from the mask makers. Fetching their finest coats and gowns from tailors and seamstresses. Hands shaking all the while. The pious flee to the cathedrals in droves to pray the long night away. The rest seek solace in the company of friends or the arms of strangers or the bottom of bottles. An endless run of soirees and salons pepper the calendar in the turns prior, as the light slowly perishes, as the citizens fight or fawn or fuck their fears away. Then truedark falls. And Carnivalé begins. Moonlight. In the distance, she could hear faint footsteps. The pulse of fearful hearts in heaving chests. The ring of steel, and prayers to the Everseeing. Men, she realized. The soldiers of the Seventeenth who’d pursued her into the labyrinth. Five thousand of them. But the power of a god now flowed in her veins. A dark and fathomless strength no child of woman born could hope to match. Even without the legion of passengers now in her shadow, she feared no mortal man. She’d deal with them, each in kind, like moths to black flame. Then Godsgrave. And then … Their voices rang through that broken skull, that hollowed crown. Many and one. “Father.” The shadows placed her bloody sword in her hand. “We come for you.” The boy beside her. The boy inside her. Anais. “The many were one,” he whispered. The many fragments of his soul. “And will be again.” United in me. “One beneath the three.” One moon beneath three suns. “To raise the four.” The Four Daughters. “Free the first.” Niah, the first divinity. “Blind the second and the third.” Extinguish the second and third suns. And what then would remain? One sun. One moon. One night. Balance. As it was, and should, and will be. “Fear was never my fate,” Mia hissed. Fear was Can’t. Fear was Won’t. But fear wasn’t ever a choice. To never fear was to never hope. Never love. Never live. To never fear the dark was to never smile as the dawn kissed your face. To never fear solitude was to never know the joy of a beauty in your arms. Part of having is the fear of losing. Part of creating is the fear of it breaking. Part of beginning is the fear of your ending. Fear is never a choice. Never a choice. But letting it rule you is. “Never flinch,” her mother had told her. “Never fear.” But there, alone in Cleo’s dark, Mia finally realized the impossibility of those words. Facing her fear for the first time in as long as she could remember, Mia finally saw it for what it was. Fear was a poison. Fear was a prison. Fear was the bridesmaid of regret, the butcher of ambition, the bleak forever between forward and backward. Niah’s first chosen. What was Mia beside her? You are nothing, the woman told her. “I am Mia Corvere,” she hissed. “Champion of the Venatus Magni. Queen of Scoundrels and Lady of Blades.” You are no one. “I am a daughter of the dark between the stars. I am the thought that wakes the bastards of this world sweating in the nevernight. I am the war you—” No, dearheart, sweetheart, blackheart. Cleo smiled, one slender hand outstretched as if to bestow a gift. You are afraid. It took Mia a moment to feel the weight of it. To recognize the shape of it. Mister Kindly had walked in her shadow since she was ten years old, tearing her fears to ribbons. With Eclipse and him both inside her, she’d been indomitable. Fear had been a blurred memory, a forgotten taste, something that only happened to others. But after all those years, at Cleo’s smiling behest, it had finally, truly found her. Rising on an ice-cold tide in her belly and setting her legs to buckling. You never know what can break you until you’re falling apart. You never miss your shadow until you’re lost in the dark. Mia’s sword fell from nerveless fingers. She stumbled to her knees. She’d been alone before, but never like this. It was as if all her life, she’d been unfinished, and she’d never realized until this moment. All the fragments of her brief existence seemed insignificant—Jonnen, Tric, Mercurio, Scaeva, even Ashlinn—they were only phantoms somewhere in the dark within. Because through all the years and all the blood, at last, at last, she was home. No. Mia gritted her teeth, balled her hands to fists. This is not my home. She was here for a reason. Not to sleep, but to awake. Not to be claimed, but to claim. The power of a fallen god. The legacy of a shattered line. The power of the light in the night. To tear it, beating and bleeding, from a shattered chest and wrest back her brother from the bastard who’d claimed him. To fight and die for the only thing that gave her life meaning anymore. The only thing she had left. When all is blood, blood is all. “You’re not my daughter.” “You’re just her shadow.” “The last thing you will ever be in this world, girl, is someone’s hero.” “A girl with a story to tell.” “All I hear, Kingmaker, are lies from the mouth of a murderer.” “I want you gone, do you hear me?” “I’d have killed the sky for you…” “Jonnen,” she breathed. Mia had no idea how Scaeva had sent word to the Ashkahi Legion about where she was headed. But he’d taken the godsblood. The might of a fallen divinity sang in his veins. Who knows what gifts he had at his disposal now? And in the end, she supposed it didn’t really matter how. He’d obviously done it, and she obviously had five thousand fully armed and armored cocks set to fuck her none too sweetly. “Only a wanker reads her own biography, Sid. Especially if it’s got footnotes.” “… Yours for the taking, Julius…” “It is dangerous, Father,” Jonnen warned. “And what have I told you, my son?” the imperator asked. “About claiming true power? Does a man need senators? Or soldiers? Or servants of the holy?” “No,” Jonnen whispered. “What then, does a man need?” “Will,” the boy heard himself say. “The will to do what others will not.” “O, Lucius,” she’d sobbed. “My darling Lucius.” And though he’d not spoken, the boy still heard the words ringing in his head. My name is Jonnen. They’d eaten a surreal sort of dinner together. Just the three of them, like he couldn’t remember them doing for an age. The table was laden with the finest fare the boy had tasted in months. No slop stews or cold porridge or dried beef. No eating in some miserable hutch or lonely ruin. No bawdy tales or cigarillo smoke. Instead, they had mouthwatering finger foods and sizzling roasts cooked to perfection and honeyed sweets that melted in his mouth. Flawless porcelain plates and silver cutlery and singing Dweymeri crystal glasses. Mother even let him have a little wine. And all Jonnen could taste was the blood. Poor Butcher. Poor Eclipse. Jonnen could still taste the blood. It had been a full turn since they’d emerged from the pool in the Red Church chapel beneath Godsgrave’s necropolis, dripping in scarlet. Fifty of the Luminatii awaiting them had given him, his father, the woman called Spiderkiller, and the sorcerii called Marielle a hasty escort through the bustling streets. The other half century had remained behind to ensure none of Mia’s comrades gave pursuit. Jonnen had wondered whether it would’ve been a good or bad thing. But none of them came after him at all. Once back in their apartments in the first Rib, the Spiderkiller had taken the sorcerii away, only Aa knew where. His father had gone to bathe. Jonnen had been surrounded by slaves, thoroughly scrubbed, trimmed, and dressed in a white toga hemmed in purple. And finally, with rather more flair than he thought their ignoble retreat from the Mountain had warranted, his father had presented him to his mother. Or at least, the woman who called herself his mother. Liviana Scaeva had wept to see him, sweeping him up in an embrace so fierce the boy thought his ribs might have cracked. She’d praised the Everseeing, blessed his father’s name, dragging him close with one hand while the other still gripped her son. “O, Lucius,” she’d sobbed. “My darling Lucius.” And though he’d not spoken, the boy still heard the words ringing in his head. My name is Jonnen. They’d eaten a surreal sort of dinner together. Just the three of them, like he couldn’t remember them doing for an age. The table was laden with the finest fare the boy had tasted in months. No slop stews or cold porridge or dried beef. No eating in some miserable hutch or lonely ruin. No bawdy tales or cigarillo smoke. Instead, they had mouthwatering finger foods and sizzling roasts cooked to perfection and honeyed sweets that melted in his mouth. Flawless porcelain plates and silver cutlery and singing Dweymeri crystal glasses. Mother even let him have a little wine. And all Jonnen could taste was the blood. Poor Butcher. Poor Eclipse. “You know, I don’t remember them ever teaching classes in it here, but you’ve a wonderful knack for killing the mood.”- “It’s all lies,” she whispered. “The murders. The offerings. Hear me, Mother. Hear me now. All that bollocks. This place wasn’t a church, Solis. It was a brothel. You were never a holy Blade in service to the Mother of Night. You were a whore.” “I’m not some hero in a storybook. I’m not someone you should aspire to be. I’m a ruthless cunt, Jonnen. I’m a selfish bitch. You hurt me, I’ll hurt you back. You hurt the ones I love, I’ll kill you instead. That’s just the way I am. Julius Scaeva killed our mother. The man I called Father. And I don’t care what they did to deserve it. I don’t care that they weren’t perfect. I don’t even care that they were probably just as bad as him. Because truth told, perhaps I’m worse than all of them. So fuck what’s right. And fuck redemption. Because Julius Scaeva still deserves to die.” Lightning flashed, tearing the skies in fury. The waves crashed and rolled. The Ladies of Storms and Oceans, the terrible twins, reaching out toward her with all their hatred. Mia hauled herself to her feet, Eclipse beside her, the shadows swaying like serpents. She dragged her sodden tricorn off, clawed her hair from her face, and she laughed. Her eyes alight. Her heart warmed by dark flame, burning in her chest. All they had, they’d thrown. All their hate, they’d given. All their fury, spent. Mia raised the knuckles to the sky. “Still standing, bitches.” “Help me, then!” “ALWAYS!” Side by side. Back to back. The pair fought together, like in younger turns when they trained in the Hall of Songs. They were older now, harder, sadder, years and miles and the very walls of life and death between them. “THE ONLY WEAPON IN THIS WAR IS FAITH.” She’d set aside her faith years ago. Stopped praying to Aa the turn she realized that all the devotion in the world wouldn’t bring her familia back. Even in service of the Dark Mother, even in the belly of the Quiet Mountain, she’d not truly held any belief for the divinities—not for divinities who might actually care, at least. Who knew who she was, who thought she mattered, who were more than empty words and hollow names. And now? Moons and crowns and mothers and fathers and all of it? Do I truly believe? “I am a daughter of the dark between the stars,” she replied. “I am the thought that wakes the bastards of this world sweating in the nevernight. I am the vengeance of every orphaned daughter, every murdered mother, every bastard son.” Mia leaned forward and looked the man in the eye. “I am the war you cannot win.” “My name is Mia Corvere,” she said, still unblinking. “Blade of the Red Church. Champion of the Venatus Magni. Chosen of the Dark Mother and Queen of Scoundrels. Never call me girl again.” Blood was a speaker’s only sustenance, but it was also an emetic. To drink too much was to know awful sickness. To drink too little was to know awful hunger. A constant, flawless sanguine torture. Blood was a speaker’s only sustenance, but it was also an emetic. Her vow. Father When the last sun falls When daylight dies So do you. “Pretty warriors can’t fight for shit. You can’t know how sweet it is to breathe ’til you’ve had your ribs broken. You can’t appreciate being happy ’til someone has made you cry. And there’s no point blaming yourself for the kickings life gives you. Just think about how much it hurt, and how much you don’t want to feel that way again. And that’ll help you do what you need to do the next time to win.” “Blaming yourself for another’s work is like blaming yourself for the weather,” he said, looking at Wavewaker’s and Bryn’s bodies. “And I’ll mourn them as a brother and sister lost, aye. But taking a beating is part of being alive. And let me tell you something, Mia—the best brawlers I ever met were the ugliest, too. Broken noses and missing teeth and cauliflower ears. Because the best way to learn to win is by losing.” “The man I’ve been trying to kill for the past eight years turns out to be the man who gave me life. And if that isn’t enough of a fuck-you from the divinities, I’ve apparently got a fragment of a dead god inside me that I inherited from him, too! O, and incidentally, the last boy I fucked got murdered by the last girl I fucked, then resurrected by the Mother of Night to help me with the aforementioned god problem, and the prick who just cut Bryn and ’Waker’s throat used to be a personal friend of mine! I am fucking poison, do you see that? I am cancer! Whatever comes near me ends up dead. So get the fuck away from me before you get killed, too.”- I realize ‘deserve’ has nothing to do with this life. Blessings and curses fall on the wicked and the just alike. Fair is a fairy tale. Nothing’s claimed by those who don’t want it, and nothing’s kept by those who won’t fight for it. So let’s fight. Fuck the gods. Fuck it all. Let’s take the world by the throat and make it give us what we want.” Whatever you did, you did it because it needed to be done. Remorse is for the weak, Mia. And regret is for cowards. Whatever you did then meant you can be here in my arms now. That makes it right. And I’m not about to let some bollocks about moons and suns take that away from us.” “You do whatever you need to do. Moons, Mothers, I don’t give a toss. But if I get a whiff of some other endgame, I get a hint this Anais nonsense is putting her at risk, we’ll find out sure and true if deadboys can die again.” She took a step back, eyes never leaving his. “I will rip all three suns out of heaven to keep her safe, you hear me?” Ashlinn vowed. “I will kill the fucking sky.” She blew him a kiss. Then she turned and stalked away. “’Byss and blood, how did you find us?”’Singer asked. “Poked my nose into the first whorehouse I saw,” Mia shrugged. “After that, I just followed the trail of vomit.” “Known many high-priced courtesans, have you?” Aelius asked. Mercurio shrugged. “In my youth.” “Got any good stories? It’s been a while for me…” “If it’s cheap smut you’re after,” Mercurio sighed, tapping the first of “THE BOOKS,” “the tawdriness starts in volume one, page two hundred and forty-nine.” “O, I know,” the chronicler chuckled. “Chapter twenty-two.” Mercurio turned his deepening scowl on Aelius. “You read those pages?” “Didn’t you?” “Maw’s fucking teeth, no!” Mercurio almost choked on his smoke, utterly horrified. “She’s like my … I don’t want to think of her getting up to … that.” “Well, let’s see,” Mia sighed, counting on her fingers. “I’ve brought two daemons and a deadboy aboard your ship. My brother and I are both darkin, and he’s also the abducted son of the imperator with what’s likely the whole Itreyan Legion chasing his arse. I implicated you and your crew in the murder of a handful of Luminatii, their crew, and the destruction of their ship.” She tipped her head back, guzzled the last of the bottle, and dropped it on the deck. “And I’ve drunk all your fucking wine.” “A HINT OF REGRET? SOME SHRED OF REMORSE? FOR YOU TO UNDERSTAND SOME SMALL PART OF WHAT YOU TOOK FROM ME?” “Remorse is for the weak, Tricky,” Ash said. “And regret is for cowards.” “Well,” Corleone said, taking another stab. “How do you all know each other?” Silence. Long as years. “We studied together,” Mia finally replied. “O, aye?” Corleone smiled, intrigued. “Public institution, or Iron Collegium, or…” “… it was a school for fledgling assassins run by a murder cult…” “Ah.” The captain glanced at the shadowcat and nodded. “Private tutors, then.” “SOME OF US BECAME MASTERS OF IT,” Tric said, staring at Ash. “MURDER, THAT IS.” “That shouldn’t surprise,” she replied. “Given what we trained for.” “A KNIFE IN THE HAND OF A FRIEND IS OFTEN A SURPRISE.” “It shouldn’t be, if that friend thinks to come before familia.” “Erm…,” Corleone stammered. Mia drained her glass. “Pass the wine, please?” Corleone complied as the galley boy brought in the main and started serving. It was fine fare considering they were aboard a ship—sizzling lamb and almost-fresh greens and rosemary jus that made Mia’s mouth water despite the tension in the air. As Corleone began carving, the meat almost fell off the bone. “I saw you best that silkling at the Whitekeep games,” BigJon said to her around his mouthful. “Won a strumpet’s cuntful of coin on you, too. Bloody magnificent, lass.” “Four Daughters, BigJon,” Cloud scowled. “Mind your cursing at table, neh?” “Fuck,” he said, biting his lip. “Apologies.” “Again?” “Fuck. Sorry. Shit … FUCK…” “No, it’s all right,” Mia said, leaning back in her chair and enjoying the feel of her head spinning. “I was bloody magnificent. I trust you spent your cuntful on something fucking marvelous.” The littleman grinned with silver teeth, raising his glass. “O, I like you.” Mia raised her glass in return, downed it in a gulp. “What about you, young don?” Cloud said, turning to Jonnen for a change of subject. “Do you like ships, perchance?” “Do not speak to me, cretin,” the boy replied, toying with his food. “Jonnen,” Mia warned. “Don’t be rude.” “I will not entertain inane chatter with this lawless brigand, Kingmaker,” the boy snapped. “Further, when I am returned to my father, I will see him hanged a villain.” “Well…” Corleone’s lips flapped a little. “I…” “Don’t mind him,” Mia said. “He’s a spoiled little shit.” “I am the son of an imperator!” the boy cried shrilly. “But you’re not above a spanking! So mind your fucking manners!” Mia glowered at the boy, engaged in a silent battle of wills. “Ah…,” BigJon tried. “More wine?” “O, yes, please,” Mia said, holding out her glass. A more comfortable silence settled over the table as Mia got her refill and folk got down to eating. Mia had spent the last eight months dining on the various questionable broths and swills cooked up in the Remus Collegium—this was the first decent feed she’d had in as long as she could remember. She started stuffing her face, using more wine to wash her ambitious mouthfuls down. The lamb was delicious, hot, perfectly seasoned, the greens crunchy and tart. Even Jonnen seemed to be enjoying himself. “Are you not eating, Don Tric?” Corleone asked. “I can have the galley fix something else if this displeases.” “THE DEAD HAVE NO NEED OF FOOD, CAPTAIN.” “And yet they insist on coming to the dinner table, regardless,” Ashlinn muttered around a mouthful. “… EXCUSE ME?” “Pass the salt, dwarf,” Jonnen demanded. “Oi!” Mia thumped the table. “He’s not a dwarf, he’s a littleman!” “No, I am a little man,” the boy said with a smug smile, pointing to BigJon with his fork. “He is a dwarf. And I will be taller tomorrow.” “That’s fucking it,” Mia said, rising to her feet. “Go to your room!” “I beg your pardon?” he asked. “I am the son of—” “I give no fucks for whose son you are. You’re a guest at this table and you don’t talk to people that way. You want to be treated with respect, little brother? Start by treating others to it. Because it’s earned, not fucking owed.” Mia leaned forward and glowered. “Now go. To. Your. Room!” “More wine, anyone?” “No,” Ashlinn said, watching Tric. “NO,” Tric said, glaring at Ashlinn. “Fuck yes,” Mia said, waving her glass. For his part Falco was ready for the blow at least, drawing the sunsteel blade at his belt and speaking a prayer to Aa. The sword ignited with a shear of bright flame and he met the girl’s strike, his sunsteel scoring her blade. The lass yelled “MIA!” again, the three remaining marines cried out and drew their shortblades, Cloud spat a black curse, and before he knew it, the cabin was in chaos. Gravebone swords. And lastly, and probably strangest of all, as the girl aimed a scything blow at Centurion Ovidius Varinius Falco, second century, third cohort’s cocky neck, a shadow shaped like a cat lunged out from beneath her voluminous robes with an unearthly yowl, followed by a rather alarmed nine-year-old boy, gagged and bound at his wrists. Several things happened in quick succession here, each slightly more surprising than the last. First, the lass shouted “MIA!” at the top of her lungs toward the open porthole. Which, all things considered, Cloud thought rather odd. Second, she moved, flinging a knife from inside her sleeve and drawing a shortsword she’d hidden fuck-knows-where. The knife sailed into the throat of the closest marine, and as the man fell back in a spray of red, the lass lashed out at the centurion with her blade, face twisted in a snarl. Third, the big fellow in the corner threw back his hood, revealing a corpse-pale face, eyes like a daemon and saltlocks like … well, Cloud had no fucking idea, but they were moving by themselves. The fellow drew out his two suspiciously sword-shaped lumps from beneath his robe, which indeed turned out to be swords. “Fear has its uses,” he replied. “Fear is what keeps the dark from devouring you. Fear is what stops you joining a game you cannot hope to win.” “I have never lied to you, daughter,” he said. “Not once, throughout it all. When I ordered you drowned, you were worthless to me. Jonnen was young enough to claim as my own. You were too old. But now you’ve proved yourself my daughter true. Possessed of the same will as I: not only to survive, but to prosper. To carve your name with bloody fingernails into this earth. Darius sought to become a kingmaker? You can truly be one. The blade in my right hand. Whatever you desire will be yours. Wealth. Power. Pleasure. I can do away with those gold-grubbing whores in the Red Church and have you at my side instead. My daughter. My blood. As dark and beautiful and deadly as the night. And together, we can sculpt a dynasty that will live for a thousand years.” “Mia, if Darius Corvere’s rebellion had triumphed, his beloved General Antonius would now be king of Itreya. The Senate House would be a ruin and the constitution in ashes. And I don’t blame the man for trying. Darius gave his best. The only difference between he and I is that his best wasn’t good enough to win the game.” “The same way I just laid c-claim to a throne.” Scaeva twisted the Trinity this way and that, veins standing taut in his neck, hissing through gritted teeth. “A matter of will, daughter m-mine. To claim true power, you need not soldiers … n-nor senators, nor servants of the holy. All you need is the will to do what others will n-not.” “YOU MUST MAKE WHOLE WHAT WAS BROKEN, MIA. YOU MUST RETURN MAGIK TO THE WORLD. RESTORE THE BALANCE BETWEEN NIGHT AND DAY, LIKE IT WAS IN THE BEGINNING. LIKE IT WAS ALWAYS MEANT TO BE. ONE SUN. ONE NIGHT. ONE MOON.” “IN THE EMPIRE OF OLD ASHKAH, THEY KNEW ANAIS BY ANOTHER NAME.” Mia looked at the glowing orb—the same she’d seen in the moment she slew Furian in Godsgrave Arena—and felt her shadow grow darker still. “The Moon,” she realized. Tric nodded. “HE WAS THE EATER OF FEAR. THE DAY IN THE DARKNESS. HE REFLECTED HIS FATHER’S LIGHT AND BRIGHTENED HIS MOTHER’S NIGHT. IN THE EMPIRE OF OLD ASHKAH, HE TAUGHT THE FIRST SORCERII THE ARTS ARCANE. A GOD OF MAGIK AND WISDOM AND HARMONY, WORSHIPPED ABOVE ALL OTHERS. NO SHADOW WITHOUT LIGHT, EVER DAY FOLLOWS NIGHT, BETWEEN BLACK AND WHITE…” “There is gray…,” Mia murmured. “HE WAS THE BALANCE BETWEEN NIGHT AND DAY. THE PRINCE OF DAWN AND DUSK. AND FEARING HIS GROWING POWER, THE EVERSEEING RESOLVED TO SLAY HIS ONLY SON.” The stone reliefs began moving again as Tric spoke. Graven hands shifting to cover sightless eyes. Mouths widening in horror. The orb in the pool shifted, became a sharp, crescent shape, dripping blood. In the back of her mind, Mia swore she could hear other voices. Thousands of them, just beyond the edge of hearing. And they were screaming. “AA STRUCK WHILE ANAIS SLEPT,” Tric continued. “HE CUT OFF HIS SON’S HEAD AND HURLED HIS BODY FROM THE HEAVENS. ANAIS’S CORPSE PLUMMETED TO THE EARTH, TEARING THE LAND ASUNDER AND THROWING ALL THE WORLD INTO CHAOS. THE ASHKAHI EMPIRE IN THE EAST WAS COMPLETELY DESTROYED. AND WHERE HIS SON’S BODY LAY IN THE WEST, AA COMMANDED HIS FAITHFUL TO BUILD A TEMPLE TO HIS GLORY. THAT TEMPLE BECAME A CITY, AND THAT CITY BECAME THE NEW HEART OF HIS FAITH.” “The Ribs.” Ash glanced at the gravebone blade at her waist. “The Spine.” “This whole place…,” Mia realized, looking around them. Tric nodded. “A GOD’S GRAVE.” Heart hammering, mouth dry, Mia pictured the illustration she’d found at the end of Cleo’s journal—a map of Itreya before the rise of the Republic. The bay of Godsgrave had been missing entirely, a peninsula filling the Sea of Silence where the Itreyan capital now stood. And in that spot, three words had been scribed in blood-red ink. “Here he fell…,” she whispered. “HERE HE FELL,” Tric nodded. “BUT GODS DON’T DIE SO EASILY. AND THE MOTHER KEEPS ONLY WHAT SHE NEEDS. ANAIS’S SOUL WASN’T EXTINGUISHED.” ANAIS’S CORPSE PLUMMETED TO THE EARTH, TEARING THE LAND ASUNDER YOUR VENGEANCE IS AS THE SUNS, MIA. IT SERVES ONLY TO BLIND YOU. Mercurio raised an eyebrow, cigarillo still smoldering at his lips as he examined the tome. It was bound in leather, black as a truedark sky. The edges of the pages were stained blood-red, and a crow in flight was embossed in glossy black on the cover. He opened the book, looked down to the first page. “Nevernight,” he muttered. “Stupid name for a book.” “Makes for interesting reading,” Aelius said. Mercurio opened the book to the prologue, rheumy eyes scanning the text. CAVEAT EMPTOR People often shit themselves when they die. Their muscles slack and their souls flutter free and everything else just … slips out. For all their audience’s love of death, the playwrights seldom— Mercurio flipped through a few more pages, softly scoffing. “It has footnotes? What kind of wanker writes a novel with footnotes?” “It’s not a novel,” Aelius replied, sounding wounded. “It’s a biography.” “About who?” The chronicler simply nodded back to the book. Mercurio flicked through a few pages more, scanning the beginning of chapter three. … dropped him into the path of an oncoming maidservant, who fell with a shriek. Dona Corvere turned on her daughter, regal and furious. “Mia Corvere, keep that wretched animal out from underfoot or we’ll leave it behind!” And as simple as that, we have her name. Mia. Mercurio faltered. Cigarillo hanging from suddenly bone-dry lips. His blood ran cold as he finally understood what he held in his hands. Glancing up at the shelves around him. The dead books and lost books and books that never were—some burned on the pyres of the faithful, some swallowed by time, and others … Simply too dangerous to write at all. Aelius had wandered off down the twisted row, hands in his pockets and muttering to himself, a trail of thin gray smoke left behind him. But Mercurio was rooted to the spot. Utterly mesmerized. He began flipping faster through the pages, eyes scanning the flowing script, snatching only fragments in his haste. “The books we love, they love us back.” “I will give your brother your regards.” “Who or what is the Moon?” she asked. Mercurio reached the end, turning the book over and over in his hands. Wondering why there were no more pages and looking around the library of the dead in mute wonder and fear. “I found another one, too,” Aelius said, returning from farther down the row. “About three months back. Wasn’t there one turn, next turn, there it was.” The chronicler handed Mercurio another heavy tome. It was similar to the one he already held, but the pages were edged in sky blue rather than blood-red. A wolf was embossed on the black cover instead of a crow. Juggling the first book into the crook of his elbow, he opened the second’s cover and peered at the title. “Godsgrave,” he muttered. “Follows on from the first,” Aelius nodded. “I think I liked this one better, actually. Less fucking about at the start.” The choir sang in the ghostly dark around them, echoing through the great Athenaeum. Mercurio’s hands were shaking, cigarillo falling from his mouth as he fumbled with the first tome, opening it finally to the title page. And there it was. NEVERNIGHT BOOK - OF THE NEVERNIGHT CHRONICLE by Mercurio of Liis The old man closed the book, looked at Niah’s chronicler with wondering eyes. “Holy shit,” he breathed. An endless heaven for any reader, and a living hell for any librarian. And now, here he was. A worm on Drusilla’s hook. For all his bluff, he knew the Lady of Blades spoke truth—Mia loved him like blood. She’d never let him die in here, not if she thought she had a chance to save him. And with those wretched daemons riding her shadow and eating her fear, in Mia’s head there was always a chance. “The bishop of Godsgrave is already back at the Quiet Mountain,” Solis said. “He put up some resistance,” Mouser said. “We had to hurt him, I’m afraid.” Spiderkiller looked at Ashlinn with black, glittering eyes. “There are some among us who are dearly hoping the same can be said of you, child.” “Please,” Drusilla waved to the chair in front of her. “Sit.” “Or what?” Ashlinn said, her anger rising. “You can’t kill me like you killed my da, you old bitch. The map’s branded on my skin. If I die, it’s lost forever.” “Please sit, Dona Järnheim,” said a voice. A man stepped out from Mercurio’s bedchamber, and Ashlinn’s belly filled with cold ice. He was tall, painfully handsome, dark hair shot through with the faintest streaks of gray. He wore a long toga of rich purple, a golden laurel at his brow. “No . . . ,” Ashlinn breathed. “If we wanted you dead, you’d have been so long ago,” Consul Scaeva said. “So, please, sit before we are forced to resort to . . . unpleasantness.” “You’re dead,” Ashlinn whispered. “I saw you die . . .” “No,” Scaeva said. “Although I admit the likeness was uncanny.” Ashlinn’s eyes grew wide as realization sank home . . . “The Weaver,” Ash whispered. “Marielle. She gave someone else your face . . .” “You always were a clever one, Ashlinn,” Aalea smiled. “You’ll forgive the appertaining drama, I hope,” Consul Scaeva said. “But such subterfuge is necessary for a man with as many enemies as I.” Ashlinn searched their faces, mind awhirl. They’d known. They’d known this whole fucking time . . . But why would they let us . . . . . . Unless they wanted us . . . Like a puzzlebox with no more missing pieces. All of them falling into place. “You wanted Cardinal Duomo dead,” she whispered. “But you couldn’t just have the Church kill him. He was protected by the Red Promise. Only a Blade would be good enough to end him . . . but it had to be a Blade willing to betray the Ministry. That way, the Church’s reputation stays intact, and you still see your enemy dead.” “And once I reveal myself miraculously alive to Godsgrave’s adoring citizens . . .” “ . . . They’ll adore you all the more.” “And be left with no doubt of the continuing danger our Republic faces.” “Buying you a fourth term as consul . . .” “O, no,” Scaeva said, smiling wide. “That laurel is already bought. But the brutal assassination of a grand cardinal in front of the entire capital on Aa’s most holy feast? Say it with me, young Dona Järnheim. Perpetual. Emergency. Powers.” Ashlinn’s lips curled in derision. The ego on this tosser . . . The girl tossed her pack away with an almost casual contempt, plopped herself into the offered chair, and put her feet on Mercurio’s desk, right in Drusilla’s face. The old woman glowered, but Mia’s gravebone blade was still in Ash’s hand, her fingers drumming on the hilt. “Foresaw everything, neh?” she asked the consul. “I foresaw enough.” “Except the part where Mia stole your son?” Duomo stopped before her, looked down with a gentle smile. It had been years since he’d seen her last. She had a new face and new scars to show for her time. But looking up into his eyes, she searched for recognition. Some sliver of understanding about who it was kneeling before him. Some acknowledgment of all he’d done. Nothing. He doesn’t even know me. More Luminatii, Scaeva marching behind, taking his time. Waving with his son to the crowd. And as he and his retinue drew nearer, closer, above the stubborn butterflies flitting about her belly, Mia felt it. A now familiar sensation. Hunger. Want. The longing of a puzzle, searching for a piece of itself. Maw’s teeth . . . Her eyes widened. Mouth dry as ashes. Someone here is darkin . . . She searched among the soldiers, felt no hint of hunger. Heart hammering, she looked to Duomo, but no . . . that would be impossible. She’d seen him wielding a blessed trinity in his hand—if he were darkin, sanctified sigils of Aa would repel him, just as she . . . O, Black Mother . . . . . . Scaeva? Her stomach sank. Eyes wide. But again, she’d seen him the truedark she attacked the Basilica Grande. There among the pews in Aa’s holy house, no ill effects among the Light Father’s faithful or his blessed symbols. But . . . O, Black Mother . . . The boy . . . Scaeva’s son. She looked at him, found him looking back, brow creased in puzzlement. He was dark of hair, dark of eye, just like her. And as her stomach sank toward her toes, in his face, the line of his cheeks, or perhaps the shape of his lips, she saw . . . “Luminus Invicta, heretic,” Remus said, raising the blade above her head. “I will give your brother your regards.” . . . she saw. “You have what is yours,” Alinne said. “Your hollow victory. Your precious Republic. I trust it keeps you warm in the nevernight.” Consul Julius looked down at Mia, his smile dark as bruises. “Would you like to know what keeps me warm in the nevernight, little one?” No . . . Mia blinked in the gloom. Eyes searching the cell beyond. “Mother, where’s Jonnen?” The Dona Corvere mouthed shapeless words. She clawed her skin, dug her hands into her matted hair. Gritting her teeth and closing her eyes as tears spilled down her cheeks. “Gone,” she breathed. “With his father. Gone.” Not “dead.” Only “gone.” With his . . . . . . no. O, mother, please no . . . “Father,” the boy on Scaeva’s shoulder’s asked. “Yes, my son?” the consul replied. The child narrowed his ink-black eyes. Looking right at Mia. “I’m hungry . . .” Mia turned her eyes to the stone. Her heart was thundering now, despite all Mister Kindly’s and Eclipse’s efforts. Pulse rushing beneath her skin. The thought was too repulsive to believe, too awful, too horrifying, but glancing up again into the boy’s face, she saw it. The shape of her mother’s eyes. The bow of her lips. Memories of the babe she’d played with as a child, six years and a lifetime ago, flooding back into her mind and threatening to spill from her throat in a scream. Jonnen. O, sweet little Jonnen. My brother lives . . . Mind racing. Heart pounding. Sweat burning. Mia curled her hands into fists and pressed her knuckles into the stone as Cardinal Duomo stood before her and spread his arms wide, face upturned to the sky. Patience. “Father of Light!” Duomo called. “Creator of fire, water, storm and earth! We call you to bear witness, on this, your holy feast! Through right of combat and trial before your everseeing eyes, we name this slave a free woman, and beg you grant her the honor of your grace! Stand and speak your name, child, that all may know our victor!” Patience. “Crow!” the crowd roared. “CROW!” The name echoed on the arena walls. Reverberation. Admonition. Benediction. “Crow!Crow!Crow!Crow!” The girl rose slowly, standing like a mountain beneath those burning suns. “My name is Mia,” she said softly. Hand slipping to the gravebone blade at her wrist. “Mia Corvere.” Duomo’s eyes widened. Scaeva’s brow creased. The blade whistled as it came, slicing through the cardinal’s throat, ear to bloody ear. He staggered back, dark blood fountaining from the wound, fingers to his severed carotid and jugular. The spray hit her face, thick and red, warm on her lips as she moved, as the Luminatii moved, as everything around her moved. The crowd roaring in horror. The cardinal collapsing to the stone. The Luminatii crying out, raising their blades. And the girl. The Blade. The gladiatii. The daughter of a murdered house, child of a failed rebellion, victor of the greatest bloodsport the Republic had ever seen . . . she charged. Right at Julius Scaeva. Fear bleached his handsome features, his dark eyes wide with horror. The Luminatii moved to intercept her, but she was quick as shadows, sharp as razors, hard as steel. Scaeva cried out, lifting the boy off his shoulders, the child’s eyes wide with fear. And as Mia’s belly rolled, the consul held his son out like a shield, and coward among cowards, he threw the boy at Mia’s face. She cried out, hand outstretched, the child’s arms pinwheeling as he flew. The world slowed to a crawl, the suns pounding at her back, the heat of sunsteel flame rippling on her skin. She caught the boy, clutching him tight in her free arm, pulling him close. And rising up on her toes, she spun like a dancer, long dark hair streaming, arm outstretched in a glittering arc. Perfection. Her blade sank into Scaeva’s chest, buried all the way to the hilt. The consul gasped, eyes open wide. Mia’s face twisted, scar tissue pulling at her cheek, hatred like acid in her veins. All the miles, all the years, all the pain, coalescing in the muscles of her arm, corded and pulled tight as she dragged her blade sideways, splitting his ribs and cutting his heart in two. She left the gravebone blade quivering in his chest, the crow on the hilt smiling with its amber eyes, dark blood fountaining from the wound. And with the boy clutched tight to her chest, still spinning like poetry, like a picture, she twisted backward, over the edge of the battlements. And she fell. In turns to come, the next few moments would be the topic of countless taverna tales, dinner table debates, and barroom brawls across the city of Godsgrave. The confusion arose for a number of reasons. Firstly, it was around this moment where Magistrae, Leonides, Tacitus, Phillipi, and virtually every other sanguila and executus in the ringside boxes began vomiting blood from the poisoned goldwine they’d drunk, which proved more than a little distracting. The central plinth was a fair distance from even ringside seats, so it was difficult for many in the audience to see. And last, and most important, the grand cardinal and the consul had just been brutally murdered by the champion of the magni, which left everyone in the crowd a little shocked. Some said the girl fell, the boy in her arms, right into the mouth of a hungry stormdrake. Some said she hit the water, but avoided the drakes, making her escape through the pipes that had vented the ocean out onto the arena floor. And then there were those—discounted as madmen and drunks, for the most part—who swore by the Everseeing and all four of his Holy Daughters that this little slip of a girl, this daemon wrapped in leather and steel who’d just murdered the two highest officials in the Republic, simply disappeared. One moment falling toward the water in the long shadow of the battlements, the next, completely vanished. The arena was in an uproar, fury, dismay, terror. The blood masters collapsed in their seats, or fell to the stone, Leonides and Magistrae dead among them, every gladiatii stable in the Republic beheaded with a single stroke. Duomo lay on the battlements, his face bled white, throat cut to the bone. And beside the grand cardinal, his purple robe drenched with dark heart’s blood, lay the savior of the Republic. Julius Scaeva, the People’s Senator, the man who had bested the Kingmakers and rescued Itreya from calamity, had been assassinated. Ashlinn stole through the city of Bridges and Bones like a knife through a consul’s chest. The sounds of panic were swelling in the arena behind them, the girl’s heart singing as cathedrals all over the city began ringing a death knell. “Black Mother, she did it.” She chewed her lip, stifling a fierce grin. “She did it.” Mercurio sighed. “I’m not sure if you’ve noticed yet, girl, but Mia Corvere and lunacy go together like cigarillos and smoke.” “There’s only one way this ends,” she said. “And you and I both know it. But I’ll come at you frontways. I can promise you that, at least.” The Unfallen nodded, tightened his grip on his blade. “So be it. Sanguii e Gloria.” Mia shook her head. “You can keep the glory, Furian.” She turned her eyes to the consul’s chair. “I’m just here for the blood.” those who do not fear the flame are burned. those who do not fear the blade are bled. and those who do not fear the grave . . .” “ . . . ARE FREE TO BE AND DO WHATEVER THEY WISH. Life is pain, and loss, and sacrifice.” Furian grit his teeth and closed his eyes. “But we should welcome that pain. If it brings us salvation.” The fear. Welling in her belly like poison. She wanted Mister Kindly and Eclipse back, right now. Life was so much easier with no regard for consequence, no thought for pain. Her passengers were what made her strong, allowed her to be a terror of the sands, to spare no thought for hurting or being hurt in kind. She was steel when they were inside her. Without them . . . Without them, what am I? “ . . . I THINK YOU TOO STUPID TO BE FRIGHTENED OF ME, LITTLE MOGGY. BUT ONE TURN, I SHALL TEACH YOU THERE IS A PRICE FOR OWNING TOO MUCH MOUTH AND NOT ENOUGH TEETH . . .” “ . . . tell me, dear mongrel, do you practice these blunt little threats when you’re alone, or do you simply improvise “Thousands would have died. Tens of thousands, maybe. And for what? So one man could wear a crown, and another could place it on his head? I couldn’t do it. I went to my centurion and told him so. He listened patiently as I tried to tell him the wrong of it. And when I was done, he had me beaten near to death, branded a coward, and sold off to the first bidder on the blocks.” Sidonius shook his head. “Six years in chains for one moment of principle. That’s the tithe I paid. But you know what I learned in all the years between then and this, little Crow?” “ . . . No.” Sid fixed Mia in his ice-blue stare. “There’s no softer pillow than a clear conscience.” “What is her name?” Feet stamping, hands clapping, the word reverberating across the sands. “Crow! Crow! Crow! Crow!” Mia looked down at the bloody sword in her hand. Over to Furian, curled in a ball in the dirt, hands to his savaged throat. She raised her eyes to the sanguila’s box, saw Leona on her feet, horrified stare locked on Furian. Arkades stood beside her, hands raised in somber applause. She thought of Godsgrave, of the Venatus Magni, the berth her victory had now assured. She thought of Bryn, her dead brother cradled in her arms as she wailed. She thought of her father, holding her hands as he whisked her around some glittering ballroom, her feet atop his as they danced. Her mother, making her watch as he was hanged, as she whispered the words that would shape Mia forever, as the hope children breathed and adults mourned withered and fell away, floating like ashes on the wind. “Never flinch. Never fear. And never, ever forget.” What is my name? “Crow! Crow! Crow! Crow!” “The magistrae?” Mia raised her eyebrow. “I’ve a penchant for older women, little Crow.” “You’ve a penchant for anything with two tits, a hole and heartbeat, Sid.” Rubbing this prick’s face in his own shit had now become a burning priority. She turned in a circle, taking in the ocean of faces, the blood-drunken cheers, the thundering feet. And for a tiny moment, she ceased being Mia Corvere, the orphaned girl, the darkin assassin, the embodiment of vengeance. She held her arms wide, dripping red onto the sand, and listened to the crowd roar in response. And just for a breath, she forgot what she had been. Knowing only what she’d become. Gladiatii. But there are no girls on the sand. No mothers or daughters. Sons or fathers. Only enemies. You spend a moment worrying about what’s between your opponent’s legs you’ll find your head parted from your body. And what good will your fool cock do you then?” “You’re a lying cunt is what you are.” “There’s an obsidian vault inside the Revered One’s chambers,” Ash spat. “And inside that vault, they keep a ledger of every offering the Church has undertaken. All their patrons. All their shit. When I poisoned the Ministry at the initiation feast, I stole the ledger, Mia. That’s the reason they’ve been hunting me and my da for the past eight months. Not because we betrayed them. Because we knew all their dirty little secrets.” “They’re assassins, of course they would! There’s no sanctity to what the Red Church does. They murder people for money. Half of them are psychopaths and the rest are just sadistic bastards. They’re not servants of some divine Goddess of Night, they’re fucking whores.” “And I’ve two golden rules in this life, little one—never trust a man who speaks of his mother without kindness, and never trust a woman who hides her face without cause.” “The sand is no place for brawlers,” Executus said, his scar creased in a scowl. “It is checkered board. And on it, we play the greatest game of all. A wily opponent may feign weakness. Allow you to exert yourself and learn your patterns, all without breaking a sweat. Overconfidence has ended a thousand fools who’d name themselves gladiatii. Mark this, or it will be the end of you. Now get off my fucking sand.” “Blade Mia. Godsgrave is the only Red Church chapel we’ve managed to rebuild in the eight months since the Luminatii attack. Thanks to Grand Cardinal Duomo and his god-bothering shitheels, I’m one of two bishops servicing the whole fucking Republic, in fact, and with Scaeva running for a fourth term as consul and Godsgrave politics all aflutter, there’s no end of bastards who need killing. So, given that I’m busier than a whorehouse running a two-for-one special, do me the honor of saying thank you, and taking what you’re bloody given.” “Gladiatii fear no death!” Executus continued, spittle on his lips. “Gladiatii fear no pain! Gladiatii fear but one thing—the everlasting shame of defeat! Mark my lessons. Know your place. Train until you bleed. For if you bring such shame upon this collegium, upon your domina, I swear by almighty Aa and all four of his holy fucking Daughters. Executus growled. “Unworthy to lick the shit from my boot. What do you know of glory? It is a hymn of sand and steel, woven by the hands of legends and sung by the roaring crowd. Glory is the province of gladiatii. CASSIUS FOUND ENOUGH MEANING IN LIFE BY ENDING THE LIVES OF OTHERS. HE NEEDED NO MORE THAN THAT . The old man hooked his thumbs into his waistcoat. “Problem with being a librarian is there’s some lessons you just can’t learn from books. And the problem with being an assassin is there’s some mysteries you just can’t solve by stabbing fuck out of them.” “You said I was a girl with a story to tell.” “And what else?” Smoke drifted from the girl’s lips as the old man stared her down. “You said maybe here’s not where I’m supposed to be,” she finally replied. “Which stank like horseshit at the time, and smells even worse now. I proved myself. The Ministry would all be nailed to crosses in the ’Grave if not for me. And I’m sick and bloody tired of everybody around here seeming to forget that.” “You don’t find any irony in earning your place in a cult of assassins by saving half a dozen lives?” “I killed almost a hundred men in the process, Aelius.” “And how do you feel about that?” “What are you, my nursemaid?” Mia snapped. “A killer is what I am. The wolf doesn’t pity the lamb. Looking out over the mezzanine to the endless shelves below, the girl couldn’t help but smile. She’d grown up inside books. No matter how dark life became, shutting out the hurt was as easy as opening a cover. A child of murdered parents and a failed rebellion, she’d still walked in the boots of scholars and warriors, queens and conquerors. The heavens grant us only one life, but through books, we live a thousand. if the unpleasant realities of bloodshed turn your insides to water, be advised now that the pages in your hands speak of a girl who was to murder as maestros are to music. Who did to happy ever afters what a sawblade does to skin. “Slender” is a poet’s way of saying “starved.” “The largest of the three suns is a furious red globe called Saan. The Seer. Shuffling across the heavens like a brigand with nothing better to do, Saan hangs in the skies for near one hundred weeks at a time. The second sun is named Saai. The Knower. A smallish blue-faced fellow, rising and setting quicker than its brother—” “… sibling…,” the cat corrected. “… old ashkahi does not gender nouns…” “… quicker than its sibling, it visits for perhaps fourteen weeks at a stretch, near twice that spent beyond the horizon. The third sun is Shiih. The Watcher. A dim yellow giant, Shiih takes almost as long as Saan in its wanderings across the sky.” Peacock’s mouth opened as she introduced her boot to his partner’s groin, kicking him hard enough to cripple his unborn children. And as simple as that, our girl’s tally of endings had multiplied threefold. Pebbles to avalanches. “You can drag the girl from the gutter, but never the gutter from the girl.” “You imagine an oaf, don’t you?” Mia continued. “Someone so full of wank there’s no room for wits. A slow-minded bastard who struts about full of spunk and completely ignorant of how he looks to others.” “Truth is, there’s no difference between your nethers and mine. Aside from the obvious, of course. But one doesn’t carry any more weight than the other. Why should what’s between my legs be considered any smarter or stupider, any worse or better? It’s all just meat, Don Tric. In the end, it’s all just food for worms. Just like Duomo, Remus, and Scaeva will be.” “Corvere and his cronies got off light with that hanging. Their commonborn troops have been crucified along the banks of the Choir. Rumor is they’re going to pave the Senate House streets with their skulls. A lot of those soldiers had familia ’round here. So, I’d not walk about with a traitor’s mark pinned to my tits were I you.” “You’ve heard the saying the quickest way to a man’s heart is through his stomach?” “I always wondered about that,” Tric frowned. “Ribcage seems much quicker to me.” “True enough. - “Bastard I might be,” Tric spat. “But you’re the one who decides to be a cunt every turn of your life.” Mia had her knife out, smiling. “That’s the sweetest thing you’ve ever said to me.” His was the beauty of a fresh suicide, laid out in a new pine box. The kind of beautiful you know will spoil after an hour or two in the ground. “All power comes with a tithe. We all pay a price. Speakers, their hunger. Weavers, their impotence. And those who call the Dark…”—Drusilla looked down to Mia’s shadow—“… well, eventually it calls them back.” The trust of a woman who can lead you to your kill? How will steel serve you then?” “I’m told hot coals work wonders in those situations.” “Warm skin serves better still. And leaves fewer “They will never see the knife in your hand if they are lost in your eyes. They will never taste the poison in their wine when they are drunk on the sight of you.” A small shrug. “Beauty simply makes it easier, love. Easier than you have it now. It may be sad. It may be wrong. But it is also true.” “It may not be right,” Aalea said. “It may not be just. But this is a world of senators and consuls and Luminatii—of republics and cults and institutions built and maintained almost entirely by men. And in it, love is a weapon. Sex is a weapon. Your eyes? Your body? Your smile?” She shrugged. “Weapons. And they give you more power than a thousand swords. Open more gates than a thousand war walkers. Love has toppled kings, Mia. Ended empires. Even broken our poor, sunsburned sky.” It all made sense now. Aalea’s unearthly beauty. Mouser’s young face and old eyes. Even the Revered Mother’s facade of homely warmth. She understood this room’s name at last. The Hall of Masks. Daughters, it might apply to the entire Mountain. Killers within—killers all—hiding behind facades not of ceramic or wood, but flesh. Beauty. Youth. Soft maternity. How better to maintain a cadre of anonymous assassins than by reshaping their faces whenever the need struck? How better to seduce a mark or blend into a crowd or be met and instantly forgotten than by crafting a face suited to the task? How better to make us forget who we were, and shape us into what they want us to be? “That is how it begins. The weaving is only the first of it. The butterfly remembers being the caterpillar. But do you think it feels anything but pity for that thing crawling in the muck? Once it has spread those beautiful wings and learned to fly?” “That is how it begins. The weaving is only the first of it. The butterfly remembers being the caterpillar. But do you think it feels anything but pity for that thing crawling in the muck? poison is a sword with no hilt, children. There is only the blade. Double-edged and ever-sharp. To be handled with utmost care lest it bleed you to your ending.” “Well, he might’ve had a hard time convincing the Senate there was still a crisis, but when an assassin tries to murder the head of the Republic in a cathedral full of witnesses, it gets a touch easier to make the case. The Truedark Massacre showed the Senate just how dangerous this city still is. You’d need a bloody army to get through to Scaeva now. He doesn’t take a piss without a cadre of Luminatii to hold the pot.” Mia sipped her whiskey. Eyes on the table. “Cardinal Duomo is still on Scaeva like a babe at his mother’s tit, of course,” Mercurio muttered. “Has his ministers preaching from the pulpits, praising our ‘glorious consul’ and his ‘golden age of peace.’” The old man scoffed. “Golden age of tyranny, more like it. We’re closer to a new arse on the throne than when the Kingmakers raised their army. But the plebs lap it up. Peace means stability. And stability means money. Scaeva’s near untouchable now.” “A shard of glass can slice a man’s throat. Pierce his heart clean. Open his wrists to the bone. But press it in the wrong place, glass with shatter. Iron will not.” “A shard of glass can slice a man’s throat. Pierce his heart clean. Open his wrists to the bone. matters not what you are,” Cassius said. “Only that you are. And if you seek an answer to some greater riddle of yourself, seek it not from me until you’ve earned it. In one measure, and one measure alone, you You are beauty and a philosopher. be still, my beating heart…” “The brighter the light, the deeper the shadow.” Focusing on the task. The comfort of the rote. “That goat-loving, mule-sucking, pig-fucking sonofabitch,” Ash growled. “Righteous brothers,” Remus began. “This eve, we strike a blow against a blasphemy that has blackened our glorious Republic for decades. The ministers of this godless church are to be brought back alive to Godsgrave for interrogation. But any other night-worshipping bastard you cross within these walls is to be shown no mercy. We are the right hand of Aa, and this eve, we bring this house of heresy to its knees.” “Righteous brothers,” Remus began. “This eve, we strike a blow against a blasphemy that has blackened our glorious Republic for decades. The ministers of this godless church are to be brought back alive to Godsgrave for interrogation. But any other night-worshipping bastard you cross within these walls is to be shown no mercy. We are the right hand of Aa, “Hear me, Aa. Hear me, Father. Your flame, my heart. Your light, my soul. For your name, and your glory, and your justice, I march. Shine upon me.” Remus raised his head. Nodded at his men. “Luminus Invicta.” “Hear me, Niah,” she whispered. “Hear me, Mother. This flesh your feast. This blood your wine. This life, this end, my gift to you. Hold him close.” But again, at the final hurdle, she’d stumbled. And she’d fallen. “Story of my life,” she muttered. “Every nevernight since I was ten years old, I’ve dreamed of killing you. You and Scaeva and Duomo. I gave up everything. Any chance I ever had of ever being happy. Every turn, I’d picture your face and imagine all the things I’d say to let you know just how much I hate you. It’s all I am anymore. It’s all that’s left inside me. You killed me, Remus. Just as sure as you killed my familia.” Mia raised her sword, leveled it at Remus’s head. “And now, I’m going to kill you.” “O, fuck off, god-botherer,” Ashlinn snarled. “I’m not in this for your glorious Republic and I don’t give a shit about you or your men. If I wanted a trump card up my sleeve, that’s my business. And in case you missed it, it just saved your miserable life. So instead of bleating about it, maybe you should end the girl who just tried to murder you, then go make sure the rest of the Ministry is still under lock and key? Unless you and your merry band of idiots want to accidentally gut them, too?” “You’ll never know my name, I’m afraid,” she said. “It’s the shadow road for me. I’m a rumor. A whisper. The thought that wakes the bastards of this world sweating in the nevernight. And you are a bastard, Swordbreaker of the Threedrake clan. A bastard I made a promise about to someone I cared for, not so long ago.” I suppose now you think you know her. The girl some called Pale Daughter. Or Kingmaker. Or Crow. The girl who was to murder as maestros are to music. Who did to happy ever afters what a sawblade does to skin. Look now upon the ruins in her wake. As pale light glitters on the waters that drank a city of bridges and bones. As the ashes of the Republic dance in the dark above your head. Stare mute at the broken sky and taste the iron on your tongue and listen as lonely winds whisper her name as if they knew her too. Do you think she would laugh or weep to see the world her hand has wrought? Do you think she knew it would come to this? Do you really know her at all? Not yet, little mortal. Not yet by half. But after all, this tale is only one of three. Birth and life and death. So take my hand now. Close your eyes. And walk with me. “Pigs. Paupers. Cattle. Kings. It makes no difference to Our Lady. It all stains alike. And it all washes out the same.” “Go,” he finally said. “May Our Lady be late when she finds you. And when she does, may she greet you with a kiss.” “One stipulation,” the big man said, holding up his finger. “An item of import to your patron. A map, written in Old Ashkahi and set with a seal shaped like a sickle’s blade. The Dona is brokering an exchange with the map’s current owner. You must take the map, along with her life.” “ . . . What’s the map of?” “It provides detailed directions to the Empire of None of Your Fucking Concern.” “Who is this patron, Shahiid?” “Irrelevant,” Solis scowled. “All you need know is that, miracle of miracles, they are pleased with your results. You are being sent after bigger game.” Mia looked Solis up and down, considering. From the scowl at his brow, the tension in his jaw, she’d wager her last coin the Revered Father had violently objected to her assignment. But despite that, she’d been appointed anyway. Which meant this patron was powerful. Or rich. Or both. Well, that narrows it down . . . “So what new backwater does my illustrious patron send me to?” Mia asked. “Last Hope? Amai? Sto—” “Godsgrave,” Mouser replied. Mia’s tongue cleaved to her teeth, her heart running quicker. Maw’s teeth. The ’Grave . . . The capital of Itreya. Only the Church’s finest Blades served in the City of Bridges and Bones. Grand Cardinal Duomo lived there, as did Consul Scaeva. If Mia wanted revenge for her familia, her first step was getting close to the men who murdered them. If she’d somehow lucked into a dream posting . . . “I know your mind,” Solis growled. “I know why you came to this Church and what it is you seek. So, while I am sending you to the capital against my better judgment, I am telling you this now, and I am telling you once.” Solis towered over her, blind eyes boring into Mia’s own. “Consul Julius Scaeva is not to be touched.” Mia scowled. “Wh—” “I will not tolerate you pursuing your own vendettas while serving this Ministry,” Solis said. “You already murdered a bara of the Dweymeri out of some misplaced sympathy for the boy you were bedding. I’ll not have another unsanctioned kill wrought by your hand. Or your quim.” “Who I bed is my concern. And you don’t get to dec—” “I do decide!” Solis roared. “I am Revered Father of this congregation! I give not a beggar’s cuss for who you wet the furs with, but Swordbreaker was a fucking king! What if he’d been a patron of this Church? We’d have breached Sanctity! Our reputation shattered over a child’s whim.” “It wasn’t a whim, it was a promise!” “Let us speak of promises, then, girl,” Solis spat. “Disobey me, and I promise you an ending from which even the Goddess herself would avert her gaze. Scaeva is not to be touched!” “And why not?” Mia looked among the Ministry, her anger finally getting the better of her. “The Luminatii killed Lord Cassius, almost killed all of you! You think Scaeva didn’t order it? Remus was a fucking lapdog. You think he took a piss without asking the consul’s permission first?” “Hear me now!” Solis raised a finger in warning, blind eyes flashing. “Scaeva will be dealt with. But in our own way. In our own time. You are a servant of Our Lady of Blessed Murder, and in the Mother’s name, that means you fucking serve!” Mia felt her cheeks flush with rage. She stared into Solis’s blind eyes and imagined drawing the gravebone stiletto in her sleeve. Cutting his throat. Spilling his steaming guts onto the floor. But amid the outrage, a single, ice-cold thought took her by the scruff of the neck and shook her ’til she was still. . . . He’s right. She had been childish. She had risked the Church’s reputation in killing Swordbreaker. She had thought to kill Duomo and Scaeva if she got back to the ’Grave. Her knuckles were white on the book in her grip. But she forced her fingers to unclench, speaking words that rang heavy in the quiet dark. “In the Mother’s name. I will serve.” “And you, Speaker.” Adonai’s pretty lips twisted in a knowing smile, but Mia kept her face like stone. The speaker was a picture, no doubt. And Mia had entertained her share of fantasies; lying in bed and picturing his pale, clever fingers as her own roamed ever lower. She’d even saved his and his beloved sister’s lives during the Luminatii attack. But Mia couldn’t fool herself into thinking of him as anything but a blackhearted bastard. Still. A fuckable bastard . . . Pig’s blood has a very peculiar taste. The blood of a man is best drunk warm, and leaves a hint of sodium and rust clinging to the teeth. Horse’s blood is less salty, with an odd bitterness almost like dark chocolate. But pig’s blood has an almost buttery quality, like oysters and oiled iron, slipping down your throat and leaving a greasy tang in its wake. Mia was thankful for the chance to show her worth. But problem was, her list of throats to slit was growing longer, not shorter. She’d killed Justicus Remus, but Consul Scaeva and Grand Cardinal Duomo still lived. Her familia were still unavenged. And with Tric’s murder at Ashlinn’s hands during the Luminatii attack, she now had one more windpipe to open before her vengeance was done. And stuck here in Galante, she was no closer to any of them. “You’re next, prettyboy.” The fighter (who was rather pretty) looked to his fellows, the corpse on the ground, and finally to the ledgerman. The greasy fellow glanced up at the sanguila, who were now staring at Mia intently. And turning back to the swordsman, he nodded. The fighter stepped forward, Mia skipped up to meet him. Their match lasted less than ten seconds, ending with Mia’s bootprint embedded in the man’s crotch and her wooden sword shoved down his pretty throat, all the way to the hilt. The girl turned to the crowd and curtseyed again. “A hundred priests,” came the call. “One hundred and ten.” Mia smiled behind her hair as sanguila began bidding. Within moments, her bid was two hundred silver coins—a decent sum by anyone’s measure. But as she looked up into the bleachers, she saw Leonides and Titus hadn’t uttered a word. Though the sanguila watched her intently, though Teardrinker was whispering in Titus’s ear and he was nodding slow, Leonides didn’t raise his voice to bid. Time to stoke the flame. Mia retrieved her wooden blade from the dead fighter’s throat, turned to the third and spoke loud enough for the bleachers to hear. “You. Next.” The big man looked at the two corpses at Mia’s feet. “Fuck that,” he scoffed. “Bring your friends.” Mia smiled at the fighters beside him. “I’ve always wanted to try three at once.” The girl tossed her wooden sword onto the dirt. “Or are you cowards all?” The crowd hooted and jeered, and the fighters rankled. To be bested on their own soil was one thing, but to eat a plateful of shit from an unarmed girl half their size was another. With flashing eyes and swords raised, the men stepped out into the Pit. “Or are you cowards all?” The crowd “I KNOW THAT YOU ARE MEANT FOR MORE THAN THIS,” it said. “YOUR TRUTH LIES BURIED IN THE GRAVE. AND YET YOU PAINT YOUR HANDS IN RED FOR THEM, WHEN YOU SHOULD BE PAINTING THE SKIES BLACK.” “ . . . o, joys, a cryptic one . . .” “YOUR VENGEANCE IS AS THE SUNS, MIA CORVERE. IT SERVES ONLY TO BLIND YOU.” “What the fuck are you talking about?” Mia heard shouts, turning toward the sound of approaching boots. “SEEK THE CROWN OF THE MOON.” And though her hand trembled, she carried that steel like she knew how to swing it. Luka had dropped faster than a bride’s unmentionables on her wedding night. It takes a while for them to really start reeking. O, chances are good if you don’t soil your britches before you die, you’ll soil them soon afterward—your human bodies simply work that way, I’m afraid. But I don’t mean the pedestrian stink of shit, gentlefriends. I speak of the eye-watering perfume of simple mortality. It takes a turn or two to really warm up, but once the gala gets into full swing, it’s one not soon forgot. ","permalink":"https://atharvashah.netlify.app/blog/book-quotes/the-best-quotes-from-nevernight-trilogy-by-jay-kristoff/","summary":"Let\u0026rsquo;s not mess around here. This series has just more than quotes to offer so I have included rich descriptive texts that boil the blood and wake something deep inside. Here\u0026rsquo;s to the good times fellas. Read on for some savage blood-curdling brutalism.\nThe deed is done. The war is won. And at the last, gentlefriend, her song is sung. I suppose you can say you know her now, at least as well as I did.","title":"The Best Quotes from Nevernight Trilogy by Jay Kristoff"},{"content":"Currently, I have only managed to finish off the first trilogy in the mammoth that Realm of the Elderlings happens to be but I plan to power through the series soon and add the remainder of the quotes so sit back and enjoy what I have to offer. If you feel a few hidden gems are missing, email me!\nFarseer Trilogy Assassin’s Apprentice When you cut pieces out of the truth to avoid looking like a fool you end up looking like a moron instead. Don’t do what you can’t undo, until you’ve considered what you can’t do once you’ve done it. Very little worth knowing is taught by fear. Nothing takes the heart out of a man more than the expectation of failure. When you spring to an idea, and decide it is truth, without evidence, you blind yourself to other possibilities. Too late to apologize, I\u0026rsquo;ve already forgiven you. Most prisons are of our own making. A man makes his own freedom, too. Learning is never wrong. Even learning how to kill isn\u0026rsquo;t wrong. Or right. It\u0026rsquo;s just a thing to learn, a thing I can teach you. That\u0026rsquo;s all. My silences he mistook for a lack of wit rather than a lack of any need to speak. I think myself cured of all spite, but when I touch pen to paper, the hurt of a boy bleeds out with sea-spawned ink, until I suspect each carefully formed black letter scabs over some ancient scarlet wound. Locked into loneliness were we two and looking at one another every evening we each saw the one we blamed for it. I have since come to know that many men always see another’s good fortune as a slight to themselves If you can read, you can learn anything. If you’ve a will to. For there is a very strange peace in giving over your judgment to someone else, to saying to them, “You lead and I will follow, and I will trust entirely that you will not lead me to death or harm.” You\u0026rsquo;re not especially strong, or fast, or bright. Don\u0026rsquo;t think you are. But you\u0026rsquo;ll have the stubborness to wear down anyone stronger, or faster, or brighter than yourself. I\u0026rsquo;ll be teaching you the nasty, furtive, polite ways to kill people When you spring to an idea, and decide it is truth, without evidence, you blind yourself to other possibilities For it is said, one may ask of the Elderlings, but what they answer may not be the question you ask, but the one you should have asked. And the answer to that question may be one a man cannot hear and live. what I have become. And so I begin again, and again, but always find that I am writing of my own beginnings rather than the beginnings of this land. I do not even know to whom I try to explain myself. My life has been a web of secrets, secrets that even now are unsafe to share. Shall I set them all down on fine paper, only to create from them flame and ash? Perhaps. My memories reach back to when I was six years old. Before that, there is nothing, only a blank gulf I know you meant no harm by it, boy. But men don’t talk about times spent among the pillows with a lady. And assassins don’t talk about…our business.” We all get used to things we once swore we could never live with If ever you make it so they don\u0026rsquo;t need you, they will kill you. I’d have wished myself elsewhere, but there is something in a boy that takes the mundanely difficult and unpleasant and turns it into a personal challenge and an adventure. I idly wished for something else, for any situation that was neither this forsaken chamber nor the tenseness of Burrich’s room. For a restfulness that perhaps I had once known somewhere else but could no longer recall. And so I drowsed into oblivion. But take him now, Regal, and shape him, and a decade hence you will command his loyalty. [\u0026hellip;] A bastard, Regal, is a unique thing. Put a signet ring on his hand and send him forth, and you have created a diplomat no foreign ruler will dare to turn away. He may safely be sent where a prince of the blood may not be risked. Imagine the uses for one who is and yet is not of the royal bloodline. Hostage exchanges. Martial alliances. Quiet work. The diplomacy of the knife. Royal Assassin He shook his head pityingly. “This, more than anything else, is what I have never understood about your people. You can roll dice, and understand that the whole game may hinge on one turn of a die. You deal out cards, and say that all a man\u0026rsquo;s fortune for the night may turn upon one hand. But a man\u0026rsquo;s whole life, you sniff at, and say, what, this naught of a human, this fisherman, this carpenter, this thief, this cook, why, what can they do in the great wide world? And so you putter and sputter your lives away, like candles burning in a draft.” “Not all men are destined for greatness,” I reminded him.“Are you sure, Fitz? Are you sure? What good is a life lived as if it made no difference at all to the great life of the world? A sadder thing I cannot imagine. Why should not a mother say to herself, if I raise this child aright, if I love and care for her, she shall live a life that brings joy to those about her, and thus I have changed the world? Why should not the farmer that plants a seed say to his neighbor, this seed I plant today will feed someone, and that is how I change the world today?” “This is philosophy, Fool. I have never had time to study such things.” “No, Fitz, this is life. And no one has time not to think of such things. Each creature in the world should consider this thing, every moment of the heart\u0026rsquo;s beating. Otherwise, what is the point of arising each day? Stop thinking of what you intend to do. Stop thinking of what you have just done. Then, stop thinking that you have stopped thinking of those things. Then you will find the Now, the time that stretches eternal, and is really the only time there is. Men of passion and vision are often seen as mad. The fight isn\u0026rsquo;t over until you win it, Fitz. That\u0026rsquo;s all you have to remember. No matter what the other man says. I have heard it called a dance, I have heard it called a battle. Some men speak of it with a knowing laugh, some with a sneer. I have heard the study market women chuckling over it like hens clucking over bread crumbs; I have been approached by bawds who spoke their wares as boldly as peddlers hawking fresh fish. For myself, I think some things are beyond words. The color blue can only be experienced, as can the scent of jasmine or the sound of a flute. The curve of a warm bared shoulder, the uniquely feminine softness of a breast, the startled sound one makes when all barriers suddenly yield, the perfume of her throat, the taste of her skin are all but parts, and sweet as they may be, they do not embody the whole. A thousand such details still would not illustrate it. The separate parts of my life became like beads and I the string that ran through them all. I believe if I had ever paused to consider the intricacy of all I did to keep those parts separate, I would have found it impossible. But I was young then, much younger than I suspected, and somehow I found the energy and time to do and be it all. Some things may be learned from words on a page, but some skills are learned first by a man’s hands and heart, and later by his head. But we are two old men, who have grown old together. Sometimes that is a greater closeness. We have come through time to your day and age. We can talk together, quietly, and share memories of a time that exists no more. I can tell you how it was, but it is not the same. It is like being two foreigners, trapped in a land we have come to, unable to return to our own, and having only each other to confirm the reality of the place we once lived. My head cleared, and suddenly I had heart to fight again, to ignore pain and damage, to fight! I swear I saw myself, face purpled from strangling, the rich blood streaming and soaking and the smell so maddening. When I had encountered the Skill joy, I had not found it the tawdry pleasure Galen had implied. Rather, it had been the same rush of blood and thunder of earth that sometimes music brought to me, or a sudden flight of bright pheasant in an autumn wood, or even the pleasure of taking a horse perfectly over a difficult jump. That instant when all things come into balance, and for a moment turn together as perfectly as birds wheeling in flight. There is a place where all time is now, and the choices are simple and always your own. Accept the discipline, live up to the task. I fancied that if I sat very still, I could still feel the warmth of Molly\u0026rsquo;s arms around me. I knew precisely where her cheek had touched mine. A very faint scent of her clung to my shirt from our brief embrace, and I agonized over whether to wear the shirt that day, to carry that scent with me, or to set it aside carefully in my clothing chest, to preserve it. I did not think it a foolish thing at all to care so much about that. Looking back, I smile, but it is at my wisdom, not my folly. Does no one around here ever use the healer? Always I have possessed the loneliness of one raised amid intrigues and clustering secrets, the isolation of a boy who cannot trust the completeness of his heart to anyone. We cannot put old heads on young shoulders. Assassin’s Quest There is a dead spot in the night, that coldest, blackest time when the world has forgotten evening and dawn is not yet a promise. A time when it is far too early to arise, but so late that going to bed makes small sense. Someday is someday, and maybe it will be or maybe it won\u0026rsquo;t. This is a human thing, to worry about things that may or may not come to be. You can\u0026rsquo;t eat meat until you\u0026rsquo;ve killed it. \u0026hellip;To free humanity of time. For time is the great enslaver of us all. Time that ages us, time that limits us. Think how often you have wished to have more time for something, or wished you could go back a day and do something differently. When humanity is freed of time, old wrongs can be corrected before they are done. No. This is right. I feel it. I am the Catalyst, and I came to change all things. Prophets become warriors, dragons hunt as wolves. You will live to love again. You know you have lost your springtime girl, your Molly on the beach with the wind in her brown hair and red cloak. You have been gone too long from her, and too much has befallen you both. And what you loved, what both of you truly loved, was not each other. It was the time of your life. It was the spring of your years, and life running strong in you, and war on your doorstep and your strong, perfect bodies. Look back, in truth. You will find you recall fully as many quarrels and tears as you do lovemaking and kisses. Fitz. Be wise. Let her go, and keep those memories intact. Save what you can of her, and let her keep what she can of the wild and daring boy she loved. Because both he and that merry little miss are no more than memories anymore.\u0026quot; She shook her head. \u0026ldquo;No more than memories. Somewhere inside me, a madman raged in his cell, but I chose not to know of that. You are not a man as ordinary men are. They think they have a right to all beasts; to hunt them and eat them, or to subjugate them and rule their lives. You know you have no such right to mastery. The horse that carries you will do so because he wishes to, as does the wolf that hunts beside you. You have a deeper sense of yourself in the world. You believe you have a right, not to rule it, but to be part of it. Predator or prey; there is no shame to being either one. I looked at her, wanting her with all the lust of my months alone and untouched. But I knew also that for that deeper hunger for companionship and understanding, she offered me no more solace than any man might find in his own hand. Other men might dream of high honors or riches or deeds of valor sung by minstrels. I wanted to come to a small cot as light faded, to sit in a chair by a fire, my back aching from work, my hands rough with toil, and hold a little girl in my lap while a woman who loved me told me of her day. Perhaps there can be no thanks nor any blame, but only recognition of the forces that brought us and bound us to our inevitable fates. Some people say there is relief in the sharing of cares and pains. To me there was no catharsis, only an unearthing of rotting corpses of memories, a baring of still suppurating wounds. All of history, a great wheel, turning inexorably. Just as seasons come and go, just as the moon moves endlessly through her cycle, so does time. The same wars are fought, the same plagues descend, the same folk, good or evil, rise to power. Humanity is trapped on that wheel, doomed endlessly to repeat the mistakes we have we have already made. Unless someone comes to change it. I take myself with me. That\u0026rsquo;s all I truly need, or own. He pleasures his body with drugs and deadens his soul with his savage amusements. Aye, and spreads the disease to those around him, until they take no satisfaction in a contest of skill that draws no blood, until games are only amusing if lives are wagered on the outcome. In every building, in every garden, at every turn the visitor finds the austere beauty and simplicity of color and form that are the Mountain ideal. The overall impression that one carries away is of tranquillity and joy in the natural world. The chosen simplicity of life there may lead the visitor to question his own choice in life. Take my memories of my mother, and the feelings that went with them. I do not want to know them at all. Take the ache in my throat when I think of Molly, take all the sharp-edged, bright-colored days I recall with her. Take their brilliance and leave me but the shadows of what I saw and felt. Let me recall them without cutting myself on their sharpness. Take my days and nights in Regal’s dungeons. It is enough to know what was done to me. Take it to keep, and let me stop feeling my face against that stone floor, hearing the sound of my nose breaking, smelling and tasting my own blood. Take my hurt that I never knew my father, take my hours of staring up at his portrait when the great hall was empty and I could do so alone. Take my— Fitz. Stop. You give her too much, there will be nothing left of you. I know of nothing more warming than hot meat and tea and good fellowship. I supposed there was something about me that made all elderly folk assume my time was at their disposal. Death is always at the edge of now. Liveship Traders Trilogy Ship of Magic The Mad Ship Ship of Destiny Tawny Man Trilogy Fool’s Errand Golden Fool Fool’s Fate Rain Wild Chronicles Dragon Keeper Dragon Haven City of Dragons Blood of Dragons The Fitz and the Fool Trilogy Fool’s Assassin Fool’s Quest Assassin’s Fate ","permalink":"https://atharvashah.netlify.app/blog/book-quotes/the-best-quotes-from-realm-of-the-elderlings-by-robin-hobb/","summary":"Currently, I have only managed to finish off the first trilogy in the mammoth that Realm of the Elderlings happens to be but I plan to power through the series soon and add the remainder of the quotes so sit back and enjoy what I have to offer. If you feel a few hidden gems are missing, email me!\nFarseer Trilogy Assassin’s Apprentice When you cut pieces out of the truth to avoid looking like a fool you end up looking like a moron instead.","title":"The Best Quotes from Realm of the Elderlings by Robin Hobb"},{"content":"Vol 1: Preludes and Nocturnes But where shall wisdom be found? And where is the place of understanding? Man knoweth not the price thereof; neither is it found in the land of the living … for the price of wisdom is above rubies. CHORONZON: I am a dire wolf, prey-stalking, lethal prowler. MORPHEUS: I am a hunter, horse-mounted, wolf-stabbing. CHORONZON: I am a horsefly, horse-stinging, hunter-throwing. MORPHEUS: I am a spider, fly-consuming, eight legged. CHORONZON: I am a snake, spider-devouring, posion-toothed. MORPHEUS: I am an ox, snake-crushing, heavy-footed. CHORONZON: I am an anthrax, butcher bacterium, warm-life destroying. MORPHEUS: I am a world, space-floating, life-nurturing. CHORONZON: I am a nova, all-exploding\u0026hellip; planet-cremating. MORPHEUS: I am the Universe \u0026ndash; all things encompassing, all life embracing. CHORONZON: I am Anti-Life, the Beast of Judgment. I am the dark at the end of everything. The end of universes, gods, worlds\u0026hellip; of everything. Sss. And what will you be then, Dreamlord? MORPHEUS: I am hope. I will be a wise and tolerant monarch, dispensing justice fairly, and only setting nightmares to rip out the minds of the evil and wicked. Or just anybody I don\u0026rsquo;t like. You are utterly the stupidest, most self-centered, appallingest excuse for an anthropomorphic personification in this or any other plane! You get what anybody gets - you get a lifetime. What power would hell have if those imprisoned here would not be able to dream of heaven? I think I’ll dismember the world and then I’ll dance in the wreckage. Vol 2: The Doll’s House There is another version of the tale. That is the tale the women tell each other, in their private language that the men-children are not taught, and that the old men are too wise to learn. And in that version of the tale perhaps things happened differently. But then, that is a women\u0026rsquo;s tale, and it is never told to men. For love is no part of the dream-world. Love belongs to desire, and desire is always cruel. And they left, slowly, one by one, with reluctance, leaving the safety of the light for the chill certainties of the darkness. It seemed like the night sucked them up, took them into its dark heart. It seemed like the darkness swallowed them … perhaps it did. If my dream was true, then everything we know, everything we think we know is a lie. It means the world\u0026rsquo;s about as solid and as reliable as a layer of scum on the top of a well of black water which goes down forever, and there are things in the depths that I don\u0026rsquo;t even want to think about. It means that we\u0026rsquo;re just dolls. We don\u0026rsquo;t have a clue what\u0026rsquo;s really going down, we just kid ourselves that we\u0026rsquo;re in control of our lives while a paper\u0026rsquo;s thickness away things that would drive us mad if we thought about them for too long play with us, and move us around from room to room, and put us away at night when they\u0026rsquo;re tired, or bored. And Desire walks the endless pathways of its body, certain that he, or she, or it, is in sole and only control of its destiny. The only inhabitant of the twilight realm of Desire; and it feels nothing like a doll. Nothing like a doll at all. Human beings are the creatures of desire. They twist and bend as I require it. If I thought otherwise, I would crack, like Delirium or I would abandon my realm, like our lost brother. If there is a moral to this part of the story, and I distrust morals in the same way that I distrust beginnings, it is simply this: know that with which you deal. I am coming through the barriers you have erected in this mind. I am coming, though the way be ardous and strange. Nothing will stop me. As I travel, I admire the craftsmanship in the construction of this maze, admire the traps and pitfalls they have wrought. You have learned well, my servants. To force the child to construct these barriers insides its mind, in its effort to escape the physical world; to build an island of dream alone and untouched by the true Dreaming\u0026hellip; This takes skill. My admiration does not lessen my anger. I am dream. I am coming. Vol 3: Dream Country The fraternity of critics, in reality a dark brethren, linked by profane rites and blood vows. To destroy an author they sacrifice a child and perform a critical mass. Gryphons shouldn\u0026rsquo;t marry. Vampires don\u0026rsquo;t dance. A man who inherits a library card to the library in Alexandria. A rose bush, a nightingale, and a black rubber dog-collar. Justice?\u0026quot; It repeated. \u0026ldquo;Justice is a delusion you will not find on this or any other sphere. And wisdom? Wisdom is no part of dreams, lithe walker, though dreams are a part of the sum of each life\u0026rsquo;s experiences, which is the only wisdom that matters. But revelation? That is the province of dream. If enough of us dream, if a bare thousand of us dream, we can change the world. We can dream it anew! A world in which no cat suffers from the malice of humans. In which no cats are killed by human caprice. A world that we rule. Dream the world. Not this pallid shadow of reality. Dream the world the way it truly is. A world in which all cats are queens and kings of creation. That is my message. And I shall keep moving, keep repeating it, until I die. Or until a thousand cats hear my words, and believe them, and dream, and we come again to paradise. It is a fool\u0026rsquo;s prerogative to utter truths that no one else will speak. I am that merry wanderer of the night\u0026rsquo;? I am that giggling-dangerous-totally-bloody-psychotic-menace-to-life-and-limb, more like it. Things have changed, and will change more; and Gaia no longer welcomes us as once she did. But he did not understand the price. Mortals never do. They only see the prize, their heart\u0026rsquo;s desire, their dream\u0026hellip; But the price of getting what you want, is getting what once you wanted. The lunatic, the lover, and the poet are of imagination all compact — One sees more devils than vast hell can hold. That is the madman. The Lover, all as frantic, sees Helen\u0026rsquo;s beauty in a brow of egypt. The poet\u0026rsquo;s eye, in a fine frenzy rolling, doth glance from heaven to earth, from earth to heaven. And, as imagination bodies forth the forms of things unknown, the poet\u0026rsquo;s pen turns them to shapes, and gives to airy nothing a local habitation and a name. And you\u0026rsquo;ve come for me? Blessed, merciful death. You\u0026rsquo;ve come to make it all stop? When the first living thing existed, I was there, waiting. When the last living thing dies, my job is finished. I\u0026rsquo;ll put the chairs on the tables, turn out the lights and lock the universe behind me when I leave. Vol 4: Season of Mists The garden of Destiny. You would know it if you saw it. After all, you will wander it until you die. Or beyond. For the paths are long, and even in death there is no ending to them. The paths fork and divide. With each step you take through Destiny\u0026rsquo;s garden, you make a choice; and every choice determines future paths. However, at the end of a lifetime of walking you might look back, and see only one path stretching out behind you; or look ahead, and see only darkness. Desire smells almost subliminally of summer peaches, and casts two shadows: one black and sharp-edged, the other translucent and forever wavering, like heat haze … Desire smiles in brief flashes, like sunlight glinting from a knife-edge. And there is much else that is knife-like about Desire … never a possession, always the possessor, with skin as pale as smoke, and eyes tawny and sharp as yellow wine: Desire is everything you have ever wanted. Whoever you are. Whatever you are. Everything. Despair, Desire\u0026rsquo;s sister and twin, is queen of her own bleak bourne. It is said that scattered through Despair\u0026rsquo;s domain are a multitude of tiny windows, hanging in the void. Each window looks out onto a different scene, being, in our world, a mirror. Sometimes you will look into a mirror and feel the eyes of Despair upon you, feel her hook catch and snag on your heart. Destiny is the oldest of the Endless; in the beginning was the Word, and it was traced by hand on the first page of his book, before ever it was spoken aloud … Destiny smells of dust and the libraries of night. He leaves no footprints. He casts no shadow. Delirium was once Delight. And although that was long ago now, even today her eyes are badly matched; one eye is a vivid emerald green, spattered with silver flecks that move; her other eye is vein blue. Who knows what Delirium sees, through her mismatched eyes? To absent friends, lost loves, old gods and the seasons of mists. And may each and everyone of us always give the devil his due. I am Breschau of Livonia. I ripped out the tongues of those who spoke against me, and cut the unborn babes from the wombs of my enemies women, that they would not become warriors to rise against me. I took my mother by force, and I strangled my sister when she would not consent to my advances. Soon my name was whispered in the night by mothers to terrify their babes into obedience, I am Breschau, who bathed in the blood of children. I am Breschau, who forced the true prophets of the lord to dance upon plates of hot iron, under which fires were burning, and I laughed as they danced. I am Breschau, and when my mistress was unfaithful to me, I cut the nose from her face and wore it about my neck. As for the woman, I had her sewn to her lover, and, skin to skin, I left them in the desert to be eaten by ravens, and I laughed as I heard them scream. I am Breschau, and this is my punishment. I could never again be an angel … innocence, once lost, can never be regained. Times have changed, and we have changed with them. We are expanding — assimilating other pantheons, later gods, new altars and icons. Marilyn Monroe is ours now, as are King Kong and Lady Liberty. I\u0026rsquo;m the amazing Cain. If you enjoyed our show, tell your friends. If you didn\u0026rsquo;t, I trust you get throat cancer and die without ever again uttering another word. Goodnight. There will be no more wanton violence; no further suffering, inflicted without reason or explanation. We will hurt you. And we are not sorry. But we do not do it to punish you. We do it to redeem you. Because afterward, you\u0026rsquo;ll be a better person … and because we love you. One day you\u0026rsquo;ll thank us for it. Why do they blame me for all their little failings? They use my name as if I spent my entire days sitting on their shoulders, forcing them to commit acts they would otherwise find repulsive. \u0026lsquo;The devil made me do it.\u0026rsquo; I have never made one of them do anything. Never. They live their own tiny lives. I do not live their lives for them. October knew, of course, that the action of turning a page, of ending a chapter or of shutting a book, did not end a tale. Having admitted that, he would also avow that happy endings were never difficult to find: \u0026ldquo;It is simply a matter,\u0026rdquo; he explained to April, \u0026ldquo;of finding a sunny place in a garden, where the light is golden and the grass is soft; somewhere to rest, to stop reading, and to be content. There must be a Hell. A place for demons. A place for the damned. Hell is Heaven\u0026rsquo;s reflection. Heaven\u0026rsquo;s shadow. They define each other. There must be a Hell for without Hell, Heaven has no meaning. Vol 5: A Game of You Everybody has a secret world inside of them. I mean everybody. All of the people in the whole world, I mean everybody — no matter how dull and boring they are on the outside. Inside them they\u0026rsquo;ve all got unimaginable, magnificent, wonderful, stupid, amazing worlds\u0026hellip; Not just one world. Hundreds of them. In the pale light of the Moon I play the game of you. Whoever I am. Whoever you are. All sense of where I am, of who I am and where I’m going, has been swallowed by the dark. And I walk through the stars and sky\u0026hellip; a trinity of dreams beneath the moon. And then it crumbled in his hand. It was just dust\u0026hellip; Sand\u0026hellip; A glittering, multicolored sand that fell away into the chilly wind at the end of the world. Where others ask timorously, Thessalian, your kind commanded, directed, ordered. It galled us. But the others are dust now, and less than dust. And one day you, in your turn, will join them. And then our compact will be over, and you will be ours, as they are. Vol 6: Fables and Reflections It is sometimes a mistake to climb, it is always a mistake never even to make the attempt. Sometimes you wake up. Sometimes the fall kills you. And sometimes, when you fall, you fly. Desire? You disappoint me. This evening\u0026rsquo;s display: bringing back a dead man to offer Norton the pleasures of the world. It was not very subtle. They say that the world rests on the backs of 36 living saints — 36 unselfish men and women. Because of them the world continues to exist. They are the secret kings and queens of this world. Will you kill all the poets, then, St. Just? Will you kill all the dreamers? From that Time on, the Song of Orpheus has always hovered at the Edge of my Perception; a Melody I can never fully recover, try howsoever I will. And do not doubt that there are many in Authority to whom I would sing it, if \u0026rsquo;twere within my Power. Listen, blood of my blood, although I\u0026rsquo;m a hard man to anger, and I love you deeply, if you interrupt me again so help me I\u0026rsquo;ll rip out your throat with my teeth. The young man\u0026rsquo;s mother had died bringing him into the world; she gave him life, a small wooden finger-ring, and the name Vassily. There have been worse legacies. We write our names in the sand, and then the waves roll in and wash them away. Forewarned is seldom forearmed. Not even in the shifting zones. There are really patterns. It was a revelation, of a kind. Dreams and sand and stories. Deserts and cities and time. You attend the funeral, you bid the dead farewell. You grieve. Then you continue with your life. And at times the fact of her absence will hit you like a blow to the chest, and you will weep. But this will happen less and less as time goes on. She is dead. You are alive. So live. Thou hast made the Furies cry, Orpheus. They will never forgive you for that. \u0026ldquo;Abel, the younger brother, had lots of sheep, and he had given the land\u0026rsquo;s creator a sheep as present. Cain, who was the older, grew fruit and vegetables, and he\u0026rsquo;d given the land\u0026rsquo;s creator some of them. The creator liked the sheep best, because it was all funny and fluffy and white — \u0026quot; \u0026ldquo;Because it was warm, steaming meat. It was a bleeding sacrifice, you bloody idiot!\u0026rdquo; There was also in that room the Other Egg of the Phoenix. (For the Phoenix when its time comes to die lays two eggs, one black, one white: From the white egg hatches the Phoenix-bird itself, when its time is come, but what hatches from the black egg no one knows.) You have called me here, Haroun. It is unwise to summon what you cannot dismiss. Bodies are strange. Some people have real problems with the stuff that goes on inside them. You find out that inside someone you know there\u0026rsquo;s just mucus and meat and slime and bone. They menstruate, salivate, defecate and cry. You know? Sometimes it can just kill the romance. You know that? Vol 7: Brief Lives Some things are changeless. People love, and die, they dream, destroy, despair, go mad. They fulfill their destinies, live out the course of their lives. We fulfill our function, as they fulfill theirs\u0026hellip;that will not change. \u0026ldquo;I mean, does this always happen when a girlfriend walks out on him?\u0026rdquo; \u0026ldquo;Not at all. For example, after the Nada affair he razed the Dreaming. It was a bleak, lonely desert for centuries. I remember the first flower that grew. The first time he smiled again …\u0026rdquo; You lived what anybody gets, Bernie. You got a lifetime. No more. No less. \u0026ldquo;What\u0026rsquo;s the name of the word for the precise moment when you realize that you\u0026rsquo;ve actually forgotten how it felt to make love to somebody you really liked a long time ago?\u0026rdquo; \u0026ldquo;There isn\u0026rsquo;t one.\u0026rdquo; \u0026ldquo;Oh. I thought maybe there was.\u0026rdquo; \u0026ldquo;Is there a word for forgetting the name of someone when you want to introduce them to someone else at the same time you realize you\u0026rsquo;ve forgotten the name of the person you\u0026rsquo;re introducing them to as well?\u0026rdquo; \u0026ldquo;No.\u0026rdquo; I know how gods begin, Roger. We start as dreams. Then we walk out of dreams into the land. We are worshipped and loved, and take power to ourselves. And then one day there\u0026rsquo;s no one left to worship us. And in the end, each little god and goddess takes its last journey back into dreams … and what comes after, not even we know. The garden of Destiny. Look behind you: shadow-plays of memory are forever being enacted, on paths you walked too long ago. Do you know why I stopped being Delight, my brother? I do. There are things not in your book. There are paths outside this garden. You would do well to remember that. I like the stars. It\u0026rsquo;s the illusion of permanence, I think. I mean, they\u0026rsquo;re always flaring up and caving in and going out. But from here, I can pretend … I can pretend that things last. I can pretend that lives last longer than moments. Gods come, and gods go. Mortals flicker and flash and fade. Worlds don\u0026rsquo;t last; and stars and galaxies are transient, fleeting things that twinkle like fireflies and vanish into cold and dust. But I can pretend. I like airplanes. I like anywhere that isn\u0026rsquo;t a proper place. I like in betweens. Touched by her fingers, the two surviving chocolate people copulate desperately, losing themselves in a melting frenzy of lust, spending the last of their brief borrowed lives in a spasm of raspberry cream and fear. The stuff you bring back from dreams is free. I walk across the dreaming sands under the pale moon: through the dreams of countries and cities, past dreams of places long gone and times beyond recall. When you dream, sometimes you remember. When you wake, you always forget. Hey, that\u0026rsquo;s life, flick it off if you can\u0026rsquo;t take a joke. To bite off your shadow is neither easy nor painless. It demands a single-mindedness that is almost unknown in this day. Three blind hummingbirds hang in the air like jewels of iridescent scarlet and cobalt; then, one by one, they fade, all color leeched from them, and fall lifeless into the mists, to be eaten by rats. Despair places the cold metal barb of her hook onto the surface of her eye. And then she pushes, piercing cornea and lens, and ripping free the aqueous humor and vitreous humor to run like tears down her cheek, into her hand\u0026hellip;The pain distracts her, a little. But still, she remembers\u0026hellip; Vol 8: World’s End I don\u0026rsquo;t really like driving in snow. There\u0026rsquo;s something about the motion of the falling snowflakes that hurts my eye, throws my sense of balance all to hell. It\u0026rsquo;s like tumbling into a field of stars. You need help, matey. You and that there young lady. That red stuff, that\u0026rsquo;s blood that is. Meant to be on the inside, it is. Bad sign if it\u0026rsquo;s not on the inside, that\u0026rsquo;s what I says. If a city has a personality, maybe it also has a soul. Maybe it dreams. That is where I believe we have come. We are in the dreams of the city. That\u0026rsquo;s why certain places hover on the brink of recognition; why we almost know where we are. \u0026ldquo;If the city was dreaming,\u0026rdquo; he told me, \u0026ldquo;then the city is asleep. And I do not fear cities sleeping, stretched out unconscious around their rivers and estuaries, like cats in the moonlight. Sleeping cities are tame and harmless things. What I fear,\u0026rdquo; he said, \u0026ldquo;is that one day the cities will waken. That one day the cities will rise.\u0026rdquo; We of Faerie are of the wild magic. We are not creatures of spells and grimoires. We are spells, and we are written of in grimoires. The words said over my father\u0026rsquo;s body were hollow and dumb, and I couldn\u0026rsquo;t find it in me to cry, not then. I knew I was watching the real thing here. There was true grief in each step they took across the sky, and they shouldered the casket as if they were shouldering the weight of the world. She looked at me. Maybe she was trying to tell me something; I don\u0026rsquo;t know. She probably didn\u0026rsquo;t even know I was there. But I\u0026rsquo;ll always love her. All my life. It was like I knew her. Like she was my oldest, dearest friend. The kind of person you can tell anything to, no matter how bad, and they\u0026rsquo;ll still love you, because they know you. Is there any person in the world who does not dream? Who does not contain within them worlds unimagined? “Sometimes big things happen, and they echo. Those echoes crash across worlds. They are the ripples in the fabric of things. Often they manifest as storms. Reality is a fragile thing, after all. Nothing you do in the White House matters. You know why not? Because as far as the mass of voting morons is concerned, while you\u0026rsquo;re in office, you\u0026rsquo;ll still be the worst single president they\u0026rsquo;ve ever had until you stop. Then it\u0026rsquo;s some other poor bastard\u0026rsquo;s turn. And even that doesn\u0026rsquo;t matter, because ten, twenty years later, they\u0026rsquo;ll look back on you, and wonder why they didn\u0026rsquo;t appreciate you when they had you\u0026hellip;You don\u0026rsquo;t get to make a difference. You don\u0026rsquo;t get to do jack shit. You know what you get?\u0026hellip;You get an entry in the history book, and every 15 minutes, every day at Disneyworld, an animatronic puppet wearing your face will wave or nod when the spotlight hits it. In the manner of one recognizing a line from a familiar poem in a strange book. Vol 9: The Kindly Ones It\u0026rsquo;s never what they want, and if we give them what they think they want, they like it less than ever. Been there, Remiel. Done that, wore the tee-shirt, ate the burger, bought the original cast album, choreographed the legions of the damned and orchestrated the screaming… You didn\u0026rsquo;t join the rebellion, not because you felt I was wrong, but because you were too damned scared. What would you have done, had I won? Told me that you\u0026rsquo;d always supported me ideologically? That you were secretly cheering me on the whole time? It has always been the prerogative of children and half-wits to point out that the emperor has no clothes. But the half-wit remains a half-wit, and the emperor remains an emperor. The gods we prayed to when we were young used up their time so long ago. They cannot answer anymore. You don\u0026rsquo;t have to believe in God. But what about gods? Eh? The plurality of powers and dominions. The lords and ladies of field and thorn, of asphalt and sewer, gods of telephone and whore, gods of hospital and car-crash? There is a madness needed to touch the gods, yes, this is true. Few mortals possess it, the willingness to step away from the protection of sanity. To walk into the wild woods of madness. I am the mother to Odin\u0026rsquo;s stallion, Sleipnir. I am the father of Fenrir sun-eater and of Hel half-rotted and of Jormungund the world-serpent. I am Loki Scar-Lip, Loki Skywalker, Loki Giant\u0026rsquo;s Child, Loki Lie-Smith. I am Loki, who is fire and wit and hate. I am Loki. And I will be under an obligation to no one. You puzzle me, Dream-Weaver. Are you a spider who\u0026rsquo;s spun a web of cunning and deceit and now waits patiently for his prey to come to him; or are you a deer frozen by the light of a hunter\u0026rsquo;s flame, as disaster comes toward you? And she wrapped her slimy body around his, and she whispered his name into his ear. And he screams, \u0026ldquo;Kill me, for God\u0026rsquo;s sake, just get it over with.\u0026rdquo; But she licked her lips with her long worm tongue, and she shakes her head. \u0026ldquo;A meal this good must never be hurried,\u0026rdquo; she says. \u0026ldquo;Just hold still boy, and let me enjoy myself.\u0026rdquo; And she takes her first, gentle bite from his cheek with her sharp, sharp teeth … Dancing salamanders brought the children silver plates filled with exotic ice-creams of various flavors, and with fruits they had never seen before and would never see again … although they would dream of them, on rare occasions, until they died. The things we do make echos. Our existence deforms the universe. That\u0026rsquo;s responsibility. I am honor-bound to warn you to stay on the path through the castle. Straying from the path could mean your destruction. Have you ever been in love? Horrible, isn\u0026rsquo;t it? It makes you so vulnerable. It opens your chest and it opens up your heart and it means that someone can get inside you and mess you up. You build up all these defenses. You build up this whole armor, for years, so nothing can hurt you, then one stupid person, no different from any other stupid person, wanders into your stupid life… You give them a piece of you. They don\u0026rsquo;t ask for it. They do something dumb one day like kiss you, or smile at you, and then your life isn\u0026rsquo;t your own anymore. Love takes hostages. It gets inside you. It eats you out and leaves you crying in the darkness, so a simple phrase like \u0026ldquo;maybe we should just be friends\u0026rdquo; or \u0026ldquo;how very perceptive\u0026rdquo; turns into a glass splinter working its way into your heart. It hurts. Not just in the imagination. Not just in the mind. It\u0026rsquo;s a soul-hurt, a body-hurt, a real gets-inside-you-and-rips-you-apart pain. Nothing should be able to do that. Especially not love. I hate love. Me? Lady, I\u0026rsquo;m your worst nightmare — a pumpkin with a gun. Gods fear us. Demons fear us. We have hounded kings and angels. We have taken vengeance on worlds and universes. We are the Kindly Ones. We are the Eumenides. This will be felt across worlds and days as a reality storm; and, as it plays its course, conflicting realities will fall and spin and shatter across time and existence. If you don\u0026rsquo;t let me in, I will turn you into a demon half-face waitress night-club lady with a crush on her boss, and I\u0026rsquo;ll make it so you\u0026rsquo;ve been that from the beginning of time to now and you\u0026rsquo;ll never ever know if you were anything else and it will itch inside your head worse than little bugses. It\u0026rsquo;s the same old story … whatever it turns into on the way, whatever it is you originally undertake to spin or knit or weave, keep it going long enough and, in the end, my lilies, it\u0026rsquo;s always a winding sheet. Flowers gathered in the morning, Afternoon they blossom on, Still are withered by the evening, You can be me when I\u0026rsquo;m gone. We make choices. No one else can live our lives for us. And we must confront and accept the consequences of our actions We do what we do, because of who we are. If we did otherwise, we would not be ourselves. I\u0026rsquo;ve been making a list of the things they don\u0026rsquo;t teach you at school. They don\u0026rsquo;t teach you how to love somebody. They don\u0026rsquo;t teach you how to be famous. They don\u0026rsquo;t teach you how to be rich or how to be poor. They don\u0026rsquo;t teach you how to walk away from someone you don\u0026rsquo;t love any longer. They don\u0026rsquo;t teach you how to know what\u0026rsquo;s going on in someone else\u0026rsquo;s mind. They don\u0026rsquo;t teach you what to say to someone who\u0026rsquo;s dying. They don\u0026rsquo;t teach you anything worth knowing. Can\u0026rsquo;t say I\u0026rsquo;ve ever been too fond of beginnings, myself. Messy little things. Give me a good ending anytime. You know where you are with an ending. I suppose the point you grow up is the point you let the dreams go. There\u0026rsquo;s but three Furies found in spacious hell. But in a great man\u0026rsquo;s breast three thousand dwell. Vol 10: The Wake The bonds of family bind both ways. They bind us up, support us, help us, and they are also a bond from which it is difficult, perhaps impossible to extricate oneself. We were never lovers, and we never will be, now. I do not regret that, however. I regret the conversations we never had, the time we did not spend together. I regret that I never told him that he made me happy, when I was in his company. The world was the better for his being in it. These things alone do I now regret: things left unsaid. And he is gone, and I am old. I cared for him, very much. He was so wise; he seemed so certain of the rightness of his actions. And I, who do nothing but doubt, admired that in him. He was a creature of hope, for dreams are hopes, and echoes of hopes, and I am a creature of despair. It\u0026rsquo;s astonishing how much trouble one can get oneself into, if one works at it. And astonishing how much trouble one can get oneself out of, if one simply assumes that everything will, somehow or other, work out for the best. I am banished to the grey waste at the end of the world, but I mourn myself no longer; I cherish the pain in my hand. I imagine the taste of the mulberries in the violet dusk. And tomorrow I shall arrive in the town of Wei. My own fine words notwithstanding, life is no play. We meet people once, and never see them again. There is no shape to events, no point at which we turn to the audience for their praise. No time at which we step behind the stage, to see the actors changing their wigs, and painting their faces, and muttering their lines. Look,i\u0026rsquo;m sorry it\u0026rsquo;s over too. But good things have to end; stories have to end. It\u0026rsquo;s what gives them meaning. Death’s a funny thing. I used to think it was a big, sudden thing, like a huge owl that would swoop down out of the night and carry you off. I don’t anymore. I think it’s a slow thing. Like a thief who comes to your house day after day, taking a little thing here and a little thing there, and one day you walk round your house and there’s nothing there to keep you, nothing to make you want to stay. And then you lie down and shut up forever. Lots of little deaths until the last big one. Whatever happened to me in my life, happened to me as a writer of plays. I\u0026rsquo;d fall in love, or fall in lust. And at the height of my passion, I would think, \u0026lsquo;So this is how it feels,\u0026rsquo; and I would tie it up in pretty words. I watched my life as if it were happening to someone else. My son died. And I was hurt, but I watched my hurt, and even relished it, a little, for now I could write a real death, a true loss. My heart was broken by my dark lady, and I wept, in my room, alone; but while I wept, somewhere inside I smiled. For I knew I could take my broken heart and place it on the stage of The Globe, and make the pit cry tears of their own. Summer is a time for popsicles. But you will remember it, in the soft, lost, slumbering moments between waking and true sleep: remember the whispering voices of the Gods of Earth and Heaven, the piping laughter of innocent chaos, the frightened rusting of cold order\u0026hellip;the voices of the living. The voices of the dead. They will haunt your sleep until you die. ","permalink":"https://atharvashah.netlify.app/blog/book-quotes/the-best-quotes-from-sandman-graphic-novel-by-neil-gaiman/","summary":"Vol 1: Preludes and Nocturnes But where shall wisdom be found? And where is the place of understanding? Man knoweth not the price thereof; neither is it found in the land of the living … for the price of wisdom is above rubies. CHORONZON: I am a dire wolf, prey-stalking, lethal prowler. MORPHEUS: I am a hunter, horse-mounted, wolf-stabbing. CHORONZON: I am a horsefly, horse-stinging, hunter-throwing. MORPHEUS: I am a spider, fly-consuming, eight legged.","title":"The Best Quotes from Sandman (Graphic Novel) by Neil Gaiman"},{"content":"The Last Wish You make as good a fisherman as a goat’s arse makes a trumpet. \u0026ldquo;Kings,” continued Calanthe, “divide people into two categories—those they order around, and those they buy—because they adhere to the old and banal truth that everyone can be bought. \u0026ldquo;The sun shines differently, the air is different, water is not as it used to be. The things we used to eat, made use of, are dying, diminishing, deteriorating. We never cultivated the land. Unlike you humans we never tore at it with hoes and ploughs. All decent predictions rhyme. It\u0026rsquo;s an invention, a fairy tale devoid of any sense, like all the legends in which good spirits and fortune tellers fulfill wishes. Stories like that are made up by poor simpletons, who can\u0026rsquo;t even dream of fulfilling their wishes and desires themselves. I\u0026rsquo;m pleased you\u0026rsquo;re not one of them, Geralt of Rivia. It makes you closer in spirit to me. If I want something, I don\u0026rsquo;t dream of it—I act. And I always get what I want. People,\u0026rdquo; Geralt turned his head, \u0026ldquo;like to invent monsters and monstrosities. Then they seem less monstrous themselves. When they get blind-drunk, cheat, steal, beat their wives, starve an old woman, when they kill a trapped fox with an axe or riddle \u0026hellip;\u0026rdquo; Lesser, greater, middling, it\u0026rsquo;s all the same. Proportions are negotiated, boundaries blurred. I\u0026rsquo;m not a pious hermit, I haven\u0026rsquo;t done only good in my life. But if I\u0026rsquo;m to choose between one evil and another, then I prefer not to choose at all.”\u0026rdquo; I manage because I have to. Because I\u0026rsquo;ve no other way out. Because I\u0026rsquo;ve overcome the vanity and pride of being different, I\u0026rsquo;ve understood that they are a pitiful defense against being different. Because I\u0026rsquo;ve understood that the sun shines differently\u0026hellip;\u0026quot; A mother, you son-of-a-bitch, is sacred! Sword of Destiny There is never a second opportunity to make a first impression. Life is full of hazards, selection also occurs in life, Geralt. Misfortune, sicknesses and wars also select. Defying destiny may be just as hazardous as succumbing to it. To me, Madam Yennefer, wisdom includes the ability to turn a deaf ear to foolish or insincere advice. For there are some… things… which there is no way of obtaining, even by magic. And there are gifts which may not be accepted, if one is unable to… reciprocate them… with something equally precious. Otherwise such a gift will slip through the fingers, melt like a shard of ice gripped in the hand. Then only regret, the sense of loss and hurt will remain… Emotions, whims and lies, fascinations and games. Feelings and their absence. Gifts, which may not be accepted. Lies and truth. What is truth? The negation of lies? Or the statement of a fact? And if the fact is a lie, what then is the truth? Who is full of feelings which torment him, and who is the empty carapace of a cold skull? Who? What is truth, Geralt? What is the essence of truth?’ Organising festivities, the poet argued, satisfied people’s profound and natural needs. From time to time, the bard maintained, a chap has to meet other people in a place where he can have a laugh and a singsong, gorge himself on kebabs and pierogis, drink beer, listen to music and squeeze a girl as he swung her around in the dance. If every chap wanted to satisfy those needs, Dandelion argued, individually, periodically and randomly, an indescribable mess would arise. For that reason holidays and festivities were invented. And since holidays and festivities exist, a chap ought to frequent them. A choice which should be respected, for it is the holy and irrefutable right of every woman. You’re taking umbrage like a tart whose lack of chastity has been pointed out to her. A little sacrifice, he thought, just a little sacrifice. For this will calm her, a hug, a kiss, calm caresses. She doesn’t want anything more. And even if she did, what of it? For a little sacrifice, a very little sacrifice, is beautiful and worth… Were she to want more… It would calm her. A quiet, calm, gentle act of love. And I… Why, it doesn’t matter, because Essi smells of verbena, not lilac and gooseberry, doesn’t have cool, electrifying skin. Essi’s hair is not a black tornado of gleaming curls, Essi’s eyes are gorgeous, soft, warm and cornflower blue; they don’t blaze with a cold, unemotional, deep violet. Essi will fall asleep afterwards, turn her head away, open her mouth slightly, Essi will not smile in triumph. For Essi… Essi is not Yennefer. I know that in order to unite two people, destiny is insufficient. Something more is necessary than destiny. Blood of Elves Remember,” she repeated, “magic is Chaos, Art and Science. It is a curse, a blessing and progress. It all depends on who uses magic, how they use it, and to what purpose. And magic is everywhere. All around us. Easily accessible. Intolerance and superstition has always been the domain of the more stupid amongst the common folk and, I conjecture, will never be uprooted, for they are as eternal as stupidity itself. There, where mountains tower today, one day there will be seas; there where today seas surge, will one day be deserts. But stupidity will remain stupidity. Nicodemus de Boot, Meditations on life, Happiness and Prosperity. None who contemplates and commits violence has the right to consider himself better than an ordinary criminal. Because it is in the nature of all violence to lead inevitably to crime. Chaos extends its talons towards you, still uncertain if you will be its tool or an obstacle in its design. That which Chaos shows you in your dreams is this very uncertainty. Chaos is afraid of you, Child of Destiny. But it wants you to be the one who feels fear. Chaos cannot show you what it really is. So it is showing you the future, showing you what is going to happen. It wants you to be afraid of the coming days, so that fear of what is going to happen to you and those closest to you will start to guide you, take you over completely. That is why Chaos is sending you those dreams. Now, you are going to show me what you see in your dreams. And you are going to be frightened. And then you will forget and master your fear. You mistake the stars reflected in the surface of the lake at night for the heavens. The special army, skipper, isn’t just any old unit. It’s not some shitty shield-bearers who just need to be shown which end of the javelin pricks. A special army has to know how to fight like nobody’s business! Taste of forbidden fruit, made all the more exciting. So you’ve got the honest truth and faithful history of a world where he who shatters the skulls of others most efficiently and swells women’s bellies fastest, reigns. You are an anachronistic witcher, and I\u0026rsquo;m a modern witcher, moving with the spirit of the times. Which is why you\u0026rsquo;ll soon be out of work and I\u0026rsquo;ll be doing well. Soon there won\u0026rsquo;t be any strigas, wyverns, endriagas or werewolves left in the world. But there\u0026rsquo;ll always be whoresons. Time of Contempt Believe me, little one, you should only regret inactivity, indecisiveness, hesitation. You shouldn’t regret actions or decisions, even if they occasionally end in sadness and regret. Everything ends.’ No, he thought. I don’t want it to be like that. I’m tired. Too tired to accept the perspective of endings which are beginnings, and starting everything over again. In each of us lies a creditor and a debtor at once and the art is for the reckoning to tally inside us. Thus do I take you, to have and to hold, for the most wondrous and terrible of times, for the best and the worst of times, by day and by night, in sickness and in health. For I love you with all my heart and swear to love you eternally, until death do us part. Traditional marriage vows. There is only she, Yennefer, at my side, here and now, and only she matters. Here and now. And what she was long ago, where she was long ago and who she was with long ago doesn’t have any, doesn’t have the slightest, importance. Now she’s with me, here, among you all. With me, with no one else. That’s what I’m thinking right now, thinking only about her, thinking endlessly about her, smelling the scent of her perfume and the warmth of her body. And you can all choke on your envy. Is there still good sense in the world? Or do only contemptibility and contempt remain? You can’t afford the luxury of spurning contempt. A time of contempt is approaching, Witcher, my friend, a time of great and utter contempt. You have to adapt. Baptism of Fire Were I to attempt to be good to everyone, to the entire world and to all the creatures living in it, it would be a drop of fresh water in the salt sea. In other words, a wasted effort. Thus, I decided to do specific good; good which would not go to waste. I’m good to myself and my immediate circle. You surround the dead with veneration and memory, you dream of immortality, and in your myths and legends there’s always someone being resurrected, conquering death. But were your esteemed late great-grandfather really to suddenly rise from the grave and order a beer, panic would ensue. When there’s hunger you don’t share out your food, you just devour the weakest ones. This practice works among wolves, since it lets the healthiest and strongest individuals survive. But among sentient races selection of that kind usually allows the biggest bastards to survive and dominate the rest. Life, it turns out, isn’t poetry! And do you know why? Because it’s so resistant to criticism! We enter the world as a minute part of the life we are given, and from then on we are ever paying off debts. To ourselves. For ourselves. In order for the final reckoning to tally. Everyone has some kind of debt. Such is life. Debts and liabilities, obligations, gratitude, payments, doing something for someone. Or perhaps for ourselves? For in fact we are always paying ourselves back and not someone else. Each time we are indebted we pay off the debt to ourselves. In each of us lies a creditor and a debtor at once and the art is for the reckoning to tally inside us. We enter the world as a minute part of the life we are given, and from then on we are ever paying off debts, To ourselves. For ourselves. In order for the final reckoning to tally. A baptism of fire, the Witcher thought, furiously striking and parrying blows. I was meant to pass through fire for Ciri. And I\u0026rsquo;m passing through fire in a battle which is of no interest to me at all. Which I don\u0026rsquo;t understand in any way. The fire that was meant to purify me is just scorching my hair and face. Ambition is the undoing of men. They always want what they know to be impossible and unattainable. And they are unaware of the attainable. Your talk\u0026rsquo;s so clever it makes my head spin,\u0026rsquo; Milva snorted. \u0026lsquo;And all your wisdom comes down to what\u0026rsquo;s under a woman\u0026rsquo;s skirt. Woeful philosophers. The Tower of the Swallow Why should I give up revenge? On behalf of what? Moral principles? And what of the higher order of things, in which evil deeds are punished? For you, a philosopher and ethicist, an act of revenge is bad, disgraceful, unethical and illegal. But I ask: where is the punishment for evil? Who has it and grants access? The Gods, in which you do not believe? The great demiurge-creator, which you decided to replace the gods with? Or maybe the law? [\u0026hellip;] I know what evil is afraid of. Not your ethics, Vysogota, not your preaching or moral treaties on the life of dignity. Evil is afraid of pain, mutilation, suffering and at the end of the day, death! The dog howls when it is badly wounded! Writhing on the ground and growls, watching the blood flow from its veins and arteries, seeing the bone that sticks out from a stump, watching its guts escape its open belly, feeling the cold as death is about to take them. Then and only then will evil begin to beg, \u0026lsquo;Have mercy! I regret my sins! I\u0026rsquo;ll be good, I swear! Just save me, do not let me waste away!\u0026rsquo;. Yes, hermit. That is the way to fight evil! When evil wants to harm you, inflict pain - anticipate them, it\u0026rsquo;s best if evil does not expect it. But if you fail to prevent evil, if you have been hurt by evil, then avenge him! It is best when they have already forgotten, when they feel safe. Then pay them in double. In triple. An eye for an eye? No! Both eyes for an eye! A tooth for a tooth? No! All their teeth for a tooth! Repay evil! Make it wail in pain, howling until their eyes pop from their sockets. And then, you can look under your feet and boldly declare that what is there cannot endanger anyone, cannot hurt anyone. How can someone be a danger, when they have no eyes? How can someone hurt when they have no hands? They can only wait until they bleed to death. No one wants to suffer. But that is the fate of each. And some suffer more. Not necessarily of their own volition. It\u0026rsquo;s not about to enduring the suffering. It\u0026rsquo;s about how you endure it. Draw me not without reason; sheath me not without honour. The line delineated by destiny is winding, but leads to this tower. Towards annihilation, towards the destruction of established values, of the established order. But there, above the tower, do you see? A swallow. The symbol of hope. Take this sword. And may what is to come about, come about. Your vision is a world where people are afraid to venture out after dark; not for fear of cut-throats, but of the guardians of public order. For, after all, the result of all great crackdowns on miscreants is always that the miscreants enter the ranks of the guardians of public order en masse. the Dank Wilderness was so dank it would have been difficult to imagine anything danker. You often disguise gaps in your education with sarcastic or exaggerated simplifications which you consider witty. The world you envision is made for a witcher. A witcher would never be short of work in it. Instead of codes, articles and peevish platitudes about justice, your idea creates lawlessness, anarchy, the licence and self-serving of princelings and mandarins, the officiousness of careerists wanting to endear themselves to their superiors, the blind vindictiveness of fanatics, the cruelty of assassins, retribution and sadistic vengeance. Your vision is a world where people are afraid to venture out after dark; not for fear of cut-throats, but of the guardians of public order. For, after all, the result of all great crackdowns on miscreants is always that the miscreants enter the ranks of the guardians of public order en masse. ","permalink":"https://atharvashah.netlify.app/blog/book-quotes/the-best-quotes-from-witcher-series-by-andrzej-sapkowski/","summary":"The Last Wish You make as good a fisherman as a goat’s arse makes a trumpet. \u0026ldquo;Kings,” continued Calanthe, “divide people into two categories—those they order around, and those they buy—because they adhere to the old and banal truth that everyone can be bought. \u0026ldquo;The sun shines differently, the air is different, water is not as it used to be. The things we used to eat, made use of, are dying, diminishing, deteriorating.","title":"The Best Quotes from The Witcher Series by Andrzej Sapkowski"},{"content":" Heard joke once: Man goes to doctor. Says he\u0026rsquo;s depressed. Says life seems harsh and cruel. Says he feels all alone in a threatening world where what lies ahead is vague and uncertain. Doctor says, \u0026ldquo;Treatment is simple. Great clown Pagliacci is in town tonight. Go and see him. That should pick you up.\u0026rdquo; Man bursts into tears. Says, \u0026ldquo;But doctor\u0026hellip;I am Pagliacci. Looked at sky through smoke heavy with human fat and God was not there. The cold, suffocating dark goes on forever and we are alone. Live our lives, lacking anything better to do. Devise reason later. Born from oblivion; bear children, hell-bound as ourselves, go into oblivion. There is nothing else. Existence is random. Has no pattern save what we imagine after staring at it for too long. No meaning save what we choose to impose. This rudderless world is not shaped by vague metaphysical forces. It is not God who kills the children. Not fate that butchers them or destiny that feeds them to the dogs. It’s us. Only us. Streets stank of fire. The void breathed hard on my heart, turning its illusions to ice, shattering them. Was reborn then, free to scrawl own design on this morally blank world. Thermodynamic miracles\u0026hellip; events with odds against so astronomical they\u0026rsquo;re effectively impossible, like oxygen spontaneously becoming gold. I long to observe such a thing. And yet, in each human coupling, a thousand million sperm vie for a single egg. Multiply those odds by countless generations, against the odds of your ancestors being alive; meeting; siring this precise son; that exact daughter\u0026hellip; Until your mother loves a man she has every reason to hate, and of that union, of the thousand million children competing for fertilization, it was you, only you, that emerged. To distill so specific a form from that chaos of improbability, like turning air to gold\u0026hellip; that is the crowning unlikelihood. The thermodynamic miracle. But\u0026hellip;if me, my birth, if that\u0026rsquo;s a thermodynamic miracle\u0026hellip; I mean, you could say that about anybody in the world!. Yes. Anybody in the world. ..But the world is so full of people, so crowded with these miracles that they become commonplace and we forget\u0026hellip; I forget. We gaze continually at the world and it grows dull in our perceptions. Yet seen from the another\u0026rsquo;s vantage point. As if new, it may still take our breath away. Come\u0026hellip;dry your eyes. For you are life, rarer than a quark and unpredictable beyond the dreams of Heisenberg; the clay in which the forces that shape all things leave their fingerprints most clearly. Dry your eyes\u0026hellip; and let\u0026rsquo;s go home. No. Not even in the face of Armageddon. Never compromise. Dog carcass in alley this morning, tire tread on burst stomach. This city is afraid of me. I have seen its true face. The streets are extended gutters and the gutters are full of blood and when the drains finally scab over, all the vermin will drown. The accumulated filth of all their sex and murder will foam up about their waists and all the whores and politicians will look up and shout \u0026ldquo;Save us!\u0026rdquo;\u0026hellip; and I\u0026rsquo;ll look down and whisper \u0026ldquo;No.” We\u0026rsquo;re all puppets, Laurie. I\u0026rsquo;m just a puppet who can see the strings. There is no future. There is no past. Do you see? Time is simultaneous, an intricately structured jewel that humans insist on viewing one edge at a time, when the whole design is visible in every facet. In an era of stress and anxiety, when the present seems unstable and the future unlikely, the natural response is to retreat and withdraw from reality, taking recourse either in fantasies of the future or in modified visions of a half-imagined past. You know what I wish? I wish all the scum of the Earth had one throat and I had my hands about it. We have laboured long to build a heaven, only to find it populated with horrors. Nothing ends, Adrian. Nothing ever ends. A live body and a dead body contain the same number of particles. Structurally, there\u0026rsquo;s no discernible difference. Life and death are unquantifiable abstracts. Why should I be concerned? I sat on the bed. I looked at the Rorschach blot. I tried to make it look like a spreading tree, shadows pooled beneath it, but it didn\u0026rsquo;t. It looked more like a dead cat I once found, the fat, glistening grubs writhing blindly, squirming over each other, frantically tunneling away from the light. But even that isn\u0026rsquo;t the real horror. The horror is this: in the end, it is simply a picture of empty meaningless blackness. Who makes the world? Perhaps the world is not made. Perhaps nothing is made. Perhaps it simply is, has been, will always be there…a clock without a craftsman. I\u0026rsquo;m disappointed in you, Adrian. I\u0026rsquo;m very disappointed. Reassembling myself was the first trick I learned. It didn\u0026rsquo;t kill Osterman. Did you really think it would kill me? I have walked across the surface of the sun. I have witnessed events so tiny and so fast, they could hardly be said to have occurred at all. But you, Adrian, you\u0026rsquo;re just a man. The world\u0026rsquo;s smartest man poses no more threat to me than does its smartest termite. We are alone. Live our lives, lacking anything better to do. Devise reason later. Does the human heart know chasms so abysmal? A world grows up around me. Am I shaping it, or do its predetermined contours guide my hand? The disciplines of physical exercise, meditation and study aren\u0026rsquo;t terribly esoteric. The means to attain a capability far beyond that of the so-called ordinary person are within the reach of everyone, if their desire and their will are strong enough. I have studied science, art, religion and a hundred different philosophies. Anyone could do as much. By applying what you learn and ordering your thoughts in an intelligent manner it is possible to accomplish almost anything. Possible for an \u0026lsquo;ordinary person.\u0026rsquo; There\u0026rsquo;s a notion I\u0026rsquo;d like to see buried: the ordinary person. Ridiculous. There is no ordinary person. The photograph is in my hand. It is the photograph of a man and a woman. They are at an amusement park, in 1959. [\u0026hellip;] I\u0026rsquo;m tired of looking at the photograph now. I open my fingers. It falls to the sand at my feet. I am going to look at the stars. They are so far away, and their light takes so long to reach us\u0026hellip; All we ever see of stars are their old photographs. [\u0026hellip;] It\u0026rsquo;s October, 1985. I\u0026rsquo;m basking in the two-million-year-old light of Andromeda. I can see the supernova that Ernst Hartwig discovered in 1885, a century ago. It scintillates, a wink intended for the Trilobites, all long dead. Supernovas are where gold forms; the only place. All gold comes from supernovas Don\u0026rsquo;t tell me they didn\u0026rsquo;t have a choice. Now the whole world stands on the brink, staring down into bloody hell, all those liberals and intellectuals and smooth-talkers\u0026hellip; and all of a sudden, nobody can think of anything to say. Is it possible, I wonder, to study a bird so closely, to observe and catalogue its peculiarities in such minute detail, that it becomes invisible? Is it possible that while fastidiously calibrating the span of its wings or the length of its tarsus, we somehow lose sight of its poetry? That in our pedestrian descriptions of a marbled or vermiculated plumage we forfeit a glimpse of living canvases, cascades of carefully toned browns and golds that would shame Kandinsky, misty explosions of color to rival Monet? I believe that we do. I believe that in approaching our subject with the sensibilities of statisticians and dissectionists, we distance ourselves increasingly from the marvelous and spell binding planet of imagination whose gravity drew us to our studies in the first place. That is not to say that we should cease to establish facts and verify our information, but merely to suggest that unless those facts can be imbued with the flash of poetic insight then they remain dull gems; semi-precious stones scarcely worth the collecting. In this world, you shouldn\u0026rsquo;t rely on help from anybody. In the end, a man stands alone. Truly, life is hell and death\u0026rsquo;s rough hand our only deliverance. Who watches the Watchmen? My parents reached America the year I was born, 1939. Entering school, I was already exceptionally bright, my perfect scores on early test papers arousing such suspicion that I carefully achieved only average grades thereafter. What caused such precociousness? My parents were intellectually unremarkable, possessing no obvious genetic advantages. Perhaps I decided to be intelligent rather than otherwise? Perhaps we all make such decisions, though that seems a callous doctrine. By seventeen, my parents were both dead, and I faced a different decision. My inheritance offered life long idle luxury, and yet, needing nothing, I burned with the paradoxical urge to do everything. Do you understand? My intellect set me apart. Faced with difficult choices, I knew nobody whose advice might prove useful. Nobody living. The only human being with whom I felt any kinship died three hundred years before the birth of Christ. Alexander of Macedonia. I idolized him. A young army commander, he\u0026rsquo;d swept along the coasts of Turkey and Phoenicia, subduing Egypt before turning his armies towards Persia. He died, thirty-three, ruling most of the civilized world. Ruling without barbarism! At Alexandria, he instituted the ancient world\u0026rsquo;s greatest seat of learning. True, people died \u0026hellip; perhaps unnecessarily, though who can judge such things? Yet how he nearly approached his vision of a united world! I was determined to measure my success against his. Firstly, I gave away my inheritance. to demonstrate the possibility of achieving anything starting from nothing. Next, I departed for Northern Turkey, to retrace my hero\u0026rsquo;s steps. I wanted to match his accomplishment, bringing an age of illumination to a benighted world. Heh. I wanted to have something to say should we meet in the hall of legends. I followed the path of Alexander\u0026rsquo;s war machine along the black sea coast, imagining his armies taking port after port, blood on ancient bronze. Perhaps because of the challenge it represented: the ancient world\u0026rsquo;s greatest puzzle was there, a knot that couldn\u0026rsquo;t be untied. Alexander cut it in two with his sword. Lateral thinking, you see. Centuries ahead of his time. Heading south, he entered Egypt through Memphis, where they proclaimed him son of Amon, judge of the dead, whose name means \u0026ldquo;hidden one.\u0026rdquo; Under rule from Alexandria, the classic culture of the great Pharaohs was restored. I followed him through Babylon, up through Kabul to Samarkhand then down the Indus, where he met the first elephants of war. Where he\u0026rsquo;d turned back to quell dissent at home, I travelled on, through China and Tibet, gathering martial wisdom as I went. Alexander returned to Babylon to die of an infection, aged thirty-three, amongst its ruined ziggurats. I saw at last his failings. He\u0026rsquo;d not united all the world, nor built a unity that would survive him. Disillusioned, but determined, to complete my odyssey, I followed his corpse to its resting place in Alexandria. The night before returning to America, I wandered into the desert and ate a ball of hashish I\u0026rsquo;d been given in Tibet. The ensuing vision transformed me. Wading through powdered history, I heard dead kings walking underground, heard fanfares through human skulls. Alexander had merely resurrected an age of Pharaohs, their wisdom, truly immortal, now inspired me. What intellectual magnificence their system encouraged.. Ptolemy seeking the universe\u0026rsquo;s pivot from his light-house at Pharos, Eratosthenes, measuring the world using only shadows … their greatest secrets entrusted to their servants, buried alive with them in sand-flooded chambers. Adopting Ramses the Second\u0026rsquo;s Greek name and Alexander\u0026rsquo;s free-booting style, I resolved to apply antiquity\u0026rsquo;s teachings to today\u0026rsquo;s world. Thus began my path to conquest … conquest not of men. But of the evils that beset them. Today, that conquest becomes assured, in which your unquestioning assistance has proven invaluable. Do you comprehend the triumph which you have contributed, the secret glory that it affords? Do you understand my shame at so inadequate a reward? Soliloquy to all of his subordinates, as he watches them die from the poison he has provided them. It don\u0026rsquo;t matter squat because inside thirty years the nukes are gonna be flyin\u0026rsquo; like maybugs\u0026hellip;and then Ozzy here is gonna be the smartest man on the cinder. Now, pardon me, but I got an appointment. See you in the funny papers. Everything is preordained. Even my responses. Dr. Malcolm Long: Walter, is what happened to Kitty Genovese really proof that the whole of mankind is rotten? I think you\u0026rsquo;ve been conditioned with a negative worldview. There are good people, too, like\u0026hellip; -Rorschach: Like you? -Dr. Malcolm Long: Me? Oh, well, I wouldn\u0026rsquo;t say that. I\u0026hellip; -Rorschach: No. You just think it. Think you\u0026rsquo;re \u0026lsquo;good people\u0026rsquo;. Why are you spending so much time with me, Doctor? -Dr. Malcolm Long: Uh\u0026hellip;well, because I care about you, and because I want to make you well\u0026hellip; -Rorschach: Other people, down in cells. Behavior more extreme than mine. You don\u0026rsquo;t spend any time with them\u0026hellip;but then, they\u0026rsquo;re not famous. Won\u0026rsquo;t get your name in the journals. You don\u0026rsquo;t want to make me well. Just want to know what makes me sick. You\u0026rsquo;ll find out. Have patience, Doctor. You\u0026rsquo;ll find out. Once you realize what a joke everything is, being the Comedian is the only thing that makes sense. Life isn’t divided into genres. It’s a horrifying, romantic, tragic, comical, science-fiction cowboy detective novel … with a bit of pornography if you\u0026rsquo;re lucky. ","permalink":"https://atharvashah.netlify.app/blog/book-quotes/the-best-quotes-from-watchmen-graphic-novel-by-alan-moore/","summary":"Heard joke once: Man goes to doctor. Says he\u0026rsquo;s depressed. Says life seems harsh and cruel. Says he feels all alone in a threatening world where what lies ahead is vague and uncertain. Doctor says, \u0026ldquo;Treatment is simple. Great clown Pagliacci is in town tonight. Go and see him. That should pick you up.\u0026rdquo; Man bursts into tears. Says, \u0026ldquo;But doctor\u0026hellip;I am Pagliacci. Looked at sky through smoke heavy with human fat and God was not there.","title":"The Best Quotes from Watchmen (Graphic Novel) by Alan Moore"},{"content":" A book is as dangerous as any journey you might take. The person who closes the back cover may not be the same one that opened the front one. Treat them with respect. Your death has not been waiting for your arrival at the appointed hour: it has, for all the years of your life, been racing towards you with the fierce velocity of time\u0026rsquo;s arrow. It cannot be evaded, it cannot be bargained with, deflected or placated. All that is given to you is the choice: meet it with open eyes and peace in your heart, go gentle to your reward. Or burn bright, take up arms, and fight the bitch. Trust is the most insidious of poisons. Trust sidesteps all of your precautions. All the world and more has rushed eternity’s length to reach this beat of your heart, screaming down the years. And if you let it, the universe, without drawing breath, will press itself through this fractured second and race to the next, on into a new eternity. Everything that is, the echoes of everything that ever was, the roots of all that will ever be, must pass through this moment that you own. Your only task is to give it pause—to make it notice. Knowledge is a rug of a certain size, and the world is larger. It’s not what remains uncovered at the edges that should worry you, rather what is swept beneath. I had a son and I breathed for him. When we buried him my sorrow consumed me. Was my grief holy? Was it unique? All our hurts and follies are repeated time and again. Generation after generation live the same mistakes. But we’re not like the fire, or the river, or the wind—we’re not a single tune, its variations played out forever, a game of numbers until the world dies. I have been too young to know, and I have been too old to care. It’s in that oh-so-narrow slice between that memories are made. And hunger must be fed. Any weapon begs use. The blade itself incites to violence. Nothing is as cruel as a righteous man. She had been righteous in her time. Never be so focused on picking a lock that you forget kicking down the door is also an option. Spend too long watching the long game and the short game will kill you. There is a purity in rage. It will burn out sorrow. For a time. It will burn out fear. Even cruelty and hatred will seek shelter, rage wants none of them, only to destroy. Rage is the gift our nature gives to us, shaped by untold years. Why discard it? There might not be a meaning to the world, or in it, but that does not mean that what we do has no meaning. Moons might rise and fall, empires wax and wane, even the stars come and go, but there are constants too, and though the story of our kind is ever-changing it is also always the same. A million words won’t push the ice back, not even the breadth of a finger. But one word will break a heart, two will mend it, and three will lay the highest low. But that was never the heart of Sweet Mercy. The shipheart wasn’t the foundation of the convent. It was always the faith. Always the notion that all men and women are our brothers and our sisters. And that faith doesn’t end with borders. It doesn’t care about heresies used to divide us, or whether you speak your prayers to a white star, or to the fields and forests and stones. All leaves must fall in time, she had said. The lives we lived fall away from us, but something remains, something that is part of the tree. ","permalink":"https://atharvashah.netlify.app/blog/book-quotes/the-best-quotes-from-book-of-the-ancestors-trilogy-by-mark-lawrence/","summary":"A book is as dangerous as any journey you might take. The person who closes the back cover may not be the same one that opened the front one. Treat them with respect. Your death has not been waiting for your arrival at the appointed hour: it has, for all the years of your life, been racing towards you with the fierce velocity of time\u0026rsquo;s arrow. It cannot be evaded, it cannot be bargained with, deflected or placated.","title":"The Best Quotes from Book of the Ancestors Trilogy by Mark Lawrence"},{"content":"Prince of Thorns Memories are dangerous things. You turn them over and over, until you know every touch and corner, but still you\u0026rsquo;ll find an edge to cut you. Each day the memories weigh a little heavier. Each day they drag you down that bit further. You wind them around you, a single thread at a time, and you weave your own shroud, you build a cocoon, and in it madness grows. You sit here with your yesterdays queuing at your shoulder. You listen to their reproach and curse those that gave you life. There’s something brittle in me that will break before it bends. I’ll tell you now. That silence almost beat me. It’s the silence that scares me. It’s the blank page on which I can write my own fears. The spirits of the dead have nothing on it. The dead one tried to show me hell, but it was a pale imitation of the horror I can paint on the darkness in a quiet moment. I’ll tell you now. That silence almost beat me. It’s the silence that scares me. It’s the blank page on which I can write my own fears. The spirits of the dead have nothing on it. The dead one tried to show me hell, but it was a pale imitation of the horror I can paint on the darkness in a quiet moment. I think maybe we die every day. Maybe we\u0026rsquo;re born new each dawn, a little changed, a little further on our own road. When enough days stand between you and the person you were, you\u0026rsquo;re strangers. Maybe that\u0026rsquo;s what growing up is. Maybe I have grown up. What\u0026rsquo;s it going to take for you to open that door? Gold? Blood? Your name and password. My name is Honorous Jorg Ancrath, my password is divine right. Now open the fecking door. You got responsibilities when you’re a leader. You got a responsibility not to kill too many of your men. Or who’re you going to lead? She had the eyes of everyone who ever cared. In the end, it seems we\u0026rsquo;re just toys, easy to break and hard to mend. We wrap up our violent and mysterious world in a pretense of understanding. We paper over the voids of our comprehension with science and religion, and make believe that order has been imposed. And, for the most of it, the fiction works. We skim across the surfaces, heedless of the depths below. Dragonflies flitting over a lake, miles deep, pursuing erratic paths to pointless ends. Until that moment when something from the cold unknown reaches up to take us. The biggest lies we save for ourselves. We play a game in which we are gods, in which we make choices, and the current follows in our wake. We pretend a separation from the wild. Pretend that a man’s control runs deep, that civilization is more than a veneer, that reason will be our companion in dark places. The weakest spot in a good defence is designed to fail. It falls, but in falling it summons the next defence and so on. It’s all about layers. At the end of it all you’ll find yourself facing the thing you sought to avoid all along, only now you’re weaker, and it’s forewarned. Jesu, Rike, you been gargling rat piss again? The perfumes of lords and ladies tickled at my nose: lavender and orange oil. On the road, shit has the decency to stink. I think you need to have lived more to truly know a man\u0026rsquo;s heart. You need to have made more transactions in life to know the worth of the coin you spend so freely. I held my arms wide to the rain. I could feel it beat on me. I didn’t have so many years under my belt, but even to me the rain fell like memory. It woke wild nights in me when I stood on the Keep Tower, on the edge above a high fall, near drowned in the deluge and daring the lightning to touch me. War, my friends, is a thing of beauty. Those as says otherwise are losing. There is no evil, Makin,” I said. “There’s the love of things, power, comfort, sex, and there’s what men are willing to do to satisfy those lusts. And, because in some hard core of me, in some stubborn trench of selfish refusal, I could not, even at ten years of age, surrender to anything or anyone, I fought that pain. I analysed its offensive, and found its lines of attack. It festered, like the corruption in a wound turned sour, drawing strength from me. I knew enough to know the remedy. Hot iron for infection, cauterize, burn, make it pure. I cut from myself all the weakness of care. The love for my dead, I put aside, secure in a casket, an object of study, a dry exhibit, no longer bleeding, cut loose, set free. The capacity for new love, I burned out. I watered it with acid until the ground lay barren and nothing there would sprout, no flower take root. Maybe we’re born new each dawn, a little changed, a little further on our own road. When enough days stand between you and the person you were, you’re strangers. Maybe that’s what growing up is. Maybe I have grown up. Anything that you cannot sacrifice pins you. Makes you predictable, makes you weak. The first time I heard that kind of pain, my mother’s pain, something held me back. I’ll tell you it was the hook-briar which held me fast. I’ll show you the scars. But in the night, before the dreams come, a voice whispers to me that it was fear that held me back, terror that rooted me in the briar, safe while I watched them die. King of Thorns We die a little every day and by degrees we’re reborn into different men, older men in the same clothes, with the same scars. Memory is all we are. Moments and feelings, captured in amber, strung on filaments of reason. Take a man’s memories and you take all of him. Chip away a memory at a time and you destroy him as surely as if you hammered nail after nail through his skull. As a child there\u0026rsquo;s a horror in discovering the limitations of the ones you love. The time you find that your mother cannot keep you safe, that your tutor makes a mistake, that the wrong path must be taken because the grown-ups lack the strength to take the right one\u0026hellip;each of those moments is the theft of your childhood, each of them a blow that kills some part of the child you were, leaving another part of the man exposed, a new creature, tougher but tempered with bitterness and disappointment. They say that time is a great teacher but unfortunately it kills all its pupils. When pain bites, men bargain. Boys too. We twist and turn, we plead and beg, we offer our tormentors what he wants so that the hurting will stop. And when there is no torturer to placate, no hooded man with hot irons and tongs, just a burn you can\u0026rsquo;t escape, we bargain with God, or ourselves, depending on the size of our egos. A man is made of memories. It is all we are. Captured moments, the smell of a place, scenes played out time and again on a small stage. We are memories, strung on storylines—the tales we tell ourselves about ourselves, falling through our lives into tomorrow. When you\u0026rsquo;ve committed yourself to violence it takes an almost inhuman effort to stop short. It\u0026rsquo;s one of those things that once you\u0026rsquo;ve started need to be finished, rather like coitus, interrupting that\u0026rsquo;s a sin, even the priests say so. And there it is, proof if proof were needed, that though God may mould the clay and fashion some of us hale, some strong, some beautiful, inside we make ourselves, from foolish things, breakable, fragile things: the thorns, that dog, the hope that Katherine might make me better than I am. Even Rike’s blunt wants were born of losses he probably remembered only in dreams. All of us fractured, awkward collages of experience wrapped tight to present a defensible face to the world. And what makes us human is that sometimes we snap. And in that moment of release we’re closer to gods than we know. In any case I would cut myself a path to the throne even if some bastard-born herder had fathered me on a gutter-whore—genealogy can work for me or I can cut down the family tree and make a battering ram. Either way is good. Emperor of Thorns This is where the wise man turns away. This is where the holy kneel and call on God. These are the last miles, my brothers. Don\u0026rsquo;t look to me to save you. Don\u0026rsquo;t think I will not spend you. Run if you have the wit. Pray if you have the soul. Stand your ground if courage is yours. But don\u0026rsquo;t follow me. Follow me, and I will break your heart. There\u0026rsquo;s a slope down toward evil, a gentle gradient that can be ignored at each step, unfelt. It\u0026rsquo;s not until you look back, see the distant heights where you once lived, that you understand your journey. Nature shaped the claw to trap, and the tooth to kill, but the thorn\u0026hellip;the thorn\u0026rsquo;s only purpose is to hurt. Take a rest and the world catches up with you. Lesson in life—keep moving. Every man has his thorns, not of him, but in him, deep as bones. The scars of the briar mark me, a calligraphy of violence, a message of blood-writ, requiring a lifetime to translate. People who talk about the weather would be better served by admitting they\u0026rsquo;ve nothing to say but like the sound of their own voice. A victim who believes himself anticipated at every turn is not only crippled by uncertainty but also easier to predict. Men are busy dying from the moment they’re born but it’s a crawl from the cradle to the grave. Decadence begins when the budget to beautify a man\u0026rsquo;s home exceeds the coin spent to ensure its defense. Time heals all wounds, but often it’s only by the application of the grave, and while we live some hurts live with us, burning, making us twist and turn to escape them. And as we twist, we turn into other men. ","permalink":"https://atharvashah.netlify.app/blog/book-quotes/the-best-quotes-from-broken-empire-trilogy-by-mark-lawrence/","summary":"Prince of Thorns Memories are dangerous things. You turn them over and over, until you know every touch and corner, but still you\u0026rsquo;ll find an edge to cut you. Each day the memories weigh a little heavier. Each day they drag you down that bit further. You wind them around you, a single thread at a time, and you weave your own shroud, you build a cocoon, and in it madness grows.","title":"The Best Quotes from Broken Empire Trilogy by Mark Lawrence"},{"content":" Coin ChangeProblem Knapsack Problem Binomial CoefficientProblem Permutation CoefficientProblem Program for nth Catalan Number Matrix Chain Multiplication Edit Distance Subset Sum Problem Friends Pairing Problem Gold Mine Problem Assembly Line SchedulingProblem Painting the Fence Problem Rod Cutting Problem Longest Common Subsequence Longest Repeated Subsequence Longest Increasing Subsequence Space Optimized Solution of LCS (Print only length) LCS (Longest Common Subsequence) of three strings Maximum Sum Increasing Subsequence Count all subsequences having product less than K Longest subsequence such that difference between adjacent is one Maximum subsequence sum such that no three are consecutive Egg Dropping Problem Maximum Length Chain of Pairs Maximum size square sub-matrix with all 1s Maximum sum of pairs with specific difference Min Cost PathProblem Maximum difference of zeros and ones in binary string Minimum number of jumps to reach end Minimum cost to fill given weight in a bag Minimum removals from array to make max –min \u0026lt;= K Longest Common Substring Count number of ways to reacha given score in a game Count Balanced Binary Trees of Height h Smallest sum contiguous subarray Unbounded Knapsack (Repetition of items allowed) Largest Independent Set Problem Partition problem Longest Palindromic Subsequence Count All Palindromic Subsequence in a given String Longest Palindromic Substring Longest alternating subsequence Weighted Job Scheduling Coin game winner where every player has three choices Count Derangements (Permutation such that no element appears in its original position) Maximum profit by buying and selling a share at most twice Optimal Strategy for a Game Optimal Binary Search Tree Palindrome PartitioningProblem Word Wrap Problem Mobile Numeric Keypad Problem Boolean Parenthesization Problem Largest rectangular sub-matrix whose sum is 0 Maximum sum rectangle in a 2D matrix Maximum profit by buying and selling a share at most k times Find if a string is interleaved of two other strings Coin ChangeProblem \u0026#34;\u0026#34;\u0026#34; Given an unlimited supply of coins of given denominations, find the total number of distinct ways to get the desired change. For example, Input: S = { 1, 3, 5, 7 }, target = 8 The total number of ways is 6 { 1, 7 } { 3, 5 } { 1, 1, 3, 3 } { 1, 1, 1, 5 } { 1, 1, 1, 1, 1, 3 } { 1, 1, 1, 1, 1, 1, 1, 1 } Input: S = { 1, 2, 3 }, target = 4 The total number of ways is 4 { 1, 3 } { 2, 2 } { 1, 1, 2 } { 1, 1, 1, 1 } \u0026#34;\u0026#34;\u0026#34; def count(S, n, target): if target == 0: return 1 # return 0 (solution does not exist) if total becomes negative, no elements are left if target \u0026lt; 0 or n \u0026lt; 0: return 0 # Case 1. Include current coin `S[n]` in solution and recur # with remaining change `target-S[n]` with the same number of coins incl = count(S, n, target - S[n]) # Case 2. Exclude current coin `S[n]` from solution and recur for remaining coins `n-1` excl = count(S, n - 1, target) # return total ways by including or excluding current coin return incl + excl # `n` coins of given denominations S = [1, 2, 3] # total change required target = 4 print(\u0026#39;The total number of ways to get the desired change is\u0026#39;, count(S, len(S) - 1, target)) Knapsack Problem \u0026#34;\u0026#34;\u0026#34; In the 0–1 Knapsack problem, we are given a set of items, each with a weight and a value, and we need to determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. Please note that the items are indivisible; we can either take an item or not (0-1 property). For example, Input: value = [ 20, 5, 10, 40, 15, 25 ] weight = [ 1, 2, 3, 8, 7, 4 ] int W = 10 Output: Knapsack value is 60 value = 20 + 40 = 60 weight = 1 + 8 = 9 \u0026lt; W \u0026#34;\u0026#34;\u0026#34; import sys # Values (stored in list `v`) # Weights (stored in list `w`) # Total number of distinct items `n` # Knapsack capacity `W` def knapsack(v, w, n, W): if W \u0026lt; 0: return -sys.maxsize # base case: no items left or capacity becomes 0 if n \u0026lt; 0 or W == 0: return 0 # Case 1. Include current item `n` in knapsack `v[n]` and recur for # remaining items `n-1` with decreased capacity `W-w[n]` include = v[n] + knapsack(v, w, n - 1, W - w[n]) # Case 2. Exclude current item `v[n]` from the knapsack and recur for # remaining items `n-1` exclude = knapsack(v, w, n - 1, W) # return maximum value we get by including or excluding the current item return max(include, exclude) # input: a set of items, each with a weight and a value v = [20, 5, 10, 40, 15, 25] w = [1, 2, 3, 8, 7, 4] # knapsack capacity W = 10 print(\u0026#39;Knapsack value is\u0026#39;, knapsack(v, w, len(v) - 1, W)) Binomial CoefficientProblem \u0026#34;\u0026#34;\u0026#34; A binomial coefficient C(n, k) also gives the number of ways, disregarding order, that k objects can be chosen from among n objects more formally, the number of k-element subsets (or k-combinations) of a n-element set. \u0026#34;\u0026#34;\u0026#34; def binomialCoeff(n, k): C = [0 for i in range(k+1)] C[0] = 1 # since nC0 is 1 for i in range(1, n+1): # Compute next row of pascal triangle using the previous row j = min(i, k) while (j \u0026gt; 0): C[j] = C[j] + C[j-1] j -= 1 return C[k] n = 5 k = 2 print (\u0026#34;Value of C(%d,%d) is %d\u0026#34; % (n, k, binomialCoeff(n, k))) Permutation CoefficientProblem \u0026#34;\u0026#34;\u0026#34; P(10, 2) = 90 P(10, 3) = 720 P(10, 0) = 1 P(10, 1) = 10 \u0026#34;\u0026#34;\u0026#34; def permutationCoeff(n, k): # P(n,k)=n*(n-1)*(n-2)*....(n-k-1) f=1 for i in range(k): f*=(n-i) return f n = 10 k = 2 print(\u0026#34;Value of P(\u0026#34;, n, \u0026#34;,\u0026#34;, k, \u0026#34;) is \u0026#34;, permutationCoeff(n, k)) Program for nth Catalan Number \u0026#34;\u0026#34;\u0026#34; Catalan numbers are a sequence of natural numbers that occurs in many interesting counting problems like the following. 1) Count the number of expressions containing n pairs of parentheses which are correctly matched. For n = 3, possible expressions are ((())), ()(()), ()()(), (())(), (()()). 2) Count the number of possible Binary Search Trees with n keys (See this) The first few Catalan numbers for n = 0, 1, 2, 3, … are 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, … \u0026#34;\u0026#34;\u0026#34; def catalan(n): return 1 if n \u0026lt;= 1 else sum(catalan(i) * catalan(n-i-1) for i in range(n)) for i in range(10): print(catalan(i), end=\u0026#39; \u0026#39;) Matrix Chain Multiplication \u0026#34;\u0026#34;\u0026#34; Input: p[] = {40, 20, 30, 10, 30} Output: 26000 There are 4 matrices of dimensions 40x20, 20x30, 30x10 and 10x30. Let the input 4 matrices be A, B, C and D. The minimum number of multiplications are obtained by putting parenthesis in following way (A(BC))D --\u0026gt; 20*30*10 + 40*20*10 + 40*10*30 Input: p[] = {10, 20, 30, 40, 30} Output: 30000 There are 4 matrices of dimensions 10x20, 20x30, 30x40 and 40x30. Let the input 4 matrices be A, B, C and D. The minimum number of multiplications are obtained by putting parenthesis in following way ((AB)C)D --\u0026gt; 10*20*30 + 10*30*40 + 10*40*30 Input: p[] = {10, 20, 30} Output: 6000 There are only two matrices of dimensions 10x20 and 20x30. So there is only one way to multiply the matrices, cost of which is 10*20*30 \u0026#34;\u0026#34;\u0026#34; import sys # Matrix A[i] has dimension p[i-1] x p[i] for i = 1..n def MatrixChainOrder(p, i, j): if i == j: return 0 _min = sys.maxsize # place parenthesis at different places between first and last matrix, # recursively calculate count of multiplications for each parenthesis # placement and return the minimum count for k in range(i, j): count = (MatrixChainOrder(p, i, k) + MatrixChainOrder(p, k + 1, j) + p[i-1] * p[k] * p[j]) if count \u0026lt; _min: _min = count # Return minimum count return _min arr = [1, 2, 3, 4, 3] n = len(arr) print(\u0026#34;Minimum number of multiplications is \u0026#34;, MatrixChainOrder(arr, 1, n-1)) Edit Distance \u0026#34;\u0026#34;\u0026#34; The Levenshtein distance (or Edit distance) is a way of quantifying how different two strings are from one another by counting the minimum number of operations required to transform one string into the other (\u0026#39;ABA\u0026#39;, \u0026#39;ABC\u0026#39;) ——\u0026gt; (\u0026#39;ABAC\u0026#39;, \u0026#39;ABC\u0026#39;) == (\u0026#39;ABA\u0026#39;, \u0026#39;AB\u0026#39;) \u0026#34;\u0026#34;\u0026#34; def dist(X, Y): # `m` and `n` is the total number of characters in `X` and `Y`, respectively (m, n) = (len(X), len(Y)) # For all pairs of `i` and `j`, `T[i, j]` will hold the Levenshtein distance # between the first `i` characters of `X` and the first `j` characters of `Y`. # Note that `T` holds `(m+1)×(n+1)` values. T = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # we can transform source prefixes into an empty string by dropping all characters for i in range(1, m + 1): T[i][0] = i # (case 1) # we can reach target prefixes from empty source prefix by inserting every character for j in range(1, n + 1): T[0][j] = j # (case 1) # fill the lookup table in a bottom-up manner for i in range(1, m + 1): for j in range(1, n + 1): cost = 0 if X[i - 1] == Y[j - 1] else 1 T[i][j] = min(T[i - 1][j] + 1, # deletion T[i][j - 1] + 1, # insertion T[i - 1][j - 1] + cost) # replace return T[m][n] X = \u0026#39;kitten\u0026#39; Y = \u0026#39;sitting\u0026#39; print(\u0026#39;The Levenshtein distance is\u0026#39;, dist(X, Y)) Subset Sum Problem \u0026#34;\u0026#34;\u0026#34; Given a set of positive integers and an integer k, check if there is any non-empty subset that sums to k. A = { 7, 3, 2, 5, 8 } k = 14 Output: Subset with the given sum exists Subset { 7, 2, 5 } sums to 14 \u0026#34;\u0026#34;\u0026#34; def subsetSum(A, k): n = len(A) # `T[i][j]` stores true if subset with sum `j` can be attained # using items up to first `i` items T = [[False for _ in range(k + 1)] for _ in range(n + 1)] # if the sum is zero for i in range(n + 1): T[i][0] = True # do for i\u0026#39;th item for i in range(1, n + 1): # consider all sum from 1 to sum for j in range(1, k + 1): # don\u0026#39;t include the i\u0026#39;th element if `j-A[i-1]` is negative if A[i - 1] \u0026gt; j: T[i][j] = T[i - 1][j] else: # find the subset with sum `j` by excluding or including the i\u0026#39;th item T[i][j] = T[i - 1][j] or T[i - 1][j - A[i - 1]] # return maximum value return T[n][k] # Input: a set of items and a sum A = [7, 3, 2, 5, 8] k = 18 if subsetSum(A, k): print(\u0026#39;Subsequence with the given sum exists\u0026#39;) else: print(\u0026#39;Subsequence with the given sum does not exist\u0026#39;) Friends Pairing Problem \u0026#34;\u0026#34;\u0026#34; Input : n = 3 Output : 4 Explanation: {1}, {2}, {3} : all single {1}, {2, 3} : 2 and 3 paired but 1 is single. {1, 2}, {3} : 1 and 2 are paired but 3 is single. {1, 3}, {2} : 1 and 3 are paired but 2 is single. Note that {1, 2} and {2, 1} are considered same. Mathematical Explanation: The problem is simplified version of how many ways we can divide n elements into multiple groups. (here group size will be max of 2 elements). In case of n = 3, we have only 2 ways to make a group: 1) all elements are individual(1,1,1) 2) a pair and individual (2,1) In case of n = 4, we have 3 ways to form a group: 1) all elements are individual (1,1,1,1) 2) 2 individuals and one pair (2,1,1) 3) 2 separate pairs (2,2) \u0026#34;\u0026#34;\u0026#34; # Returns count of ways n people can remain single or paired up. def countFriendsPairings(n): dp = [0 for _ in range(n + 1)] # Filling dp[] in bottom-up manner using recursive formula explained above. for i in range(n + 1): dp[i] = i if (i \u0026lt;= 2) else dp[i - 1] + (i - 1) * dp[i - 2] return dp[n] n = 4 print(countFriendsPairings(n)) Gold Mine Problem \u0026#34;\u0026#34;\u0026#34; Given a gold mine of n*m dimensions. Each field in this mine contains a positive integer which is the amount of gold in tons. Initially the miner is at first column but can be at any row. He can move only (right-\u0026gt;,right up /,right down\\) that is from a given cell, the miner can move to the cell diagonally up towards the right or right or diagonally down towards the right. Find out maximum amount of gold he can collect. Examples: Input : mat[][] = {{1, 3, 3}, {2, 1, 4}, {0, 6, 4}}; Output : 12 {(1,0)-\u0026gt;(2,1)-\u0026gt;(1,2)} Input: mat[][] = { {1, 3, 1, 5}, {2, 2, 4, 1}, {5, 0, 2, 3}, {0, 6, 1, 2}}; Output : 16 (2,0) -\u0026gt; (1,1) -\u0026gt; (1,2) -\u0026gt; (0,3) OR (2,0) -\u0026gt; (3,1) -\u0026gt; (2,2) -\u0026gt; (2,3) \u0026#34;\u0026#34;\u0026#34; def collectGold(gold, x, y, n, m): if ((x \u0026lt; 0) or (x == n) or (y == m)): return 0 # Right upper diagonal rightUpperDiagonal = collectGold(gold, x - 1, y + 1, n, m) # right right = collectGold(gold, x, y + 1, n, m) # Lower right diagonal rightLowerDiagonal = collectGold(gold, x + 1, y + 1, n, m) # Return the maximum and store the value return gold[x][y] + max(max(rightUpperDiagonal, rightLowerDiagonal), right) def getMaxGold(gold,n,m): maxGold = 0 for i in range(n): goldCollected = collectGold(gold, i, 0, n, m) maxGold = max(maxGold, goldCollected) return maxGold gold = [[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2] ] m,n = 4,4 print(getMaxGold(gold, n, m)) Assembly Line SchedulingProblem def carAssembly(a, t, e, x): NUM_STATION = len(a[0]) T1 = [0 for _ in range(NUM_STATION)] T2 = [0 for _ in range(NUM_STATION)] # time taken to leave first station in line 1 T1[0] = e[0] + a[0][0] # time taken to leave first station in line 2 T2[0] = e[1] + a[1][0] # Fill tables T1[] and T2[] using above given recursive relations for i in range(1, NUM_STATION): T1[i] = min(T1[i-1] + a[0][i], T2[i-1] + t[1][i] + a[0][i]) T2[i] = min(T2[i-1] + a[1][i], T1[i-1] + t[0][i] + a[1][i] ) # consider exit times and return minimum return min(T1[NUM_STATION - 1] + x[0], T2[NUM_STATION - 1] + x[1]) a = [[4, 5, 3, 2], [2, 10, 1, 4]] t = [[0, 7, 4, 5], [0, 9, 2, 8]] e = [10, 12] x = [18, 7] print(carAssembly(a, t, e, x)) Painting the Fence Problem \u0026#39;\u0026#39;\u0026#39; Given a fence with n posts and k colors, find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color. Since answer can be large return it modulo 10^9 + 7. Examples: Input : n = 2 k = 4 Output : 16 We have 4 colors and 2 posts. Ways when both posts have same color : 4 Ways when both posts have diff color : 4(choices for 1st post) * 3(choices for 2nd post) = 12 Input : n = 3 k = 2 Output : 6 \u0026#39;\u0026#39;\u0026#39; # Returns count of ways to color k posts using k colors def countWays(n, k): # There are k ways to color first post total = k mod = 1000000007 # There are 0 ways for single post to violate (same color_ and k ways to not violate (different color) same, diff = 0, k # Fill for 2 posts onwards for _ in range(2, n + 1): # Current same is same as previous diff same = diff # We always have k-1 choices for next post diff = total * (k - 1) diff = diff % mod # Total choices till i. total = (same + diff) % mod return total n, k = 3, 2 print(countWays(n, k)) Rod Cutting Problem \u0026#39;\u0026#39;\u0026#39; Given a rod of length n and a list of rod prices of length i, where 1 \u0026lt;= i \u0026lt;= n, find the optimal way to cut the rod into smaller rods to maximize profit. For example, consider the following rod lengths and values: Input: length[] = [1, 2, 3, 4, 5, 6, 7, 8] price[] = [1, 5, 8, 9, 10, 17, 17, 20] Rod length: 4 Best: Cut the rod into two pieces of length 2 each to gain revenue of 5 + 5 = 10 \u0026#39;\u0026#39;\u0026#39; def rodCut(price, n): # `T[i]` stores the maximum profit achieved from a rod of length `i` T = [0] * (n + 1) # consider a rod of length `i` for i in range(1, n + 1): # divide the rod of length `i` into two rods of length `j` and `i-j` each and take maximum for j in range(1, i + 1): T[i] = max(T[i], price[j - 1] + T[i - j]) # `T[n]` stores the maximum profit achieved from a rod of length `n` return T[n] price = [1, 5, 8, 9, 10, 17, 17, 20] n = 4 # rod length print(\u0026#39;Profit is\u0026#39;, rodCut(price, n)) Longest Common Subsequence # Function to return all LCS of substrings `X[0…m-1]`, `Y[0…n-1]` def LCS(X, Y, m, n, lookup): # if the end of either sequence is reached if m == 0 or n == 0: # create a list with one empty string and return return [\u0026#39;\u0026#39;] # if the last character of `X` and `Y` matches if X[m - 1] == Y[n - 1]: # ignore the last characters of `X` and `Y` and find all LCS of substring # `X[0…m-2]`, `Y[0…n-2]` and store it in a list lcs = LCS(X, Y, m - 1, n - 1, lookup) # append current character `X[m-1]` or `Y[n-1]` # to all LCS of substring `X[0…m-2]` and `Y[0…n-2]` for i in range(len(lcs)): lcs[i] = lcs[i] + (X[m - 1]) return lcs # we reach here when the last character of `X` and `Y` don\u0026#39;t match # if a top cell of the current cell has more value than the left cell, # then ignore the current character of string `X` and find all LCS of # substring `X[0…m-2]`, `Y[0…n-1]` if lookup[m - 1][n] \u0026gt; lookup[m][n - 1]: return LCS(X, Y, m - 1, n, lookup) # if a left cell of the current cell has more value than the top cell, # then ignore the current character of string `Y` and find all LCS of # substring `X[0…m-1]`, `Y[0…n-2]` if lookup[m][n - 1] \u0026gt; lookup[m - 1][n]: return LCS(X, Y, m, n - 1, lookup) # if the top cell has equal value to the left cell, then consider both characters top = LCS(X, Y, m - 1, n, lookup) left = LCS(X, Y, m, n - 1, lookup) # merge two lists and return return top + left # Function to fill the lookup table by finding the length of LCS # of substring `X` and `Y` def LCSLength(X, Y, lookup): # fill the lookup table in a bottom-up manner for i in range(1, len(X) + 1): for j in range(1, len(Y) + 1): # if current character of `X` and `Y` matches if X[i - 1] == Y[j - 1]: lookup[i][j] = lookup[i - 1][j - 1] + 1 # otherwise, if the current character of `X` and `Y` don\u0026#39;t match else: lookup[i][j] = max(lookup[i - 1][j], lookup[i][j - 1]) # Function to find all LCS of string `X[0…m-1]` and `Y[0…n-1]` def findLCS(X, Y): # lookup[i][j] stores the length of LCS of substring `X[0…i-1]` and `Y[0…j-1]` lookup = [[0 for _ in range(len(Y) + 1)] for _ in range(len(X) + 1)] # fill lookup table LCSLength(X, Y, lookup) # find all the longest common subsequences lcs = LCS(X, Y, len(X), len(Y), lookup) # since a list can contain duplicates, \u0026#34;convert\u0026#34; it to a set and return return set(lcs) X = \u0026#39;ABCBDAB\u0026#39; Y = \u0026#39;BDCABA\u0026#39; lcs = findLCS(X, Y) print(lcs) Longest Repeated Subsequence def LRS(X, m, n, lookup): # if the end of either sequence is reached, return an empty string if m == 0 or n == 0: return \u0026#39;\u0026#39; if X[m - 1] == X[n - 1] and m != n: return LRS(X, m - 1, n - 1, lookup) + X[m - 1] # otherwise, if characters at index `m` and `n` don\u0026#39;t match if lookup[m - 1][n] \u0026gt; lookup[m][n - 1]: return LRS(X, m - 1, n, lookup) else: return LRS(X, m, n - 1, lookup) # Function to fill the lookup table by finding the length of LRS of substring `X[0…n-1]` def LRSLength(X, lookup): # Fill the lookup table in a bottom-up manner.The first row and first column of the lookup table are already 0. for i in range(1, len(X) + 1): for j in range(1, len(X) + 1): # if characters at index `i` and `j` matches and the index are different if X[i - 1] == X[j - 1] and i != j: lookup[i][j] = lookup[i - 1][j - 1] + 1 # otherwise, if characters at index `i` and `j` are different else: lookup[i][j] = max(lookup[i - 1][j], lookup[i][j - 1]) X = \u0026#39;ATACTCGGA\u0026#39; # lookup[i][j] stores the length of LRS of substring `X[0…i-1]` and `X[0…j-1]` lookup = [[0 for _ in range(len(X) + 1)] for _ in range(len(X) + 1)] # fill lookup table LRSLength(X, lookup) # find the longest repeating subsequence print(LRS(X, len(X), len(X), lookup)) Longest Increasing Subsequence def findLIS(arr): if not arr: return [] # LIS[i] stores the longest increasing subsequence of sublist `arr[0…i]` that ends with `arr[i]` LIS = [[] for _ in range(len(arr))] # LIS[0] denotes the longest increasing subsequence ending at `arr[0]` LIS[0].append(arr[0]) # start from the second element in the list for i in range(1, len(arr)): # do for each element in sublist `arr[0…i-1]` for j in range(i): # find the longest increasing subsequence that ends with `arr[j]` # where `arr[j]` is less than the current element `arr[i]` if arr[j] \u0026lt; arr[i] and len(LIS[j]) \u0026gt; len(LIS[i]): LIS[i] = LIS[j].copy() # include `arr[i]` in `LIS[i]` LIS[i].append(arr[i]) # `j` will store the index of LIS j = 0 for i in range(len(arr)): if len(LIS[j]) \u0026lt; len(LIS[i]): j = i print(LIS[j]) arr = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] findLIS(arr) Space Optimized Solution of LCS (Print only length) def lcs(text1, text2): m, n = len(text1), len(text2) if m \u0026gt; n : text1, text2 = text2, text1 dp = [0] * (n + 1) for c in text1: prev = 0 for i, d in enumerate(text2): prev, dp[i + 1] = dp[i + 1], prev + 1 if c == d else max(dp[i], dp[i + 1]) return dp[-1] X = \u0026#34;AGGTAB\u0026#34; Y = \u0026#34;GXTXAYB\u0026#34; print(\u0026#34;Length of LCS is\u0026#34;, lcs(X, Y)) LCS (Longest Common Subsequence) of three strings \u0026#34;\u0026#34;\u0026#34; Given 3 strings of all having length \u0026lt; 100,the task is to find the longest common sub-sequence in all three given sequences. Examples: Input : str1 = \u0026#34;geeks\u0026#34; str2 = \u0026#34;geeksfor\u0026#34; str3 = \u0026#34;geeksforgeeks\u0026#34; Output : 5 Longest common subsequence is \u0026#34;geeks\u0026#34; i.e., length = 5 \u0026#34;\u0026#34;\u0026#34; X = \u0026#34;AGGT12\u0026#34; Y = \u0026#34;12TXAYB\u0026#34; Z = \u0026#34;12XBA\u0026#34; dp = [[[-1 for _ in range(100)] for _ in range(100)] for _ in range(100)] # Returns length of LCS for X[0..m-1], Y[0..n-1] and Z[0..o-1] def lcsOf3(i, j, k): if(i == -1 or j == -1 or k == -1) : return 0 if(dp[i][j][k] != -1) : return dp[i][j][k] if X[i] == Y[j] == Z[k]: dp[i][j][k] = 1 + lcsOf3(i - 1, j - 1, k - 1) else: dp[i][j][k] = max(max(lcsOf3(i - 1, j, k), lcsOf3(i, j - 1, k)), lcsOf3(i, j, k - 1)) return dp[i][j][k] m = len(X) n = len(Y) o = len(Z) print(\u0026#34;Length of LCS is\u0026#34;, lcsOf3(m - 1, n - 1, o - 1)) Maximum Sum Increasing Subsequence \u0026#34;\u0026#34;\u0026#34; Given an array of n positive integers. Write a program to find the sum of maximum sum subsequence of the given array such that the integers in the subsequence are sorted in increasing order. For example, if input is {1, 101, 2, 3, 100, 4, 5}, then output should be 106 (1 + 2 + 3 + 100), if the input array is {3, 4, 5, 10}, then output should be 22 (3 + 4 + 5 + 10) and if the input array is {10, 5, 4, 3}, then output should be 10 \u0026#34;\u0026#34;\u0026#34; def maxSumIS(arr, n): maxx = 0 msis = [0 for _ in range(n)] # Initialize msis values for all indexes for i in range(n): msis[i] = arr[i] # Compute maximum sum values in bottom up manner for i in range(1, n): for j in range(i): if (arr[i] \u0026gt; arr[j] and msis[i] \u0026lt; msis[j] + arr[i]): msis[i] = msis[j] + arr[i] # Pick maximum of all msis values for i in range(n): if maxx \u0026lt; msis[i]: maxx = msis[i] return maxx arr = [1, 101, 2, 3, 100, 4, 5] n = len(arr) print(\u0026#34;Sum of maximum sum increasing \u0026#34; + \u0026#34;subsequence is \u0026#34; +str(maxSumIS(arr, n))) Count all subsequences having product less than K \u0026#34;\u0026#34;\u0026#34; Input : [1, 2, 3, 4] k = 10 Output :11 Explanation: The subsequences are {1}, {2}, {3}, {4}, {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {1, 2, 3}, {1, 2, 4} Input : [4, 8, 7, 2] k = 50 Output : 9 \u0026#34;\u0026#34;\u0026#34; def productSubSeqCount(arr, k): n = len(arr) dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)] for i in range(1, k + 1): for j in range(1, n + 1): # number of subsequence using j-1 terms dp[i][j] = dp[i][j - 1] # if arr[j-1] \u0026gt; i it will surely make product greater thus it won\u0026#39;t contribute then if arr[j - 1] \u0026lt;= i and arr[j - 1] \u0026gt; 0: # number of subsequence using 1 to j-1 terms and j-th term dp[i][j] += dp[i // arr[j - 1]][j - 1] + 1 return dp[k][n] A = [1,2,3,4] k = 10 print(productSubSeqCount(A, k)) Longest subsequence such that difference between adjacent is one \u0026#34;\u0026#34;\u0026#34; Input : arr[] = {10, 9, 4, 5, 4, 8, 6} Output : 3 As longest subsequences with difference 1 are, \u0026#34;10, 9, 8\u0026#34;, \u0026#34;4, 5, 4\u0026#34; and \u0026#34;4, 5, 6\u0026#34; Input : arr[] = {1, 2, 3, 2, 3, 7, 2, 1} Output : 7 As longest consecutive sequence is \u0026#34;1, 2, 3, 2, 3, 2, 1\u0026#34; \u0026#34;\u0026#34;\u0026#34; def longestSubseqWithDiffOne(arr, n): # Initialize the dp[] array with 1 as a single element will be of 1 length dp = [1 for _ in range(n)] # Start traversing the given array for i in range(n): # Compare with all the previous elements for j in range(i): # If the element is consecutive then consider this subsequence and update dp[i] if required. if arr[i] in [arr[j] + 1, arr[j] - 1]: dp[i] = max(dp[i], dp[j]+1) # Longest length will be the maximum value of dp array. result = 1 for i in range(n): if (result \u0026lt; dp[i]): result = dp[i] return result arr = [1, 2, 3, 4, 5, 3, 2] # Longest subsequence with one difference is {1, 2, 3, 4, 3, 2} n = len(arr) print (longestSubseqWithDiffOne(arr, n)) Maximum subsequence sum such that no three are consecutive # sourcery skip: avoid-builtin-shadow \u0026#34;\u0026#34;\u0026#34; Input: arr[] = {1, 2, 3} Output: 5 We can\u0026#39;t take three of them, so answer is 2 + 3 = 5 Input: arr[] = {3000, 2000, 1000, 3, 10} Output: 5013 3000 + 2000 + 3 + 10 = 5013 \u0026#34;\u0026#34;\u0026#34; arr = [100, 1000, 100, 1000, 1] sum = [-1] * 10000 # Returns maximum subsequence sum such # that no three elements are consecutive def maxSumWO3Consec(n) : if(sum[n] != -1): return sum[n] # 3 Base cases (process first three elements) if(n == 0) : sum[n] = 0 return sum[n] if(n == 1) : sum[n] = arr[0] return sum[n] if(n == 2) : sum[n] = arr[1] + arr[0] return sum[n] # Process rest of the elements We have three cases sum[n] = max(max(maxSumWO3Consec(n - 1), maxSumWO3Consec(n - 2) + arr[n-1]), arr[n-1] + arr[n - 2] + maxSumWO3Consec(n - 3)) return sum[n] n = len(arr) print(maxSumWO3Consec(n)) Egg Dropping Problem import sys # Function to get minimum number of trials needed in worst case with n eggs and k floors def eggDrop(n, k): # If there are no floors, then no trials needed. OR if there is one floor, one trial needed. if k in [1, 0]: return k # We need k trials for one egg and k floors if (n == 1): return k min = sys.maxsize # Consider all droppings from 1st floor to kth floor and return the minimum of these values plus 1. for x in range(1, k + 1): res = max(eggDrop(n - 1, x - 1), eggDrop(n, k - x)) if (res \u0026lt; min): min = res return min + 1 n = 2 k = 10 print(\u0026#34;Minimum number of trials in worst case with\u0026#34;, n, \u0026#34;eggs and\u0026#34;, k, \u0026#34;floors is\u0026#34;, eggDrop(n, k)) Maximum Length Chain of Pairs \u0026#34;\u0026#34;\u0026#34; You are given n pairs of numbers. In every pair, the first number is always smaller than the second number. A pair (c, d) can follow another pair (a, b) if b \u0026lt; c. Chain of pairs can be formed in this fashion. Find the longest chain which can be formed from a given set of pairs. For example, if the given pairs are {{5, 24}, {39, 60}, {15, 28}, {27, 40}, {50, 90} }, then the longest chain that can be formed is of length 3, and the chain is {{5, 24}, {27, 40}, {50, 90}} \u0026#34;\u0026#34;\u0026#34; class Pair(object): def __init__(self, a, b): self.a = a self.b = b # This function assumes that arr[] is sorted in increasing # order according the first (or smaller) values in pairs. def maxChainLength(arr, n): max = 0 # Initialize MCL(max chain length) values for all indices mcl = [1 for _ in range(n)] # Compute optimized chain length values in bottom up manner for i in range(1, n): for j in range(i): if (arr[i].a \u0026gt; arr[j].b and mcl[i] \u0026lt; mcl[j] + 1): mcl[i] = mcl[j] + 1 # mcl[i] now stores the maximum chain length ending with pair i # Pick maximum of all MCL values for i in range(n): if (max \u0026lt; mcl[i]): max = mcl[i] return max arr = [Pair(5, 24), Pair(15, 25), Pair(27, 40), Pair(50, 60)] print(\u0026#39;Length of maximum size chain is\u0026#39;, maxChainLength(arr, len(arr))) Maximum size square sub-matrix with all 1s R = 6 C = 5 def printMaxSubSquare(M): global R,C Max = 0 # set all elements of S to 0 first S = [[0 for _ in range(C)] for _ in range(2)] # Construct the entries for i in range(R): for j in range(C): # Compute the entrie at the current position Entrie = M[i][j] if Entrie and j: Entrie = 1 + min(S[1][j - 1],min(S[0][j - 1], S[1][j])) # Save the last entrie and add the new one S[0][j] = S[1][j] S[1][j] = Entrie # Keep track of the max square length Max = max(Max, Entrie) # Print the square print(\u0026#34;Maximum size sub-matrix is: \u0026#34;) for _ in range(Max): for _ in range(Max): print(\u0026#34;1\u0026#34;,end=\u0026#34; \u0026#34;) print()\tM = [[0, 1, 1, 0, 1], [1, 1, 0, 1, 0], [0, 1, 1, 1, 0], [1, 1, 1, 1, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0]]\tprintMaxSubSquare(M) Maximum sum of pairs with specific difference \u0026#34;\u0026#34;\u0026#34; Input : arr[] = {3, 5, 10, 15, 17, 12, 9}, K = 4 Output : 62 Explanation: Then disjoint pairs with difference less than K are, (3, 5), (10, 12), (15, 17) So maximum sum which we can get is 3 + 5 + 12 + 10 + 15 + 17 = 62 Note that an alternate way to form disjoint pairs is, (3, 5), (9, 12), (15, 17), but this pairing produces lesser sum. Input : arr[] = {5, 15, 10, 300}, k = 12 Output : 25 \u0026#34;\u0026#34;\u0026#34; def maxSumPairWithDifferenceLessThanK(arr, N, k): maxSum = 0 # Sort elements to ensure every i and i-1 is closest possible pair arr.sort() # To get maximum possible sum, iterate from largest to smallest, giving larger numbers priority over smaller numbers. i = N - 1 while (i \u0026gt; 0): # Case I: Diff of arr[i] and arr[i-1] is less than K, add to maxSum # Case II: Diff between arr[i] and arr[i-1] is not less than K, move to next i since with sorting we know, # arr[i]-arr[i-1] \u0026lt; arr[i]-arr[i-2] and so on. if (arr[i] - arr[i - 1] \u0026lt; k): # Assuming only positive numbers. maxSum += arr[i] maxSum += arr[i - 1] # When a match is found skip this pair i -= 1 i -= 1 return maxSum arr = [3, 5, 10, 15, 17, 12, 9] N = len(arr) K = 4 print(maxSumPairWithDifferenceLessThanK(arr, N, K)) Min Cost PathProblem \u0026#34;\u0026#34;\u0026#34; Given a n*n matrix where all numbers are distinct, find the maximum length path (starting from any cell) such that all cells along the path are in increasing order with a difference of 1. We can move in 4 directions from a given cell (i, j), i.e., we can move to (i+1, j) or (i, j+1) or (i-1, j) or (i, j-1) with the condition that the adjacent cells have a difference of 1. Example: Input: mat[][] = {{1, 2, 9} {5, 3, 8} {4, 6, 7}} Output: 4 The longest path is 6-7-8-9. \u0026#34;\u0026#34;\u0026#34; n = 3 # Returns length of the longest path beginning with mat[i][j]. This function mainly uses lookup table dp[n][n] def findLongestFromACell(i, j, mat, dp): if (i \u0026lt; 0 or i \u0026gt;= n or j \u0026lt; 0 or j \u0026gt;= n): return 0 # If this subproblem is already solved if (dp[i][j] != -1): return dp[i][j] # To store the path lengths in all the four directions x, y, z, w = -1, -1, -1, -1 # Since all numbers are unique and in range from 1 to n * n, # there is atmost one possible direction from any cell if (j \u0026lt; n-1 and ((mat[i][j] + 1) == mat[i][j + 1])): x = 1 + findLongestFromACell(i, j + 1, mat, dp) if (j \u0026gt; 0 and (mat[i][j] + 1 == mat[i][j-1])): y = 1 + findLongestFromACell(i, j-1, mat, dp) if (i \u0026gt; 0 and (mat[i][j] + 1 == mat[i-1][j])): z = 1 + findLongestFromACell(i-1, j, mat, dp) if (i \u0026lt; n-1 and (mat[i][j] + 1 == mat[i + 1][j])): w = 1 + findLongestFromACell(i + 1, j, mat, dp) # If none of the adjacent fours is one greater we will take 1 # otherwise we will pick maximum from all the four directions dp[i][j] = max(x, max(y, max(z, max(w, 1)))) return dp[i][j] # Returns length of the longest path beginning with any cell def finLongestOverAll(mat): result = 1 # Initialize result # Create a lookup table and fill all entries in it as -1 dp = [[-1 for _ in range(n)] for _ in range(n)] # Compute longest path beginning from all cells for i in range(n): for j in range(n): if (dp[i][j] == -1): findLongestFromACell(i, j, mat, dp) # Update result if needed result = max(result, dp[i][j]) return result mat = [[1, 2, 9], [5, 3, 8], [4, 6, 7]] print(\u0026#34;Length of the longest path is \u0026#34;, finLongestOverAll(mat)) Maximum difference of zeros and ones in binary string \u0026#34;\u0026#34;\u0026#34; Given a binary string of 0s and 1s. The task is to find the length of the substring which is having a maximum difference between the number of 0s and the number of 1s (number of 0s – number of 1s). In case of all 1s print -1. Examples: Input : S = \u0026#34;11000010001\u0026#34; Output : 6 From index 2 to index 9, there are 7 0s and 1 1s, so number of 0s - number of 1s is 6. Input : S = \u0026#34;1111\u0026#34; Output : -1 \u0026#34;\u0026#34;\u0026#34; MAX = 100 # Return true if there all 1s def allones(s, n): # Checking each index is 0 or not. co = sum(1 if i == \u0026#39;1\u0026#39; else 0 for i in s) return co == n # Find the length of substring with maximum difference of zeroes and ones in binary string def findlength(arr, s, n, ind, st, dp): # If string is over if ind \u0026gt;= n: return 0 # If the state is already calculated. if dp[ind][st] != -1: return dp[ind][st] if not st: dp[ind][st] = max(arr[ind] + findlength(arr, s, n, ind + 1, 1, dp), (findlength(arr, s, n, ind + 1, 0, dp))) else: dp[ind][st] = max(arr[ind] + findlength(arr, s, n, ind + 1, 1, dp), 0) return dp[ind][st] # Returns length of substring which is having maximum difference of number of 0s and number of 1s def maxLen(s, n): # If all 1s return -1. if allones(s, n): return -1 # Else find the length. arr = [0] * MAX for i in range(n): arr[i] = 1 if s[i] == \u0026#39;0\u0026#39; else -1 dp = [[-1] * 3 for _ in range(MAX)] return findlength(arr, s, n, 0, 0, dp) s = \u0026#34;11000010001\u0026#34; n = 11 print(maxLen(s, n)) Minimum number of jumps to reach end \u0026#34;\u0026#34;\u0026#34; Given an array of integers where each element represents the max number of steps that can be made forward from that element. Write a function to return the minimum number of jumps to reach the end of the array (starting from the first element). If an element is 0, then we cannot move through that element. If we can’t reach the end, return -1. Examples: Input: arr[] = {1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9} Output: 3 (1-\u0026gt; 3 -\u0026gt; 8 -\u0026gt; 9) Explanation: Jump from 1st element to 2nd element as there is only 1 step, now there are three options 5, 8 or 9. If 8 or 9 is chosen then the end node 9 can be reached. So 3 jumps are made. Input: arr[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1} Output: 10 Explanation: In every step a jump is needed so the count of jumps is 10. \u0026#34;\u0026#34;\u0026#34; def minJumps(arr, n): # The number of jumps needed to reach the starting index is 0 if (n \u0026lt;= 1): return 0 # Return -1 if not possible to jump if (arr[0] == 0): return -1 # initialization maxReach = arr[0] # stores all time the maximal reachable index in the array step = arr[0] # stores the amount of steps we can still take jump = 1 # stores the amount of jumps necessary to reach that maximal reachable position # Start traversing array for i in range(1, n): # Check if we have reached the end of the array if (i == n-1): return jump # updating maxReach maxReach = max(maxReach, i + arr[i]) # we use a step to get to the current index step -= 1; # If no further steps left if (step == 0): # we must have used a jump jump += 1 # Check if the current index / position or lesser index is the maximum reach point from the previous indexes if(i \u0026gt;= maxReach): return -1 # re-initialize the steps to the amount of steps to reach maxReach from position i. step = maxReach - i; return -1 arr = [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9] size = len(arr) print(\u0026#34;Minimum number of jumps to reach end is % d \u0026#34; % minJumps(arr, size)) Minimum cost to fill given weight in a bag \u0026#34;\u0026#34;\u0026#34; You are given a bag of size W kg and you are provided costs of packets different weights of oranges in array cost[] where cost[i] is basically the cost of ‘i’ kg packet of oranges. Where cost[i] = -1 means that ‘i’ kg packet of orange is unavailable Find the minimum total cost to buy exactly W kg oranges and if it is not possible to buy exactly W kg oranges then print -1. It may be assumed that there is an infinite supply of all available packet types. Note: array starts from index 1. Examples: Input : W = 5, cost[] = {20, 10, 4, 50, 100} Output : 14 We can choose two oranges to minimize cost. First orange of 2Kg and cost 10. Second orange of 3Kg and cost 4. Input : W = 5, cost[] = {1, 10, 4, 50, 100} Output : 5 We can choose five oranges of weight 1 kg. \u0026#34;\u0026#34;\u0026#34; import sys # Returns the best obtainable price for a rod of length n and price[] as prices of different pieces def minCost(cost, n): dp = [0 for _ in range(n + 1)] # Build the table val[] in bottom up manner and return the last entry from the table for i in range(1, n + 1): min_cost = sys.maxsize for j in range(i): if j\u0026lt;len(cost) and cost[j]!=-1: min_cost = min(min_cost, cost[j] + dp[i - j - 1]) dp[i] = min_cost return dp[n] cost = [ 10,-1,-1,-1,-1 ] W = len(cost) print(minCost(cost, W)) Minimum removals from array to make max –min \u0026lt;= K \u0026#34;\u0026#34;\u0026#34; Input : a[] = {1, 3, 4, 9, 10, 11, 12, 17, 20} k = 4 Output : 5 Explanation: Remove 1, 3, 4 from beginning and 17, 20 from the end. Input : a[] = {1, 5, 6, 2, 8} K=2 Output : 3 Explanation: There are multiple ways to remove elements in this case. One among them is to remove 5, 6, 8. The other is to remove 1, 2, 5 \u0026#34;\u0026#34;\u0026#34; def removal(a, n, k): # sort the array a.sort() # to store the max length of array with difference \u0026lt;= k maxLen = 0 # pointer to keep track of starting of each subarray i = 0 for j in range(i+1, n): # if the subarray from i to j index is valid the store it\u0026#39;s length if a[j]-a[i] \u0026lt;= k: maxLen = max(maxLen, j-i+1) else: i += 1 if i \u0026gt;= n: break return n-maxLen a = [1, 3, 4, 9, 10, 11, 12, 17, 20] n = len(a) k = 4 print(removal(a, n, k)) Longest Common Substring \u0026#34;\u0026#34;\u0026#34; Input : X = “GeeksforGeeks”, y = “GeeksQuiz” Output : 5 Explanation: The longest common substring is “Geeks” and is of length 5. \u0026#34;\u0026#34;\u0026#34; def lcs(i, j, count): if (i == 0 or j == 0): return count if (X[i - 1] == Y[j - 1]): count = lcs(i - 1, j - 1, count + 1) count = max(count, max(lcs(i, j - 1, 0), lcs(i - 1, j, 0))) return count X = \u0026#34;abcdxyz\u0026#34; Y = \u0026#34;xyzabcd\u0026#34; n = len(X) m = len(Y) print(lcs(n, m, 0)) Count number of ways to reacha given score in a game \u0026#34;\u0026#34;\u0026#34; Consider a game where a player can score 3 or 5 or 10 points in a move. Given a total score n, find number of ways to reach the given score. Examples: Input: n = 20 Output: 4 There are following 4 ways to reach 20 (10, 10) (5, 5, 10) (5, 5, 5, 5) (3, 3, 3, 3, 3, 5) \u0026#34;\u0026#34;\u0026#34; def count(n): # table[i] will store count of solutions for value i. Initialize all table values as 0. table = [0 for _ in range(n+1)] # Base case (If given value is 0) table[0] = 1 # One by one consider given 3 moves and update the table[] values after the index greater than # or equal to the value of the picked move. for i in range(3, n+1): table[i] += table[i-3] for i in range(5, n+1): table[i] += table[i-5] for i in range(10, n+1): table[i] += table[i-10] return table[n] n = 20 print(\u0026#39;Count for\u0026#39;, n, \u0026#39;is\u0026#39;, count(n)) n = 13 print(\u0026#39;Count for\u0026#39;, n, \u0026#39;is\u0026#39;, count(n)) Count Balanced Binary Trees of Height h \u0026#34;\u0026#34;\u0026#34; Given a height h, count and return the maximum number of balanced binary trees possible with height h. A balanced binary tree is one in which for every node, the difference between heights of left and right subtree is not more than 1. Input : h = 3 Output : 15 Input : h = 4 Output : 315 \u0026#34;\u0026#34;\u0026#34; def countBT(h) : BIG_PRIME = 1000000007 if h \u0026lt; 2: return 1 dp0 = dp1 = 1 dp2 = 3 for _ in range(2,h+1): dp2 = (dp1*dp1 + 2*dp1*dp0)%BIG_PRIME dp0 = dp1 dp1 = dp2 return dp2 h = 3 print(f\u0026#34;No. of balanced binary trees of height {h} is: {str(countBT(h))}\u0026#34;) Smallest sum contiguous subarray \u0026#34;\u0026#34;\u0026#34; Given an array containing n integers. The problem is to find the sum of the elements of the contiguous subarray having the smallest(minimum) sum. Examples: Input : arr[] = {3, -4, 2, -3, -1, 7, -5} Output : -6 Subarray is {-4, 2, -3, -1} = -6 \u0026#34;\u0026#34;\u0026#34; maxsize=float(\u0026#39;inf\u0026#39;) def smallestSumSubarr(arr, n): # to store the minimum value that is ending up to the current index min_ending_here = maxsize # to store the minimum value encountered so far min_so_far = maxsize # traverse the array elements for i in range(n): # if min_ending_here \u0026gt; 0, then it could not possibly contribute to the minimum sum further if (min_ending_here \u0026gt; 0): min_ending_here = arr[i] # else add the value arr[i] to min_ending_here else: min_ending_here += arr[i] # update min_so_far min_so_far = min(min_so_far, min_ending_here) return min_so_far arr = [3, -4, 2, -3, -1, 7, -5] n = len(arr) print (\u0026#34;Smallest sum: \u0026#34;, smallestSumSubarr(arr, n)) Unbounded Knapsack (Repetition of items allowed) \u0026#34;\u0026#34;\u0026#34; Given a knapsack weight W and a set of n items with certain value vali and weight wti, we need to calculate the maximum amount that could make up this quantity exactly. This is different from classical Knapsack problem, here we are allowed to use unlimited number of instances of an item. Examples: Input : W = 100 val[] = {1, 30} wt[] = {1, 50} Output : 100 There are many ways to fill knapsack. 1) 2 instances of 50 unit weight item. 2) 100 instances of 1 unit weight item. 3) 1 instance of 50 unit weight item and 50 instances of 1 unit weight items. We get maximum value with option 2. \u0026#34;\u0026#34;\u0026#34; def unboundedKnapsack(W, n, val, wt): # dp[i] is going to store maximum value with knapsack capacity i. dp = [0 for _ in range(W + 1)] ans = 0 # Fill dp[] using above recursive formula for i in range(W + 1): for j in range(n): if (wt[j] \u0026lt;= i): dp[i] = max(dp[i], dp[i - wt[j]] + val[j]) return dp[W] W = 100 val = [10, 30, 20] wt = [5, 10, 15] n = len(val) print(unboundedKnapsack(W, n, val, wt)) Largest Independent Set Problem \u0026#34;\u0026#34;\u0026#34; Given a Binary Tree, find size of the Largest Independent Set(LIS) in it. A subset of all tree nodes is an independent set if there is no edge between any two nodes of the subset. For example, consider the following binary tree. The largest independent set(LIS) is {10, 40, 60, 70, 80} and size of the LIS is 5. \u0026#34;\u0026#34;\u0026#34; class node: def __init__(self, data): self.data = data self.left = self.right = None self.liss = 0 # A memoization function returns size of the largest independent set in a given binary tree def liss(root): if root is None: return 0 if root.liss != 0: return root.liss if root.left is None and root.right is None: root.liss = 1 return root.liss # Calculate size excluding the current node liss_excl = (liss(root.left) + liss(root.right)) # Calculate size including the current node liss_incl = 1 if root.left != None: liss_incl += (liss(root.left.left) + liss(root.left.right)) if root.right != None: liss_incl += (liss(root.right.left) + liss(root.right.right)) # Maximum of two sizes is LISS, store it for future uses. root.liss = max(liss_excl, liss_incl) return root.liss root = node(20) root.left = node(8) root.left.left = node(4) root.left.right = node(12) root.left.right.left = node(10) root.left.right.right = node(14) root.right = node(22) root.right.right = node(25) print(\u0026#34;Size of the Largest Independent Set is \u0026#34;, liss(root)) Partition problem def isPossible(elements, target): dp = [False]*(target+1) dp[0] = True for ele in elements: for j in range(target, ele - 1, -1): if dp[j - ele]: dp[j] = True return dp[target] arr = [6, 2, 5] target = 7 if isPossible(arr, target): print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) Longest Palindromic Subsequence \u0026#34;\u0026#34;\u0026#34; As another example, if the given sequence is “BBABCBCAB”, then the output should be 7 as “BABCBAB” is the longest palindromic subsequence in it. “BBBBB” and “BBCBB” are also palindromic subsequences of the given sequence, but not the longest ones. \u0026#34;\u0026#34;\u0026#34; dp = [[-1 for _ in range(1001)] for _ in range(1001)] def lps(s1, s2, n1, n2): if (n1 == 0 or n2 == 0): return 0 if (dp[n1][n2] != -1): return dp[n1][n2] if (s1[n1 - 1] == s2[n2 - 1]): dp[n1][n2] = 1 + lps(s1, s2, n1 - 1, n2 - 1) else: dp[n1][n2] = max(lps(s1, s2, n1 - 1, n2), lps(s1, s2, n1, n2 - 1)) return dp[n1][n2] seq = \u0026#34;GEEKSFORGEEKS\u0026#34; n = len(seq) s2 = seq s2 = s2[::-1] print(f\u0026#34;The length of the LPS is {lps(s2, seq, n, n)}\u0026#34;) Count All Palindromic Subsequence in a given String \u0026#34;\u0026#34;\u0026#34; Input : str = \u0026#34;abcd\u0026#34; Output : 4 Explanation :- palindromic subsequence are : \u0026#34;a\u0026#34; ,\u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; ,\u0026#34;d\u0026#34; Input : str = \u0026#34;aab\u0026#34; Output : 4 Explanation :- palindromic subsequence are :\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;aa\u0026#34; Input : str = \u0026#34;aaaa\u0026#34; Output : 15 \u0026#34;\u0026#34;\u0026#34; def countPS(i, j): if(i \u0026gt; j): return 0 if(dp[i][j] != -1): return dp[i][j] if (i == j): dp[i][j] = 1 elif str[i] == str[j]: dp[i][j] = (countPS(i + 1, j) + countPS(i, j - 1) + 1) else: dp[i][j] = (countPS(i + 1, j) + countPS(i, j - 1) - countPS(i + 1, j - 1)) return dp[i][j] str = \u0026#34;abcb\u0026#34; # remember to use variable name str otherwise program will fail dp = [[-1 for _ in range(1000)] for _ in range(1000)] n = len(str) print(\u0026#34;Total palindromic subsequence are :\u0026#34;, countPS(0, n - 1)) Longest Palindromic Substring \u0026#34;\u0026#34;\u0026#34; Suppose we have a string S. We have to find the longest palindromic substring in S. We are assuming that the length of the string S is 1000. So if the string is “BABAC”, then the longest palindromic substring is “BAB”. \u0026#34;\u0026#34;\u0026#34; def longestPalindrome( s): dp = [[False for _ in range(len(s))] for _ in range(len(s))] for i in range(len(s)): dp[i][i] = True max_length = 1 start = 0 for l in range(2,len(s)+1): for i in range(len(s)-l+1): end = i+l if l==2: if s[i] == s[end-1]: dp[i][end-1]=True max_length = l start = i elif s[i] == s[end-1] and dp[i+1][end-2]: dp[i][end-1]=True max_length = l start = i return s[start:start+max_length] print(longestPalindrome(\u0026#34;ABBABBC\u0026#34;)) Longest alternating subsequence \u0026#34;\u0026#34;\u0026#34; Input: arr[] = {1, 5, 4} Output: 3 The whole arrays is of the form x1 \u0026lt; x2 \u0026gt; x3 Input: arr[] = {1, 4, 5} Output: 2 All subsequences of length 2 are either of the form x1 \u0026lt; x2; or x1 \u0026gt; x2 Input: arr[] = {10, 22, 9, 33, 49, 50, 31, 60} Output: 6 The subsequences {10, 22, 9, 33, 31, 60} or {10, 22, 9, 49, 31, 60} or {10, 22, 9, 50, 31, 60} are longest subsequence of length 6. \u0026#34;\u0026#34;\u0026#34; def LAS(arr, n): # \u0026#34;inc\u0026#34; and \u0026#34;dec\u0026#34; initialized as 1 as single element is still LAS inc = 1 dec = 1 # Iterate from second element for i in range(1,n): if (arr[i] \u0026gt; arr[i-1]): # \u0026#34;inc\u0026#34; changes iff \u0026#34;dec\u0026#34; changes inc = dec + 1 elif (arr[i] \u0026lt; arr[i-1]): # \u0026#34;dec\u0026#34; changes iff \u0026#34;inc\u0026#34; changes dec = inc + 1 # Return the maximum length return max(inc, dec) arr = [10, 22, 9, 33, 49, 50, 31, 60] n = len(arr) print(LAS(arr, n)) Weighted Job Scheduling \u0026#34;\u0026#34;\u0026#34; Given N jobs where every job is represented by following three elements of it. Start Time Finish Time Profit or Value Associated (\u0026gt;= 0) Find the maximum profit subset of jobs such that no two jobs in the subset overlap. Example: Input: Number of Jobs n = 4 Job Details {Start Time, Finish Time, Profit} Job 1: {1, 2, 50} Job 2: {3, 5, 20} Job 3: {6, 19, 100} Job 4: {2, 100, 200} Output: The maximum profit is 250. We can get the maximum profit by scheduling jobs 1 and 4. Note that there is longer schedules possible Jobs 1, 2 and 3 but the profit with this schedule is 20+50+100 which is less than 250. \u0026#34;\u0026#34;\u0026#34; # Importing the following module to sort array based on our custom comparison function from functools import cmp_to_key # A job has start time, finish time and profit class Job: def __init__(self, start, finish, profit): self.start = start self.finish = finish self.profit = profit # A utility function that is used for sorting events according to finish time def jobComparator(s1, s2): return s1.finish \u0026lt; s2.finish # Find the latest job (in sorted array) that doesn\u0026#39;t conflict with the job[i]. If there is no compatible job, then it returns -1 def latestNonConflict(arr, i): for j in range(i - 1, -1, -1): if arr[j].finish \u0026lt;= arr[i - 1].start: return j return -1 # A recursive function that returns the maximum possible profit from given array of jobs. The array of jobs must be sorted according to finish time def findMaxProfitRec(arr, n): # Base case if n == 1: return arr[n - 1].profit # Find profit when current job is included inclProf = arr[n - 1].profit i = latestNonConflict(arr, n) if i != -1: inclProf += findMaxProfitRec(arr, i + 1) # Find profit when current job is excluded exclProf = findMaxProfitRec(arr, n - 1) return max(inclProf, exclProf) # The main function that returns the maximum possible profit from given array of jobs def findMaxProfit(arr, n): # Sort jobs according to finish time arr = sorted(arr, key = cmp_to_key(jobComparator)) return findMaxProfitRec(arr, n) values = [ (3, 10, 20), (1, 2, 50), (6, 19, 100), (2, 100, 200) ] arr = [Job(i[0], i[1], i[2]) for i in values] n = len(arr) print(\u0026#34;The optimal profit is\u0026#34;, findMaxProfit(arr, n)) Coin game winner where every player has three choices \u0026#34;\u0026#34;\u0026#34; A and B are playing a game. At the beginning there are n coins. Given two more numbers x and y. In each move a player can pick x or y or 1 coins. A always starts the game. The player who picks the last coin wins the game or the person who is not able to pick any coin loses the game. For a given value of n, find whether A will win the game or not if both are playing optimally. Examples: Input : n = 5, x = 3, y = 4 Output : A There are 5 coins, every player can pick 1 or 3 or 4 coins on his/her turn. A can win by picking 3 coins in first chance. Now 2 coins will be left so B will pick one coin and now A can win by picking the last coin. Input : 2 3 4 Output : B \u0026#34;\u0026#34;\u0026#34; # To find winner of game def findWinner(x, y, n): # To store results dp = [0 for _ in range(n + 1)] # Initial values dp[0] = False dp[1] = True # Computing other values. for i in range(2, n + 1): # If A losses any of i-1 or i-x or i-y game then he will definitely win game i if i \u0026gt;= 1 and not dp[i - 1]: dp[i] = True elif (i - x \u0026gt;= 0 and not dp[i - x]): dp[i] = True elif (i - y \u0026gt;= 0 and not dp[i - y]): dp[i] = True else: dp[i] = False # If dp[n] is true then A will game otherwise he losses return dp[n] x = 3; y = 4; n = 5 if (findWinner(x, y, n)): print(\u0026#39;A\u0026#39;) else: print(\u0026#39;B\u0026#39;) Count Derangements (Permutation such that no element appears in its original position) \u0026#34;\u0026#34;\u0026#34; A and B are playing a game. At the beginning there are n coins. Given two more numbers x and y. In each move a player can pick x or y or 1 coins. A always starts the game. The player who picks the last coin wins the game or the person who is not able to pick any coin loses the game. For a given value of n, find whether A will win the game or not if both are playing optimally. Examples: A Derangement is a permutation of n elements, such that no element appears in its original position. For example, a derangement of {0, 1, 2, 3} is {2, 3, 1, 0}. Given a number n, find the total number of Derangements of a set of n elements. Examples : Input: n = 2 Output: 1 For two elements say {0, 1}, there is only one possible derangement {1, 0} Input: n = 3 Output: 2 For three elements say {0, 1, 2}, there are two possible derangements {2, 0, 1} and {1, 2, 0} \u0026#34;\u0026#34;\u0026#34; def countDer(n): if n in [1, 2]: return n-1 a = 0 b = 1 for i in range(3, n + 1): cur = (i-1)*(a+b) a = b b = cur return b n = 4 print(\u0026#34;Count of Derangements is \u0026#34;, countDer(n)) Maximum profit by buying and selling a share at most twice \u0026#34;\u0026#34;\u0026#34; In daily share trading, a buyer buys shares in the morning and sells them on the same day. If the trader is allowed to make at most 2 transactions in a day, whereas the second transaction can only start after the first one is complete (Buy-\u0026gt;sell-\u0026gt;Buy-\u0026gt;sell). Given stock prices throughout the day, find out the maximum profit that a share trader could have made. Examples: Input: price[] = {10, 22, 5, 75, 65, 80} Output: 87 Trader earns 87 as sum of 12, 75 Buy at 10, sell at 22, Buy at 5 and sell at 80 Input: price[] = {2, 30, 15, 10, 8, 25, 80} Output: 100 Trader earns 100 as sum of 28 and 72 Buy at price 2, sell at 30, buy at 8 and sell at 80 Input: price[] = {100, 30, 15, 10, 8, 25, 80}; Output: 72 Buy at price 8 and sell at 80. Input: price[] = {90, 80, 70, 60, 50} Output: 0 Not possible to earn. \u0026#34;\u0026#34;\u0026#34; import sys def maxtwobuysell(arr, size): first_buy = -sys.maxsize; first_sell = 0; second_buy = -sys.maxsize; second_sell = 0; for i in range(size): first_buy = max(first_buy, -arr[i]); first_sell = max(first_sell, first_buy + arr[i]); second_buy = max(second_buy, first_sell - arr[i]); second_sell = max(second_sell, second_buy + arr[i]); return second_sell; arr = [ 2, 30, 15, 10, 8, 25, 80 ]; size = len(arr); print(maxtwobuysell(arr, size)); Optimal Strategy for a Game \u0026#34;\u0026#34;\u0026#34; Consider a row of n coins of values v1 . . . vn, where n is even. We play a game against an opponent by alternating turns. In each turn, a player selects either the first or last coin from the row, removes it from the row permanently, and receives the value of the coin. Determine the maximum possible amount of money we can definitely win if we move first. Note: The opponent is as clever as the user. Let us understand the problem with few examples: 5, 3, 7, 10 : The user collects maximum value as 15(10 + 5) 8, 15, 3, 7 : The user collects maximum value as 22(7 + 15) Does choosing the best at each move gives an optimal solution? No. In the second example, this is how the game can be finished: \u0026gt; User chooses 8. \u0026gt; Opponent chooses 15. \u0026gt; User chooses 7. \u0026gt; Opponent chooses 3. Total value collected by user is 15(8 + 7) \u0026gt; User chooses 7. \u0026gt; Opponent chooses 8. \u0026gt; User chooses 15. \u0026gt; Opponent chooses 3. Total value collected by user is 22(7 + 15) So if the user follows the second game state, the maximum value can be collected although the first move is not the best. \u0026#34;\u0026#34;\u0026#34; def optimalStrategyOfGame(arr, n): memo = {} # recursive top down memoized solution def solve(i, j): if i \u0026gt; j or i \u0026gt;= n or j \u0026lt; 0: return 0 k = (i, j) if k in memo: return memo[k] # if the user chooses ith coin, the opponent can choose from i+1th or jth coin. # if he chooses i+1th coin, user is left with [i+2,j] range. # if opp chooses jth coin, then user is left with [i+1,j-1] range to choose from. # Also opponent tries to choose in such a way that the user has minimum value left. option1 = arr[i] + min(solve(i+2, j), solve(i+1, j-1)) # if user chooses jth coin, opponent can choose ith coin or j-1th coin. # if opp chooses ith coin, user can choose in range [i+1,j-1]. # if opp chooses j-1th coin, user can choose in range [i,j-2]. option2 = arr[j] + min(solve(i+1, j-1), solve(i, j-2)) # since the user wants to get maximum money memo[k] = max(option1, option2) return memo[k] return solve(0, n-1) arr1 = [8, 15, 3, 7] n = len(arr1) print(optimalStrategyOfGame(arr1, n)) arr2 = [2, 2, 2, 2] n = len(arr2) print(optimalStrategyOfGame(arr2, n)) arr3 = [20, 30, 2, 2, 2, 10] n = len(arr3) print(optimalStrategyOfGame(arr3, n)) Optimal Binary Search Tree \u0026#34;\u0026#34;\u0026#34; Given a sorted array key [0.. n-1] of search keys and an array freq[0.. n-1] of frequency counts, where freq[i] is the number of searches for keys[i]. Construct a binary search tree of all keys such that the total cost of all the searches is as small as possible. Let us first define the cost of a BST. The cost of a BST node is the level of that node multiplied by its frequency. The level of the root is 1. Examples: Input: keys[] = {10, 12}, freq[] = {34, 50} There can be following two possible BSTs 10 12 \\ / 12 10 I II Frequency of searches of 10 and 12 are 34 and 50 respectively. The cost of tree I is 34*1 + 50*2 = 134 The cost of tree II is 50*1 + 34*2 = 118 \u0026#34;\u0026#34;\u0026#34; def optCost(freq, i, j): if j \u0026lt; i:\t# no elements in this subarray return 0 if j == i:\t# one element in this subarray return freq[i] # Get sum of freq[i], freq[i+1], ... freq[j] fsum = Sum(freq, i, j) # Initialize minimum value Min = float(\u0026#39;inf\u0026#39;) # One by one consider all elements as root and recursively find cost of the BST, compare the cost with min and update min if needed for r in range(i, j + 1): cost = (optCost(freq, i, r - 1) + optCost(freq, r + 1, j)) if cost \u0026lt; Min: Min = cost # Return minimum value return Min + fsum # The main function that calculates minimum cost of a Binary Search Tree. It mainly uses optCost() to find the optimal cost. def optimalSearchTree(keys, freq, n): # Here array keys[] is assumed to be sorted in increasing order. If keys[] # is not sorted, then add code to sort keys, and rearrange freq[] accordingly. return optCost(freq, 0, n - 1) # A utility function to get sum of array elements freq[i] to freq[j] def Sum(freq, i, j): return sum(freq[k] for k in range(i, j + 1)) if __name__ == \u0026#39;__main__\u0026#39;: keys = [10, 12, 20] freq = [34, 8, 50] n = len(keys) print(\u0026#34;Cost of Optimal BST is\u0026#34;, optimalSearchTree(keys, freq, n)) Palindrome PartitioningProblem \u0026#34;\u0026#34;\u0026#34; Input : str = “geek” Output : 2 We need to make minimum 2 cuts, i.e., “g ee k” Input : str = “aaaa” Output : 0 The string is already a palindrome. Input : str = “abcde” Output : 4 Input : str = “abbac” Output : 1 \u0026#34;\u0026#34;\u0026#34; def isPalindrome(x): return x == x[::-1] def minPalPartion(string, i, j): if i \u0026gt;= j or isPalindrome(string[i:j + 1]): return 0 ans = float(\u0026#39;inf\u0026#39;) for k in range(i, j): count = ( 1 + minPalPartion(string, i, k) + minPalPartion(string, k + 1, j) ) ans = min(ans, count) return ans string = \u0026#34;ababbbabbababa\u0026#34; print(\u0026#34;Min cuts needed for Palindrome Partitioning is \u0026#34;, minPalPartion(string, 0, len(string) - 1)) Word Wrap Problem \u0026#34;\u0026#34;\u0026#34; Given a sequence of words, and a limit on the number of characters that can be put in one line (line width). Put line breaks in the given sequence such that the lines are printed neatly. Assume that the length of each word is smaller than the line width. The word processors like MS Word do task of placing line breaks. The idea is to have balanced lines. In other words, not have few lines with lots of extra spaces and some lines with small amount of extra spaces. The extra spaces includes spaces put at the end of every line except the last one. The problem is to minimize the following total cost. Cost of a line = (Number of extra spaces in the line)^3 Total Cost = Sum of costs for all lines For example, consider the following string and line width M = 15 \u0026#34;Geeks for Geeks presents word wrap problem\u0026#34; Following is the optimized arrangement of words in 3 lines Geeks for Geeks presents word wrap problem The total extra spaces in line 1, line 2 and line 3 are 0, 2 and 3 respectively. So optimal value of total cost is 0 + 2*2*2 + 3*3*3 = 35 Please note that the total cost function is not sum of extra spaces, but sum of cubes (or square is also used) of extra spaces. \u0026#34;\u0026#34;\u0026#34; # A Dynamic programming solution # for Word Wrap Problem # A utility function to print # the solution # l[] represents lengths of different # words in input sequence. For example, # l[] = {3, 2, 2, 5} is for a sentence # like \u0026#34;aaa bb cc ddddd\u0026#34;. n is size of # l[] and M is line width (maximum no. # of characters that can fit in a line) INF = 2147483647 def printSolution(p, n): k = 0 if p[n] == 1: k = 1 else: k = printSolution(p, p[n] - 1) + 1 print(\u0026#39;Line number \u0026#39;, k, \u0026#39;: From word no. \u0026#39;, p[n], \u0026#39;to \u0026#39;, n) return k def solveWordWrap(l, n, M): # For simplicity, 1 extra space is used in all below arrays # extras[i][j] will have number of extra spaces if words from i to j are put in a single line extras = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # lc[i][j] will have cost of a line which has words from i to j lc = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # c[i] will have total cost of optimal arrangement of words from 1 to i c = [0 for _ in range(n + 1)] # p[] is used to print the solution. p = [0 for _ in range(n + 1)] # calculate extra spaces in a single line. The value extra[i][j] indicates # extra spaces if words from word number i to j are placed in a single line for i in range(n + 1): extras[i][i] = M - l[i - 1] for j in range(i + 1, n + 1): extras[i][j] = (extras[i][j - 1] - l[j - 1] - 1) # Calculate line cost corresponding to the above calculated extra # spaces. The value lc[i][j] indicates cost of putting words from word number i to j in a single line for i in range(n + 1): for j in range(i, n + 1): if extras[i][j] \u0026lt; 0: lc[i][j] = INF; elif j == n: lc[i][j] = 0 else: lc[i][j] = (extras[i][j] * extras[i][j]) # Calculate minimum cost and find minimum cost arrangement. The value # c[j] indicates optimized cost to arrange words from word number 1 to j. c[0] = 0 for j in range(1, n + 1): c[j] = INF for i in range(1, j + 1): if (c[i - 1] != INF and lc[i][j] != INF and ((c[i - 1] + lc[i][j]) \u0026lt; c[j])): c[j] = c[i-1] + lc[i][j] p[j] = i printSolution(p, n) l = [3, 2, 2, 5] n = len(l) M = 6 solveWordWrap(l, n, M) Mobile Numeric Keypad Problem \u0026#34;\u0026#34;\u0026#34; Given the mobile numeric keypad. You can only press buttons that are up, left, right or down to the current button. You are not allowed to press bottom row corner buttons (i.e. * and # ). Mobile-keypad Given a number N, find out the number of possible numbers of given length. Examples: For N=1, number of possible numbers would be 10 (0, 1, 2, 3, …., 9) For N=2, number of possible numbers would be 36 Possible numbers: 00,08 11,12,14 22,21,23,25 and so on. If we start with 0, valid numbers will be 00, 08 (count: 2) If we start with 1, valid numbers will be 11, 12, 14 (count: 3) If we start with 2, valid numbers will be 22, 21, 23,25 (count: 4) If we start with 3, valid numbers will be 33, 32, 36 (count: 3) If we start with 4, valid numbers will be 44,41,45,47 (count: 4) If we start with 5, valid numbers will be 55,54,52,56,58 (count: 5) .................................... .................................... We need to print the count of possible numbers. \u0026#34;\u0026#34;\u0026#34; # left, up, right, down move from current location row = [0, 0, -1, 0, 1] col = [0, -1, 0, 1, 0] # Returns count of numbers of length n starting from key position (i, j) in a numeric keyboard. def getCountUtil(keypad, i, j, n): if (keypad == None or n \u0026lt;= 0): return 0 # From a given key, only one number is possible of length 1 if (n == 1): return 1 k = 0 move = 0 ro = 0 co = 0 totalCount = 0 # move left, up, right, down from current location and if # new location is valid, then get number count of length # (n-1) from that new position and add in count obtained so far for move in range(5): ro = i + row[move] co = j + col[move] if (ro \u0026gt;= 0 and ro \u0026lt;= 3 and co \u0026gt;= 0 and co \u0026lt;= 2 and keypad[ro][co] != \u0026#39;*\u0026#39; and keypad[ro][co] != \u0026#39;#\u0026#39;): totalCount += getCountUtil(keypad, ro, co, n - 1) return totalCount # Return count of all possible numbers of length n in a given numeric keyboard def getCount(keypad, n): if keypad is None or n \u0026lt;= 0: return 0 if (n == 1): return 10 i = 0 j = 0 totalCount = 0 for i in range(4): # Loop on keypad row for j in range(3): # Loop on keypad column # Process for 0 to 9 digits if (keypad[i][j] != \u0026#39;*\u0026#39; and keypad[i][j] != \u0026#39;#\u0026#39;): # Get count when number is starting from key position (i, j) and add in count obtained so far totalCount += getCountUtil(keypad, i, j, n) return totalCount keypad = [[\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;], [\u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;], [\u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;], [\u0026#39;*\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;#\u0026#39;]] print(\u0026#34;Count for numbers of length 1:\u0026#34;, getCount(keypad, 1)) print(\u0026#34;Count for numbers of length 2:\u0026#34;, getCount(keypad, 2)) print(\u0026#34;Count for numbers of length 3:\u0026#34;, getCount(keypad, 3)) print(\u0026#34;Count for numbers of length 4:\u0026#34;, getCount(keypad, 4)) print(\u0026#34;Count for numbers of length 5:\u0026#34;, getCount(keypad, 5)) Boolean Parenthesization Problem \u0026#34;\u0026#34;\u0026#34; Given a boolean expression with the following symbols. Symbols \u0026#39;T\u0026#39; ---\u0026gt; true \u0026#39;F\u0026#39; ---\u0026gt; false And following operators filled between symbols Operators \u0026amp; ---\u0026gt; boolean AND | ---\u0026gt; boolean OR ^ ---\u0026gt; boolean XOR Count the number of ways we can parenthesize the expression so that the value of expression evaluates to true. Let the input be in form of two arrays one contains the symbols (T and F) in order and the other contains operators (\u0026amp;, | and ^} Examples: Input: symbol[] = {T, F, T} operator[] = {^, \u0026amp;} Output: 2 The given expression is \u0026#34;T ^ F \u0026amp; T\u0026#34;, it evaluates true in two ways \u0026#34;((T ^ F) \u0026amp; T)\u0026#34; and \u0026#34;(T ^ (F \u0026amp; T))\u0026#34; Input: symbol[] = {T, F, F} operator[] = {^, |} Output: 2 The given expression is \u0026#34;T ^ F | F\u0026#34;, it evaluates true in two ways \u0026#34;( (T ^ F) | F )\u0026#34; and \u0026#34;( T ^ (F | F) )\u0026#34;. Input: symbol[] = {T, T, F, T} operator[] = {|, \u0026amp;, ^} \u0026#34;\u0026#34;\u0026#34; def countParenth(symb, oper, n): F = [[0 for _ in range(n + 1)] for _ in range(n + 1)] T = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # Fill diagonal entries first # All diagonal entries in T[i][i] are 1 if symbol[i] is T (true). Similarly, all F[i][i] entries are 1 if # symbol[i] is F (False) for i in range(n): F[i][i] = 1 if symb[i] == \u0026#39;F\u0026#39; else 0 T[i][i] = 1 if symb[i] == \u0026#39;T\u0026#39; else 0 # Now fill T[i][i+1], T[i][i+2], # T[i][i+3]... in order And F[i][i+1], F[i][i+2], F[i][i+3]... in order for gap in range(1, n): for i, j in enumerate(range(gap, n)): T[i][j] = F[i][j] = 0 for g in range(gap): # Find place of parenthesization using current value of gap k = i + g # Store Total[i][k] and Total[k+1][j] tik = T[i][k] + F[i][k] tkj = T[k + 1][j] + F[k + 1][j] # Follow the recursive formulas according to the current operator if oper[k] == \u0026#39;\u0026amp;\u0026#39;: T[i][j] += T[i][k] * T[k + 1][j] F[i][j] += (tik * tkj - T[i][k] * T[k + 1][j]) if oper[k] == \u0026#39;|\u0026#39;: F[i][j] += F[i][k] * F[k + 1][j] T[i][j] += (tik * tkj - F[i][k] * F[k + 1][j]) if oper[k] == \u0026#39;^\u0026#39;: T[i][j] += (F[i][k] * T[k + 1][j] + T[i][k] * F[k + 1][j]) F[i][j] += (T[i][k] * T[k + 1][j] + F[i][k] * F[k + 1][j]) return T[0][n - 1] symbols = \u0026#34;TTFT\u0026#34; operators = \u0026#34;|\u0026amp;^\u0026#34; n = len(symbols) # There are 4 ways # ((T|T)\u0026amp;(F^T)), (T|(T\u0026amp;(F^T))), # (((T|T)\u0026amp;F)^T) and (T|((T\u0026amp;F)^T)) print(countParenth(symbols, operators, n)) Largest rectangular sub-matrix whose sum is 0 \u0026#34;\u0026#34;\u0026#34; Given a 2D matrix, find the number non-empty sub matrices, such that the sum of the elements inside the sub matrix is equal to 0. (note: elements might be negative). \u0026#34;\u0026#34;\u0026#34; import itertools def solve(A): if not A or not A[0]: return 0 # SC \u0026amp; guard cols = len(A[0]) + 1 # pad left to guard [c - 1] A = [[0] + row for row in A] for row, c in itertools.product(A, range(2, cols)): row[c] += row[c - 1] zeros = 0 for c1 in range(cols - 1): # each pair of (c, c2] for c2 in range(c1 + 1, cols): sofar = 0 seen = {0: 1} # {sum : cnt}, dict to cnt dups for row in A: # scan top-down as 1D sum 0 sofar += row[c2] - row[c1] if sofar-0 in seen: zeros += seen[sofar-0] if sofar in seen: seen[sofar] += 1 else: seen[sofar] = 1 return zeros A=[[-8, 5, 7], [3 , 7, -8], [5 ,-8, 9] ] print(solve(A)) Maximum sum rectangle in a 2D matrix # Implementation of Kadane\u0026#39;s algorithm for 1D array. The function returns the maximum sum and stores starting # and ending indexes of the maximum sum subarray at addresses pointed by start and finish pointers respectively. def kadane(arr, start, finish, n): Sum = 0 maxSum = -999999999999 i = None # Just some initial value to check for all negative values case finish[0] = -1 # local variable local_start = 0 for i in range(n): Sum += arr[i] if Sum \u0026lt; 0: Sum = 0 local_start = i + 1 elif Sum \u0026gt; maxSum: maxSum = Sum start[0] = local_start finish[0] = i # There is at-least one non-negative number if finish[0] != -1: return maxSum # Special Case: When all numbers in arr[] are negative maxSum = arr[0] start[0] = finish[0] = 0 # Find the maximum element in array for i in range(1, n): if arr[i] \u0026gt; maxSum: maxSum = arr[i] start[0] = finish[0] = i return maxSum def findMaxSum(M): global ROW, COL # Variables to store the final output maxSum, finalLeft = -999999999999, None finalRight, finalTop, finalBottom = None, None, None left, right, i = None, None, None temp = [None] * ROW Sum = 0 start = [0] finish = [0] # Set the left column for left in range(COL): # Initialize all elements of temp as 0 temp = [0] * ROW # Set the right column for the left column set by outer loop for right in range(left, COL): # Calculate sum between current left and right for every row \u0026#39;i\u0026#39; for i in range(ROW): temp[i] += M[i][right] # Find the maximum sum subarray in temp[]. The kadane() function also # sets values of start and finish So \u0026#39;sum\u0026#39; is sum of rectangle between # (start, left) and (finish, right) which is the maximum sum with boundary columns # strictly as left and right. Sum = kadane(temp, start, finish, ROW) # Compare sum with maximum sum so far. If sum is more, then update maxSum and other output values if Sum \u0026gt; maxSum: maxSum = Sum finalLeft = left finalRight = right finalTop = start[0] finalBottom = finish[0] # Prfinal values print(\u0026#34;(Top, Left)\u0026#34;, \u0026#34;(\u0026#34;, finalTop, finalLeft, \u0026#34;)\u0026#34;) print(\u0026#34;(Bottom, Right)\u0026#34;, \u0026#34;(\u0026#34;, finalBottom, finalRight, \u0026#34;)\u0026#34;) print(\u0026#34;Max sum is:\u0026#34;, maxSum) ROW = 4 COL = 5 M = [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]] findMaxSum(M) Maximum profit by buying and selling a share at most k times \u0026#34;\u0026#34;\u0026#34; Input: Price = [10, 22, 5, 75, 65, 80] K = 2 Output: 87 Trader earns 87 as sum of 12 and 75 Buy at price 10, sell at 22, buy at 5 and sell at 80 Input: Price = [12, 14, 17, 10, 14, 13, 12, 15] K = 3 Output: 12 Trader earns 12 as the sum of 5, 4 and 3 Buy at price 12, sell at 17, buy at 10 and sell at 14 and buy at 12 and sell at 15 Input: Price = [100, 30, 15, 10, 8, 25, 80] K = 3 Output: 72 Only one transaction. Buy at price 8 and sell at 80. Input: Price = [90, 80, 70, 60, 50] K = 1 Output: 0 Not possible to earn. \u0026#34;\u0026#34;\u0026#34; def maxProfit(prices, n, k): profit = [[0 for _ in range(k + 1)] for _ in range(n)] # Profit is zero for the first day and for zero transactions for i in range(1, n): for j in range(1, k + 1): max_so_far = 0 for l in range(i): max_so_far = max(max_so_far, prices[i] - prices[l] + profit[l][j - 1]) profit[i][j] = max(profit[i - 1][j], max_so_far) return profit[n - 1][k] k = 2 prices = [10, 22, 5, 75, 65, 80] n = len(prices) print(\u0026#34;Maximum profit is:\u0026#34;, maxProfit(prices, n, k)) Find if a string is interleaved of two other strings \u0026#34;\u0026#34;\u0026#34; Given three strings A, B and C. Write a function that checks whether C is an interleaving of A and B. C is said to be interleaving A and B, if it contains all and only characters of A and B and order of all characters in individual strings is preserved. Example: Input: strings: \u0026#34;XXXXZY\u0026#34;, \u0026#34;XXY\u0026#34;, \u0026#34;XXZ\u0026#34; Output: XXXXZY is interleaved of XXY and XXZ The string XXXXZY can be made by interleaving XXY and XXZ String: XXXXZY String 1: XX Y String 2: XX Z Input: strings: \u0026#34;XXY\u0026#34;, \u0026#34;YX\u0026#34;, \u0026#34;X\u0026#34; Output: XXY is not interleaved of YX and X XXY cannot be formed by interleaving YX and X. The strings that can be formed are YXX and XYX \u0026#34;\u0026#34;\u0026#34; dp = [[0]*101]*101 def dfs(i, j, A, B, C): # If path has already been calculated from this index then return calculated value. if(dp[i][j]!=-1): return dp[i][j] # If we reach the destination return 1 n,m=len(A),len(B) if(i==n and j==m): return 1 # If C[i+j] matches with both A[i] and B[j] we explore both the paths if (i\u0026lt;n and A[i]==C[i + j] and j\u0026lt;m and B[j]==C[i + j]): # go down and store the calculated value in x # and go right and store the calculated value in y. x = dfs(i + 1, j, A, B, C) y = dfs(i, j + 1, A, B, C) # return the best of both. dp[i][j] = x|y return dp[i][j] # If C[i+j] matches with A[i]. if (i \u0026lt; n and A[i] == C[i + j]): # go down x = dfs(i + 1, j, A, B, C) # Return the calculated value. dp[i][j] = x return dp[i][j] # If C[i+j] matches with B[j]. if (j \u0026lt; m and B[j] == C[i + j]): y = dfs(i, j + 1, A, B, C) # Return the calculated value. dp[i][j] = y return dp[i][j] # if nothing matches we return 0 dp[i][j] = 0 return dp[i][j] # The main function that returns true if C is # an interleaving of A and B, otherwise false. def isInterleaved(A, B, C): # Storing the length in n,m n = len(A) m = len(B) # C can be an interleaving of A and B only of the sum # of lengths of A \u0026amp; B is equal to the length of C. if((n+m)!=len(C)): return 0 # initializing dp array with -1 for i in range(n+1): for j in range(m+1): dp[i][j]=-1 # calling and returning the answer return dfs(0,0,A,B,C) def test(A, B, C): if (isInterleaved(A, B, C)): print(C, \u0026#34;is interleaved of\u0026#34;, A, \u0026#34;and\u0026#34;, B) else: print(C, \u0026#34;is not interleaved of\u0026#34;, A, \u0026#34;and\u0026#34;, B) test(\u0026#34;XXY\u0026#34;, \u0026#34;XXZ\u0026#34;, \u0026#34;XXZXXXY\u0026#34;) test(\u0026#34;XY\u0026#34;, \u0026#34;WZ\u0026#34;, \u0026#34;WZXY\u0026#34;) test(\u0026#34;XY\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XXY\u0026#34;) test(\u0026#34;YX\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XXY\u0026#34;) test(\u0026#34;XXY\u0026#34;, \u0026#34;XXZ\u0026#34;, \u0026#34;XXXXZY\u0026#34;) test(\u0026#34;ACA\u0026#34;, \u0026#34;DAS\u0026#34;, \u0026#34;DAACSA\u0026#34;) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/dp/","summary":"Coin ChangeProblem Knapsack Problem Binomial CoefficientProblem Permutation CoefficientProblem Program for nth Catalan Number Matrix Chain Multiplication Edit Distance Subset Sum Problem Friends Pairing Problem Gold Mine Problem Assembly Line SchedulingProblem Painting the Fence Problem Rod Cutting Problem Longest Common Subsequence Longest Repeated Subsequence Longest Increasing Subsequence Space Optimized Solution of LCS (Print only length) LCS (Longest Common Subsequence) of three strings Maximum Sum Increasing Subsequence Count all subsequences having product less than K Longest subsequence such that difference between adjacent is one Maximum subsequence sum such that no three are consecutive Egg Dropping Problem Maximum Length Chain of Pairs Maximum size square sub-matrix with all 1s Maximum sum of pairs with specific difference Min Cost PathProblem Maximum difference of zeros and ones in binary string Minimum number of jumps to reach end Minimum cost to fill given weight in a bag Minimum removals from array to make max –min \u0026lt;= K Longest Common Substring Count number of ways to reacha given score in a game Count Balanced Binary Trees of Height h Smallest sum contiguous subarray Unbounded Knapsack (Repetition of items allowed) Largest Independent Set Problem Partition problem Longest Palindromic Subsequence Count All Palindromic Subsequence in a given String Longest Palindromic Substring Longest alternating subsequence Weighted Job Scheduling Coin game winner where every player has three choices Count Derangements (Permutation such that no element appears in its original position) Maximum profit by buying and selling a share at most twice Optimal Strategy for a Game Optimal Binary Search Tree Palindrome PartitioningProblem Word Wrap Problem Mobile Numeric Keypad Problem Boolean Parenthesization Problem Largest rectangular sub-matrix whose sum is 0 Maximum sum rectangle in a 2D matrix Maximum profit by buying and selling a share at most k times Find if a string is interleaved of two other strings Coin ChangeProblem \u0026#34;\u0026#34;\u0026#34; Given an unlimited supply of coins of given denominations, find the total number of distinct ways to get the desired change.","title":"DSA in Python - Dynamic Programming"},{"content":" Check Leap Year Generate Random Number Largest No of 3 Prime Number Factorial Prime Number Intervals Fibonacci Sequence Armstrong Number Decimal to Binary/Hexadecimal/Octal GCD LCM Factorial Using Recursion 10 Triange Pattern Programs Check Leap Year year = 2000 # divided by 100 means century year (ending with 00) century year divided by 400 is leap year if (year % 400 == 0) and (year % 100 == 0): print(\u0026#34;{0} is a leap year\u0026#34;.format(year)) # not divided by 100 means not a century year year divided by 4 is a leap year elif (year % 4 ==0) and (year % 100 != 0): print(\u0026#34;{0} is a leap year\u0026#34;.format(year)) # if not divided by both 400 (century year) and 4 (not century year) year is not leap year else: print(\u0026#34;{0} is not a leap year\u0026#34;.format(year)) Generate Random Number import random print(random.randint(0,9)) Largest No of 3 num1 = 10 num2 = 14 num3 = 12 if (num1 \u0026gt;= num2) and (num1 \u0026gt;= num3): largest = num1 elif (num2 \u0026gt;= num1) and (num2 \u0026gt;= num3): largest = num2 else: largest = num3 print(\u0026#34;The largest number is\u0026#34;, largest) Prime Number num = 29 # define a flag variable flag = False # prime numbers are greater than 1 if num \u0026gt; 1: # check for factors for i in range(2, num): if (num % i) == 0: # if factor is found, set flag to True flag = True # break out of loop break # check if flag is True if flag: print(num, \u0026#34;is not a prime number\u0026#34;) else: print(num, \u0026#34;is a prime number\u0026#34;) Factorial num = 7 factorial = 1 # check if the number is negative, positive or zero if num \u0026lt; 0: print(\u0026#34;Sorry, factorial does not exist for negative numbers\u0026#34;) elif num == 0: print(\u0026#34;The factorial of 0 is 1\u0026#34;) else: for i in range(1,num + 1): factorial = factorial*i print(\u0026#34;The factorial of\u0026#34;,num,\u0026#34;is\u0026#34;,factorial) Prime Number Intervals lower = 900 upper = 1000 print(\u0026#34;Prime numbers between\u0026#34;, lower, \u0026#34;and\u0026#34;, upper, \u0026#34;are:\u0026#34;) for num in range(lower, upper + 1): # all prime numbers are greater than 1 if num \u0026gt; 1: for i in range(2, num): if (num % i) == 0: break else: print(num) Fibonacci Sequence nterms = int(input(\u0026#34;How many terms? \u0026#34;)) n1, n2 = 0, 1 count = 0 # check if the number of terms is valid if nterms \u0026lt;= 0: print(\u0026#34;Please enter a positive integer\u0026#34;) # if there is only one term, return n1 elif nterms == 1: print(\u0026#34;Fibonacci sequence upto\u0026#34;,nterms,\u0026#34;:\u0026#34;) print(n1) # generate fibonacci sequence else: print(\u0026#34;Fibonacci sequence:\u0026#34;) while count \u0026lt; nterms: print(n1) nth = n1 + n2 # update values n1 = n2 n2 = nth count += 1 Armstrong Number num = int(input(\u0026#34;Enter a number: \u0026#34;)) sum = 0 # find the sum of the cube of each digit temp = num while temp \u0026gt; 0: digit = temp % 10 sum += digit ** 3 temp //= 10 if num == sum: print(num,\u0026#34;is an Armstrong number\u0026#34;) else: print(num,\u0026#34;is not an Armstrong number\u0026#34;) Decimal to Binary/Hexadecimal/Octal dec = 344 print(\u0026#34;The decimal value of\u0026#34;, dec, \u0026#34;is:\u0026#34;) print(bin(dec), \u0026#34;in binary.\u0026#34;) print(oct(dec), \u0026#34;in octal.\u0026#34;) print(hex(dec), \u0026#34;in hexadecimal.\u0026#34;) GCD def compute_hcf(x, y): if x \u0026gt; y: smaller = y else: smaller = x for i in range(1, smaller+1): if((x % i == 0) and (y % i == 0)): hcf = i return hcf num1 = 54 num2 = 24 print(\u0026#34;The H.C.F. is\u0026#34;, compute_hcf(num1, num2)) LCM def compute_gcd(x, y): while(y): x, y = y, x % y return x def compute_lcm(x, y): lcm = (x*y)//compute_gcd(x,y) return lcm num1 = 54 num2 = 24 print(\u0026#34;The L.C.M. is\u0026#34;, compute_lcm(num1, num2)) Factorial Using Recursion def recur_factorial(n): if n == 1: return n else: return n*recur_factorial(n-1) num = 7 if num \u0026lt; 0: print(\u0026#34;Sorry, factorial does not exist for negative numbers\u0026#34;) elif num == 0: print(\u0026#34;The factorial of 0 is 1\u0026#34;) else: print(\u0026#34;The factorial of\u0026#34;, num, \u0026#34;is\u0026#34;, recur_factorial(num)) 10 Triange Pattern Programs \u0026#34;\u0026#34;\u0026#34; * * * * * * * * * * * * * * * \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) for i in range(rows): for j in range(i+1): print(\u0026#34;* \u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34;\\n\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 1 1 2 1 2 3 1 2 3 4 1 2 3 4 5 \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) for i in range(rows): for j in range(i+1): print(j+1, end=\u0026#34; \u0026#34;) print(\u0026#34;\\n\u0026#34;) \u0026#34;\u0026#34;\u0026#34; A B B C C C D D D D E E E E E \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) ascii_value = 65 for i in range(rows): for j in range(i+1): alphabet = chr(ascii_value) print(alphabet, end=\u0026#34; \u0026#34;) ascii_value += 1 print(\u0026#34;\\n\u0026#34;) \u0026#34;\u0026#34;\u0026#34; * * * * * * * * * * * * * * * \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) for i in range(rows, 0, -1): for j in range(0, i): print(\u0026#34;* \u0026#34;, end=\u0026#34; \u0026#34;) print(\u0026#34;\\n\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 1 2 3 4 5 1 2 3 4 1 2 3 1 2 1 \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) for i in range(rows, 0, -1): for j in range(1, i+1): print(j, end=\u0026#34; \u0026#34;) print(\u0026#34;\\n\u0026#34;) \u0026#34;\u0026#34;\u0026#34; * * * * * * * * * * * * * * * * * * * * * * * * * \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) k = 0 for i in range(1, rows+1): for space in range(1, (rows-i)+1): print(end=\u0026#34; \u0026#34;) while k!=(2*i-1): print(\u0026#34;* \u0026#34;, end=\u0026#34;\u0026#34;) k += 1 k = 0 print() \u0026#34;\u0026#34;\u0026#34; 1 2 3 2 3 4 5 4 3 4 5 6 7 6 5 4 5 6 7 8 9 8 7 6 5 \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) k = 0 count=0 count1=0 for i in range(1, rows+1): for space in range(1, (rows-i)+1): print(\u0026#34; \u0026#34;, end=\u0026#34;\u0026#34;) count+=1 while k!=((2*i)-1): if count\u0026lt;=rows-1: print(i+k, end=\u0026#34; \u0026#34;) count+=1 else: count1+=1 print(i+k-(2*count1), end=\u0026#34; \u0026#34;) k += 1 count1 = count = k = 0 print() \u0026#34;\u0026#34;\u0026#34; * * * * * * * * * * * * * * * * * * * * * * * * * \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) for i in range(rows, 1, -1): for space in range(0, rows-i): print(\u0026#34; \u0026#34;, end=\u0026#34;\u0026#34;) for j in range(i, 2*i-1): print(\u0026#34;* \u0026#34;, end=\u0026#34;\u0026#34;) for j in range(1, i-1): print(\u0026#34;* \u0026#34;, end=\u0026#34;\u0026#34;) print() \u0026#34;\u0026#34;\u0026#34; 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) coef = 1 for i in range(1, rows+1): for space in range(1, rows-i+1): print(\u0026#34; \u0026#34;,end=\u0026#34;\u0026#34;) for j in range(0, i): if j==0 or i==0: coef = 1 else: coef = coef * (i - j)//j print(coef, end = \u0026#34; \u0026#34;) print() \u0026#34;\u0026#34;\u0026#34; 1 2 3 4 5 6 7 8 9 10 \u0026#34;\u0026#34;\u0026#34; rows = int(input(\u0026#34;Enter number of rows: \u0026#34;)) number = 1 for i in range(1, rows+1): for j in range(1, i+1): print(number, end=\u0026#34; \u0026#34;) number += 1 print() ","permalink":"https://atharvashah.netlify.app/blog/dsapython/elementry-algos/","summary":"Check Leap Year Generate Random Number Largest No of 3 Prime Number Factorial Prime Number Intervals Fibonacci Sequence Armstrong Number Decimal to Binary/Hexadecimal/Octal GCD LCM Factorial Using Recursion 10 Triange Pattern Programs Check Leap Year year = 2000 # divided by 100 means century year (ending with 00) century year divided by 400 is leap year if (year % 400 == 0) and (year % 100 == 0): print(\u0026#34;{0} is a leap year\u0026#34;.","title":"DSA in Python - Elementry Algos"},{"content":" Implement Graph Implement Weighted Graph Implement BFS algorithm Implement DFS Algo Detect Cycle in Directed Graph using BFS/DFS Algo Detect Cycle in UnDirected Graph using BFS/DFS Algo Minimum Step by Knight flood fill algo Clone a graph Making wired Connections word Ladder Dijkstra algo Implement Topological Sort Minimum time taken by each job to be completed given by a Directed Acyclic Graph Find whether it is possible to finish all tasks or not from given dependencies Find the no. of Islands Given a sorted Dictionary of an Alien Language, find order of characters Implement Kruksal’sAlgorithm Implement Prim’s Algorithm Total no. of Spanning tree in a graph Implement Bellman Ford Algorithm Implement Floyd warshallAlgorithm Travelling Salesman Problem Graph ColouringProblem Snake and Ladders Problem Find bridge in a graph Count Strongly connected Components(Kosaraju Algo) Check whether a graph is Bipartite or Not Longest path in a Directed Acyclic Graph Journey to the Moon Cheapest Flights Within K Stops Oliver and the Game Water Jug problem using BFS Find if there is a path of more thank length from a source Minimum edges to reverse o make path from source to destination Paths to travel each nodes using each edge(Seven Bridges) Vertex Cover Problem Chinese Postman or Route Inspection Number of Triangles in a Directed and Undirected Graph Minimise the cashflow among a given set of friends who have borrowed money from each other Two Clique Problem Implement Graph class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) def printGraph(graph): for src in range(len(graph.adjList)): for dest in graph.adjList[src]: print(f\u0026#39;({src} —\u0026gt; {dest}) \u0026#39;, end=\u0026#39;\u0026#39;) print() edges = [(0, 1), (1, 2), (2, 0), (2, 1), (3, 2), (4, 5), (5, 4)] n = 6 graph = Graph(edges, n) printGraph(graph) Implement Weighted Graph class Graph: def __init__(self, edges, n): self.adjList = [None] * n for i in range(n): self.adjList[i] = [] for (src, dest, weight) in edges: self.adjList[src].append((dest, weight)) def printGraph(graph): for src in range(len(graph.adjList)): for (dest, weight) in graph.adjList[src]: print(f\u0026#39;({src} —\u0026gt; {dest}, {weight}) \u0026#39;, end=\u0026#39;\u0026#39;) print() # Input: Edges in a weighted digraph (as per the above diagram) # Edge (x, y, w) represents an edge from `x` to `y` having weight `w` edges = [(0, 1, 6), (1, 2, 7), (2, 0, 5), (2, 1, 4), (3, 2, 10), (4, 5, 1), (5, 4, 3)] n = 6 graph = Graph(edges, n) printGraph(graph) Implement BFS algorithm from collections import deque class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) self.adjList[dest].append(src) def BFS(graph, v, discovered): q = deque() discovered[v] = True q.append(v) while q: v = q.popleft() print(v, end=\u0026#39; \u0026#39;) for u in graph.adjList[v]: if not discovered[u]: discovered[u] = True q.append(u) edges = [ (1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (5, 9), (5, 10), (4, 7), (4, 8), (7, 11), (7, 12) # vertex 0, 13, and 14 are single nodes ] n = 15 graph = Graph(edges, n) discovered = [False] * n for i in range(n): if not discovered[i]: BFS(graph, i, discovered) Implement DFS Algo from collections import deque class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) self.adjList[dest].append(src) def iterativeDFS(graph, v, discovered): stack = deque() stack.append(v) while stack: v = stack.pop() if discovered[v]: continue discovered[v] = True print(v, end=\u0026#39; \u0026#39;) adjList = graph.adjList[v] for i in reversed(range(len(adjList))): u = adjList[i] if not discovered[u]: stack.append(u) edges = [ # Notice that node 0 is unconnected (1, 2), (1, 7), (1, 8), (2, 3), (2, 6), (3, 4), (3, 5), (8, 9), (8, 12), (9, 10), (9, 11) # (6, 9) introduces a cycle ] n = 13 graph = Graph(edges, n) discovered = [False] * n for i in range(n): if not discovered[i]: iterativeDFS(graph, i, discovered) Detect Cycle in Directed Graph using BFS/DFS Algo class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) # Perform DFS on the graph and set the departure time of all vertices of the graph def DFS(graph, v, discovered, departure, time): # mark the current node as discovered discovered[v] = True # do for every edge (v, u) for u in graph.adjList[v]: # if `u` is not yet discovered if not discovered[u]: time = DFS(graph, u, discovered, departure, time) # ready to backtrack set departure time of vertex `v` departure[v] = time time = time + 1 return time # Returns true if the given directed graph is DAG def isDAG(graph, n): # keep track of whether a vertex is discovered or not discovered = [False] * n # keep track of the departure time of a vertex in DFS departure = [None] * n time = 0 # Perform DFS traversal from all undiscovered vertices to visit all connected components of a graph for i in range(n): if not discovered[i]: time = DFS(graph, i, discovered, departure, time) # check if the given directed graph is DAG or not for u in range(n): # check if (u, v) forms a back-edge. for v in graph.adjList[u]: # If the departure time of vertex `v` is greater than equal # to the departure time of `u`, they form a back edge. # Note that `departure[u]` will be equal to `departure[v]` # only if `u = v`, i.e., vertex contain an edge to itself if departure[u] \u0026lt;= departure[v]: return False # no back edges return True # List of graph edges as per the above diagram edges = [(0, 1), (0, 3), (1, 2), (1, 3), (3, 2), (3, 4), (3, 0), (5, 6), (6, 3)] # total number of nodes in the graph (labelled from 0 to 6) n = 7 graph = Graph(edges, n) if isDAG(graph, n): print(\u0026#39;Does not contain a Cycle\u0026#39;) else: print(\u0026#39;Contains a Cycle\u0026#39;) Detect Cycle in UnDirected Graph using BFS/DFS Algo class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) self.adjList[dest].append(src) # Function to perform DFS traversal on the graph on a graph def DFS(graph, v, discovered, parent=-1): # mark the current node as discovered discovered[v] = True # do for every edge (v, w) for w in graph.adjList[v]: # if `w` is not discovered if not discovered[w]: if DFS(graph, w, discovered, v): return True # if `w` is discovered, and `w` is not a parent elif w != parent: # we found a back-edge (cycle) return True # No back-edges were found in the graph return False edges = [ (0, 1), (0, 6), (0, 7), (1, 2), (1, 5), (2, 3), (2, 4), (7, 8), (7, 11), (8, 9), (8, 10), (10, 11) # edge (10, 11) introduces a cycle in the graph ] # total number of nodes in the graph (0 to 11) n = 12 graph = Graph(edges, n) discovered = [False] * n if DFS(graph, 0, discovered): print(\u0026#39;The graph contains a cycle\u0026#39;) else: print(\u0026#39;The graph doesn\\\u0026#39;t contain any cycle\u0026#39;) Minimum Step by Knight \u0026#34;\u0026#34;\u0026#34;Given a chessboard, find the shortest distance (minimum number of steps) taken by a knight to reach a given destination from a given source. For example, Input: N = 8 (8 × 8 board) Source = (7, 0) Destination = (0, 7) Output: Minimum number of steps required is 6 \u0026#34;\u0026#34;\u0026#34; import sys from collections import deque class Node: # (x, y) represents chessboard coordinates `dist` represents its minimum distance from the source def __init__(self, x, y, dist=0): self.x = x self.y = y self.dist = dist # As we are using `Node` as a key in a dictionary, we need to override the `__hash__()` and `__eq__()` function def __hash__(self): return hash((self.x, self.y, self.dist)) def __eq__(self, other): return (self.x, self.y, self.dist) == (other.x, other.y, other.dist) # Below lists detail all eight possible movements for a knight row = [2, 2, -2, -2, 1, 1, -1, -1] col = [-1, 1, 1, -1, 2, -2, 2, -2] # Check if (x, y) is valid chessboard coordinates. # Note that a knight cannot go out of the chessboard def isValid(x, y, N): return x \u0026gt;= 0 and y \u0026gt;= 0 and x \u0026lt; N and y \u0026lt; N # Find the minimum number of steps taken by the knight # from the source to reach the destination using BFS def findShortestDistance(src, dest, N): # set to check if the matrix cell is visited before or not visited = set() # create a queue and enqueue the first node q = deque() q.append(src) # loop till queue is empty while q: # dequeue front node and process it node = q.popleft() x = node.x y = node.y dist = node.dist # if the destination is reached, return distance if x == dest.x and y == dest.y: return dist # skip if the location is visited before if node not in visited: # mark the current node as visited visited.add(node) # check for all eight possible movements for a knight # and enqueue each valid movement for i in range(len(row)): # get the knight\u0026#39;s valid position from the current position on # the chessboard and enqueue it with +1 distance x1 = x + row[i] y1 = y + col[i] if isValid(x1, y1, N): q.append(Node(x1, y1, dist + 1)) # return infinity if the path is not possible return sys.maxsize N = 8 # N x N matrix src = Node(0, 7) # source coordinates dest = Node(7, 0) # destination coordinates print(\u0026#34;The minimum number of steps required is\u0026#34;,findShortestDistance(src, dest, N)) flood fill algo \u0026#34;\u0026#34;\u0026#34;Flood fill (also known as seed fill) is an algorithm that determines the area connected to a given node in a multi-dimensional array. \u0026#34;\u0026#34;\u0026#34; # Below lists detail all eight possible movements row = [-1, -1, -1, 0, 0, 1, 1, 1] col = [-1, 0, 1, -1, 1, -1, 0, 1] # check if it is possible to go to pixel (x, y) from the # current pixel. The function returns false if the pixel # has a different color, or it\u0026#39;s not a valid pixel def isSafe(mat, x, y, target): return 0 \u0026lt;= x \u0026lt; len(mat) and 0 \u0026lt;= y \u0026lt; len(mat[0]) and mat[x][y] == target # Flood fill using DFS def floodfill(mat, x, y, replacement): # base case if not mat or not len(mat): return # get the target color target = mat[x][y] # target color is same as replacement if target == replacement: return # replace the current pixel color with that of replacement mat[x][y] = replacement # process all eight adjacent pixels of the current pixel and # recur for each valid pixel for k in range(len(row)): # if the adjacent pixel at position (x + row[k], y + col[k]) is # a valid pixel and has the same color as that of the current pixel if isSafe(mat, x + row[k], y + col[k], target): floodfill(mat, x + row[k], y + col[k], replacement) mat = [ [\u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;], [\u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;W\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;W\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;W\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;W\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;W\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;W\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;], [\u0026#39;W\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;X\u0026#39;] ] # start node x, y = (3, 9) # having a target color `X` # replacement color replacement = \u0026#39;C\u0026#39; # replace the target color with a replacement color using DFS floodfill(mat, x, y, replacement) # print the colors after replacement for r in mat: print(r) Clone a graph TODO Making wired Connections \u0026#34;\u0026#34;\u0026#34;There are n computers numbered from 0 to n-1 connected by ethernet cables connections forming a network where connections[i] = [a, b] represents a connection between computers a and b. Any computer can reach any other computer directly or indirectly through the network. Given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected. Return the minimum number of times you need to do this in order to make all the computers connected. If it’s not possible, return -1. Example 1: Input: n = 4, connections = [[0,1],[0,2],[1,2]] Output: 1 Explanation: Remove cable between computer 1 and 2 and place between computers 1 and 3. Example 2: Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] Output: 2 Example 3: Input: n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] Output: -1 Explanation: There are not enough cables. Example 4: Input: n = 5, connections = [[0,1],[0,2],[3,4],[2,3]] Output: 0 \u0026#34;\u0026#34;\u0026#34; def makeConnected(n, connections): uf = {i: i for i in range(n)} def find(x): uf.setdefault(x, x) if uf[x] != x: uf[x] = find(uf[x]) return uf[x] def union(a, b): uf[find(a)] = find(b) if len(connections) \u0026lt; n - 1: return -1 for a, b in connections: union(a, b) islands = len({find(x) for x in uf}) return islands - 1 n = 4 connections = [[0,1],[0,2],[1,2]] print(makeConnected(n, connections)) word Ladder \u0026#34;\u0026#34;\u0026#34; Given two words (beginWord and endWord), and a dictionary\u0026#39;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: (i) Only one letter can be changed at a time, and (ii) each transformed word must exist in the word list. Note that beginWord is not a transformed word. EXAMPLES beginWord = \u0026#34;hit\u0026#34; endWord = \u0026#34;cog\u0026#34; wordList = [\u0026#34;hot\u0026#34;,\u0026#34;dot\u0026#34;,\u0026#34;dog\u0026#34;,\u0026#34;lot\u0026#34;,\u0026#34;log\u0026#34;,\u0026#34;cog\u0026#34;] -\u0026gt; 5 (because \u0026#34;hit\u0026#34; -\u0026gt; \u0026#34;hot\u0026#34; -\u0026gt; \u0026#34;dot\u0026#34; -\u0026gt; \u0026#34;dog\u0026#34; -\u0026gt; \u0026#34;cog\u0026#34;) \u0026#34;\u0026#34;\u0026#34; from collections import deque def ladderLength(beginWord, endWord, wordList): \u0026#34;\u0026#34;\u0026#34; :type beginWord: str :type endWord: str :type wordList: Set[str] :rtype: int \u0026#34;\u0026#34;\u0026#34; queue = deque() queue.append((beginWord, [beginWord])) while queue: node, path = queue.popleft() for next in next_nodes(node, wordList) - set(path): if next == endWord: return len(path) + 1 else: queue.append((next, path + [next])) return 0 def next_nodes(word, word_list): to_return = set() for w in word_list: mismatch_count, w_length = 0, len(w) for i in range(w_length): if w[i] != word[i]: mismatch_count += 1 if mismatch_count == 1: to_return.add(w) return to_return beginWord = \u0026#34;hit\u0026#34; endWord = \u0026#34;cog\u0026#34; wordList = [\u0026#34;hot\u0026#34;,\u0026#34;dot\u0026#34;,\u0026#34;dog\u0026#34;,\u0026#34;lot\u0026#34;,\u0026#34;log\u0026#34;,\u0026#34;cog\u0026#34;] print(ladderLength(beginWord, endWord, wordList)) Dijkstra algo \u0026#34;\u0026#34;\u0026#34; Given a source vertex s from a set of vertices V in a weighted digraph where all its edge weights w(u, v) are non-negative, find the shortest path weights d(s, v) from source s for all vertices v present in the graph \u0026#34;\u0026#34;\u0026#34; import sys from heapq import heappop, heappush class Node: def __init__(self, vertex, weight=0): self.vertex = vertex self.weight = weight # Override the __lt__() function to make `Node` class work with a min-heap def __lt__(self, other): return self.weight \u0026lt; other.weight class Graph: def __init__(self, edges, n): # allocate memory for the adjacency list self.adjList = [[] for _ in range(n)] # add edges to the directed graph for (source, dest, weight) in edges: self.adjList[source].append((dest, weight)) def get_route(prev, i, route): if i \u0026gt;= 0: get_route(prev, prev[i], route) route.append(i) def findShortestPaths(graph, source, n): # create a min-heap and push source node having distance 0 pq = [] heappush(pq, Node(source)) # set initial distance from the source to `v` as infinity dist = [sys.maxsize] * n # distance from the source to itself is zero dist[source] = 0 # list to track vertices for which minimum cost is already found done = [False] * n done[source] = True # stores predecessor of a vertex (to a print path) prev = [-1] * n # run till min-heap is empty while pq: node = heappop(pq) # Remove and return the best vertex u = node.vertex # get the vertex number # do for each neighbor `v` of `u` for (v, weight) in graph.adjList[u]: if not done[v] and (dist[u] + weight) \u0026lt; dist[v]: # Relaxation step dist[v] = dist[u] + weight prev[v] = u heappush(pq, Node(v, dist[v])) # mark vertex `u` as done so it will not get picked up again done[u] = True route = [] for i in range(n): if i != source and dist[i] != sys.maxsize: get_route(prev, i, route) print(f\u0026#39;Path ({source} —\u0026gt; {i}): Minimum cost = {dist[i]}, Route = {route}\u0026#39;) route.clear() # initialize edges as per the above diagram (u, v, w) represent edge from vertex `u` to vertex `v` having weight `w` edges = [(0, 1, 10), (0, 4, 3), (1, 2, 2), (1, 4, 4), (2, 3, 9), (3, 2, 7), (4, 1, 1), (4, 2, 8), (4, 3, 2)] # total number of nodes in the graph (labelled from 0 to 4) n = 5 graph = Graph(edges, n) for source in range(n): findShortestPaths(graph, source, n) Implement Topological Sort \u0026#34;\u0026#34;\u0026#34; Given a Directed Acyclic Graph (DAG), print it in topological order using topological sort algorithm. If the graph has more than one topological ordering, output any of them. Assume valid Directed Acyclic Graph (DAG). A Topological sort or Topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering. A topological ordering is possible if and only if the graph has no directed cycles, i.e. if the graph is DAG. \u0026#34;\u0026#34;\u0026#34; # A class to represent a graph object class Graph: def __init__(self, edges, n): self.adjList = [[] for _ in range(n)] for (src, dest) in edges: self.adjList[src].append(dest) # Perform DFS on the graph and set the departure time of all vertices of the graph def DFS(graph, v, discovered, departure, time): discovered[v] = True time = time + 1 for u in graph.adjList[v]: if not discovered[u]: time = DFS(graph, u, discovered, departure, time) departure[time] = v time = time + 1 return time # Function to perform a topological sort on a given DAG def doTopologicalSort(graph, n): # departure[] stores the vertex number using departure time as an index departure = [-1] * 2 * n \u0026#39;\u0026#39;\u0026#39; If we had done it the other way around, i.e., fill the array with departure time using vertex number as an index, we would need to sort it later \u0026#39;\u0026#39;\u0026#39; # to keep track of whether a vertex is discovered or not discovered = [False] * n time = 0 # perform DFS on all undiscovered vertices for i in range(n): if not discovered[i]: time = DFS(graph, i, discovered, departure, time) # Print the vertices in order of their decreasing # departure time in DFS, i.e., in topological order for i in reversed(range(2*n)): if departure[i] != -1: print(departure[i], end=\u0026#39; \u0026#39;) # List of graph edges as per the above diagram edges = [(0, 6), (1, 2), (1, 4), (1, 6), (3, 0), (3, 4), (5, 1), (7, 0), (7, 1)] # total number of nodes in the graph (labelled from 0 to 7) n = 8 graph = Graph(edges, n) doTopologicalSort(graph, n) Minimum time taken by each job to be completed given by a Directed Acyclic Graph \u0026#34;\u0026#34;\u0026#34; Given a Directed Acyclic Graph having V vertices and E edges, where each edge {U, V} represents the Jobs U and V such that Job V can only be started only after completion of Job U. The task is to determine the minimum time taken by each job to be completed where each Job takes unit time to get completed. \u0026#34;\u0026#34;\u0026#34; from collections import defaultdict class Graph: def __init__(self, vertices, edges): self.graph = defaultdict(list) self.n = vertices self.m = edges # Function to add an edge to graph def addEdge(self, u, v): self.graph[u].append(v) # Function to find the minimum time needed by each node to get the task def printOrder(self, n, m): # Create a vector to store indegrees of all vertices. Initialize all indegrees as 0. indegree = [0] * (self.n + 1) # Traverse adjacency lists to fill indegrees of vertices. This step takes O(V + E) time for i in self.graph: for j in self.graph[i]: indegree[j] += 1 # Array to store the time in which the job i can be done job = [0] * (self.n + 1) # Create an queue and enqueue all vertices with indegree 0 q = [] # Update the time of the jobs who don\u0026#39;t require any job to be completed before this job for i in range(1, self.n + 1): if indegree[i] == 0: q.append(i) job[i] = 1 # Iterate until queue is empty while q: # Get front element of queue cur = q.pop(0) for adj in self.graph[cur]: # Decrease in-degree of the current node indegree[adj] -= 1 # Push its adjacent elements if (indegree[adj] == 0): job[adj] = 1 + job[cur] q.append(adj) # Print the time to complete the job for i in range(1, n + 1): print(job[i], end = \u0026#34; \u0026#34;) print() # Given Nodes N and edges M n = 10 m = 13 g = Graph(n, m) g.addEdge(1, 3) g.addEdge(1, 4) g.addEdge(1, 5) g.addEdge(2, 3) g.addEdge(2, 8) g.addEdge(2, 9) g.addEdge(3, 6) g.addEdge(4, 6) g.addEdge(4, 8) g.addEdge(5, 8) g.addEdge(6, 7) g.addEdge(7, 8) g.addEdge(8, 10) g.printOrder(n, m) Find whether it is possible to finish all tasks or not from given dependencies \u0026#34;\u0026#34;\u0026#34; There are a total of n tasks you have to pick, labelled from 0 to n-1. Some tasks may have prerequisites, for example to pick task 0 you have to first pick task 1, which is expressed as a pair: [0, 1] Given the total number of tasks and a list of prerequisite pairs, is it possible for you to finish all tasks? Examples: Input: 2, [[1, 0]] Output: true Explanation: There are a total of 2 tasks to pick. To pick task 1 you should have finished task 0. So it is possible. Input: 2, [[1, 0], [0, 1]] Output: false Explanation: There are a total of 2 tasks to pick. To pick task 1 you should have finished task 0, and to pick task 0 you should also have finished task 1. So it is impossible. Input: 3, [[1, 0], [2, 1], [3, 2]] Output: true Explanation: There are a total of 3 tasks to pick. To pick tasks 1 you should have finished task 0, and to pick task 2 you should have finished task 1 and to pick task 3 you should have finished task 2. So it is possible. \u0026#34;\u0026#34;\u0026#34; class Solution: arr = [] # parameterized constructor def __init__(self,n): # Initially, everyone is their own child self.arr = list(range(n)) def makeParent(self,a, b): # find parent of b and make it a\u0026#39;s parent self.arr[a] = self.findParent(b) def findParent(self,c): # when an independent task is found return c if (c == self.arr) else self.findParent(self.arr) def isPossible(self,N , prerequisites): # traverse through pre-requisites array for i in range(len(prerequisites)): # check whether given pre-requisite pair already have a common pre-requisite(parent) if (self.findParent(prerequisites[i][0]) == self.findParent(prerequisites[i][1])): # tasks cannot be completed because there was a cyclic condition in the tasks return False # make parent-child relation between pre-requisite task and the task dependent on it self.makeParent(prerequisites[i][0], prerequisites[i][1]) # if there was no cycle found, tasks can be completed return True prerequisites = [[1, 0], [2, 1], [3, 2]] ob = Solution(4) if ob.isPossible(4,prerequisites ): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) Find the no. of Islands \u0026#34;\u0026#34;\u0026#34; Given a boolean 2D matrix, find the number of islands. A group of connected 1s forms an island. For example, the below matrix contains 5 islands Example: Input : mat[][] = {{1, 1, 0, 0, 0}, {0, 1, 0, 0, 1}, {1, 0, 0, 1, 1}, {0, 0, 0, 0, 0}, {1, 0, 1, 0, 1}} Output : 5 \u0026#34;\u0026#34;\u0026#34; # Program to count islands in boolean 2D matrix class Graph: def __init__(self, row, col, graph): self.ROW = row self.COL = col self.graph = graph # A utility function to do DFS for a 2D boolean matrix. It only considers the 8 neighbours as adjacent vertices def DFS(self, i, j): if i \u0026lt; 0 or i \u0026gt;= len(self.graph) or j \u0026lt; 0 or j \u0026gt;= len(self.graph[0]) or self.graph[i][j] != 1: return # mark it as visited self.graph[i][j] = -1 # Recur for 8 neighbours self.DFS(i - 1, j - 1) self.DFS(i - 1, j) self.DFS(i - 1, j + 1) self.DFS(i, j - 1) self.DFS(i, j + 1) self.DFS(i + 1, j - 1) self.DFS(i + 1, j) self.DFS(i + 1, j + 1) # The main function that returns count of islands in a given boolean 2D matrix def countIslands(self): # Initialize count as 0 and traverse through the all cells of given matrix count = 0 for i in range(self.ROW): for j in range(self.COL): # If a cell with value 1 is not visited yet, then new island found if self.graph[i][j] == 1: # Visit all cells in this island and increment island count self.DFS(i, j) count += 1 return count graph = [ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ] row = len(graph) col = len(graph[0]) g = Graph(row, col, graph) print(\u0026#34;Number of islands is:\u0026#34;, g.countIslands()) Given a sorted Dictionary of an Alien Language, find order of characters \u0026#34;\u0026#34;\u0026#34; Given a dictionary of ancient origin where the words are arranged alphabetically, find the correct order of alphabets in the ancient language. For example, Input: Ancient dictionary { ¥€±, €±€, €±‰ð, ðß, ±±ð, ±ßß } Output: The correct order of alphabets in the ancient language is {¥ € ‰ ð ± ß}. Since the input is small, more than one ordering is possible. Another such ordering is {¥ € ð ± ß ‰}. Input: Ancient dictionary { ÿ€±š, €€€ß, €€‰ð, ðß, ±ß¥š } Output: The correct order of alphabets in the ancient language is {ÿ € ‰ ð ±}. The alphabets {š, ß, ¥} are not included in the order as they are not properly defined. \u0026#34;\u0026#34;\u0026#34; class Graph: def __init__(self, N): self.adj = [[] for _ in range(N)] def DFS(graph, v, discovered, departure, time): discovered[v] = True time = time + 1 for u in graph.adj[v]: if not discovered[u]: time = DFS(graph, u, discovered, departure, time) departure[time] = v return time + 1 # Utility function to performs topological sort on a given DAG def doTopologicalSort(graph, d): # `departure[]` stores the vertex number using departure time as an index departure = [-1] * (2 * N) \u0026#39;\u0026#39;\u0026#39; If we had done it the other way around, i.e., fill the array with departure time using vertex number as an index, we would need to sort it later \u0026#39;\u0026#39;\u0026#39; # to keep track of whether a vertex is discovered or not discovered = [False] * N time = 0 # perform DFS on all undiscovered connected vertices for i in range(N): if not discovered[i] and len(graph.adj[i]): time = DFS(graph, i, discovered, departure, time) print(\u0026#39;\\nThe correct order of alphabets in the ancient language is\u0026#39;, end=\u0026#39; \u0026#39;) # Print the vertices in order of their decreasing # departure time in DFS, i.e., in topological order for i in reversed(range(2*N)): if departure[i] != -1: print(d[departure[i]], end=\u0026#39; \u0026#39;) # Utility function to print adjacency list representation of a graph def printGraph(graph, d): for i in range(N): # ignore vertices with no outgoing edges if graph.adj[i]: # print current vertex and all neighboring vertices of a vertex `i` print(d[i], \u0026#39;—\u0026gt;\u0026#39;, [d[v] for v in graph.adj[i]]) # Function to find the correct order of alphabets in a given dictionary of # ancient origin. This function assumes that the input is correct. def findAlphabetsOrder(dictionary): # create a dictionary to map each non-ASCII character present in the given dictionary with a unique integer d = {} k = 0 # do for each word for word in dictionary: # do for each non-ASCII character of the word for s in word: # if the current character is not present in the dictionary, insert it d.setdefault(s, k) k = k + 1 # create a graph containing `N` nodes graph = Graph(N) # iterate through the complete dictionary and compare adjacent words for character mismatch for i in range(1, len(dictionary)): # previous word in the dictionary prev = dictionary[i - 1] # current word in the dictionary curr = dictionary[i] # iterate through both `prev` and `curr` simultaneously and find the first mismatching character j = 0 while j \u0026lt; len(prev) and j \u0026lt; len(curr): # mismatch found if prev[j] is not curr[j]: # add an edge from the current character of `prev` to the # current character of `curr` in the graph graph.adj[d[prev[j]]].append(d[curr[j]]) break j += 1 # create a reverse dict reverse = {v: k for k, v in d.items()} printGraph(graph, reverse) # perform a topological sort on the above graph doTopologicalSort(graph, reverse) # define the maximum number of alphabets in the ancient dictionary N = 100 dictionary = [ [\u0026#34;¥\u0026#34;, \u0026#34;€\u0026#34;, \u0026#34;±\u0026#34;], [\u0026#34;€\u0026#34;, \u0026#34;±\u0026#34;, \u0026#34;€\u0026#34;], [\u0026#34;€\u0026#34;, \u0026#34;±\u0026#34;, \u0026#34;‰\u0026#34;, \u0026#34;ð\u0026#34;], [\u0026#34;ð\u0026#34;, \u0026#34;ß\u0026#34;], [\u0026#34;±\u0026#34;, \u0026#34;±\u0026#34;, \u0026#34;ð\u0026#34;], [\u0026#34;±\u0026#34;, \u0026#34;ß\u0026#34;, \u0026#34;ß\u0026#34;] ] findAlphabetsOrder(dictionary) Implement Kruksal’sAlgorithm \u0026#34;\u0026#34;\u0026#34; Below are the steps for finding MST using Kruskal’s algorithm 1. Sort all the edges in non-decreasing order of their weight. 2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it. 3. Repeat step#2 until there are (V-1) edges in the spanning tree. \u0026#34;\u0026#34;\u0026#34; from collections import defaultdict class Graph: def __init__(self, vertices): self.V = vertices # No. of vertices self.graph = [] # default dictionary # to store graph # function to add an edge to graph def addEdge(self, u, v, w): self.graph.append([u, v, w]) # A utility function to find set of an element i (uses path compression technique) def find(self, parent, i): return i if parent[i] == i else self.find(parent, parent[i]) # A function that does union of two sets of x and y (uses union by rank) def union(self, parent, rank, x, y): xroot = self.find(parent, x) yroot = self.find(parent, y) # Attach smaller rank tree under root of high rank tree (Union by Rank) if rank[xroot] \u0026lt; rank[yroot]: parent[xroot] = yroot elif rank[xroot] \u0026gt; rank[yroot]: parent[yroot] = xroot # If ranks are same, then make one as root and increment its rank by one else: parent[yroot] = xroot rank[xroot] += 1 # The main function to construct MST using Kruskal\u0026#39;s algorithm def KruskalMST(self): result = [] # This will store the resultant MST i = 0 # An index variable, used for sorted edges e = 0 # An index variable, used for result[] # Step 1: Sort all the edges in non-decreasing order of their # weight. If we are not allowed to change the given graph, we can create a copy of graph self.graph = sorted(self.graph, key=lambda item: item[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(self.V): parent.append(node) rank.append(0) # Number of edges to be taken is equal to V-1 while e \u0026lt; self.V - 1: # Step 2: Pick the smallest edge and increment the index for next iteration u, v, w = self.graph[i] i = i + 1 x = self.find(parent, u) y = self.find(parent, v) # If including this edge doesn\u0026#39;t cause cycle, include it in result and increment the indexof # result for next edge if x != y: e += 1 result.append([u, v, w]) self.union(parent, rank, x, y) # Else discard the edge minimumCost = 0 print (\u0026#34;Edges in the constructed MST\u0026#34;) for u, v, weight in result: minimumCost += weight print(\u0026#34;%d -- %d == %d\u0026#34; % (u, v, weight)) print(\u0026#34;Minimum Spanning Tree\u0026#34; , minimumCost) g = Graph(4) g.addEdge(0, 1, 10) g.addEdge(0, 2, 6) g.addEdge(0, 3, 5) g.addEdge(1, 3, 15) g.addEdge(2, 3, 4) g.KruskalMST() Implement Prim’s Algorithm # A Python program for Prim\u0026#39;s Minimum Spanning Tree (MST) algorithm. # The program is for adjacency matrix representation of the graph import sys # Library for INT_MAX class Graph(): def __init__(self, vertices): self.V = vertices self.graph = [[0 for column in range(vertices)] for row in range(vertices)] # A utility function to print the constructed MST stored in parent[] def printMST(self, parent): print (\u0026#34;Edge \\tWeight\u0026#34;) for i in range(1, self.V): print (parent[i], \u0026#34;-\u0026#34;, i, \u0026#34;\\t\u0026#34;, self.graph[i][parent[i]]) # A utility function to find the vertex with minimum distance value, from the set of vertices not yet included in shortest path tree def minKey(self, key, mstSet): # Initialize minValue value minValue = sys.maxsize for v in range(self.V): if key[v] \u0026lt; minValue and mstSet[v] == False: minValue = key[v] min_index = v return min_index # Function to construct and print MST for a graph represented using adjacency matrix representation def primMST(self): # Key values used to pick minimum weight edge in cut key = [sys.maxsize] * self.V parent = [None] * self.V # Array to store constructed MST # Make key 0 so that this vertex is picked as first vertex key[0] = 0 mstSet = [False] * self.V parent[0] = -1 # First node is always the root of for cout in range(self.V): # Pick the minimum distance vertex from the set of vertices not yet processed. u is always equal to src in first iteration u = self.minKey(key, mstSet) # Put the minimum distance vertex in the shortest path tree mstSet[u] = True # Update dist value of the adjacent vertices of the picked vertex only if the current # distance is greater than new distance and the vertex in not in the shortest path tree for v in range(self.V): # graph[u][v] is non zero only for adjacent vertices of m mstSet[v] is false for vertices not yet included in MST # Update the key only if graph[u][v] is smaller than key[v] if self.graph[u][v] \u0026gt; 0 and mstSet[v] == False and key[v] \u0026gt; self.graph[u][v]: key[v] = self.graph[u][v] parent[v] = u self.printMST(parent) g = Graph(5) g.graph = [ [0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0]] g.primMST(); Total no. of Spanning tree in a graph TODO Implement Bellman Ford Algorithm \u0026#34;\u0026#34;\u0026#34; We are given a directed graph. We need to compute whether the graph has a negative cycle or not. A negative cycle is one in which the overall sum of the cycle becomes negative. \u0026#34;\u0026#34;\u0026#34; # a structure to represent a weighted edge in graph class Edge: def __init__(self): self.src = 0 self.dest = 0 self.weight = 0 # a structure to represent a connected, directed and weighted graph class Graph: def __init__(self): # V. Number of vertices, E. Number of edges self.V = 0 self.E = 0 # graph is represented as an array of edges. self.edge = None # Creates a graph with V vertices and E edges def createGraph(V, E): graph = Graph() graph.V = V; graph.E = E; graph.edge = [Edge() for _ in range(graph.E)] return graph; # The main function that finds shortest distances from src to all other vertices using Bellman- Ford algorithm. The function also detects negative weight cycle def isNegCycleBellmanFord(graph, src): V = graph.V; E = graph.E; dist = [1000000 for _ in range(V)]; dist[src] = 0; # Step 2: Relax all edges |V| - 1 times. # A simple shortest path from src to any other vertex can have at-most |V| - 1 edges for _ in range(1, V): for j in range(E): u = graph.edge[j].src; v = graph.edge[j].dest; weight = graph.edge[j].weight; if (dist[u] != 1000000 and dist[u] + weight \u0026lt; dist[v]): dist[v] = dist[u] + weight; # Step 3: check for negative-weight cycles. # The above step guarantees shortest distances if graph doesn\u0026#39;t contain negative weight cycle. # If we get a shorter path, then there is a cycle. for i in range(E): u = graph.edge[i].src; v = graph.edge[i].dest; weight = graph.edge[i].weight; if (dist[u] != 1000000 and dist[u] + weight \u0026lt; dist[v]): return True; return False; # Let us create the graph given in above example V = 5; # Number of vertices in graph E = 8; # Number of edges in graph graph = createGraph(V, E) source= [0,0,1,1,1,3,3,4] destination= [1,2,2,3,4,2,1,3] weight=[-1,4,3,2,2,5,1,-3] for i in range(E): graph.edge[i].src=source[i] graph.edge[i].dest=destination[i] graph.edge[i].weight=weight[i] if (isNegCycleBellmanFord(graph, 0)): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) Implement Floyd warshallAlgorithm \u0026#34;\u0026#34;\u0026#34; The Floyd Warshall Algorithm is for solving the All Pairs Shortest Path problem. The problem is to find shortest distances between every pair of vertices in a given edge weighted directed Graph. Example: Input: graph[][] = { {0, 5, INF, 10}, {INF, 0, 3, INF}, {INF, INF, 0, 1}, {INF, INF, INF, 0} } which represents the following graph 10 (0)-------\u0026gt;(3) | /|\\ 5 | | | | 1 \\|/ | (1)-------\u0026gt;(2) 3 Note that the value of graph[i][j] is 0 if i is equal to j And graph[i][j] is INF (infinite) if there is no edge from vertex i to j. Output: Shortest distance matrix 0 5 8 9 INF 0 3 4 INF INF 0 1 INF INF INF 0 \u0026#34;\u0026#34;\u0026#34; def floydWarshall(graph): dist = list(map(lambda i: list(map(lambda j: j, i)), graph)) for k in range(V): # pick all vertices as source one by one for i in range(V): # Pick all vertices as destination for the above picked source for j in range(V): # If vertex k is on the shortest path from i to j, then update the value of dist[i][j] dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]) printSolution(dist) # A utility function to print the solution def printSolution(dist): print (\u0026#34;Following matrix shows the shortest distances\\ between every pair of vertices\u0026#34;) for i in range(V): for j in range(V): if(dist[i][j] == INF): print (\u0026#34;%7s\u0026#34; % (\u0026#34;INF\u0026#34;),end=\u0026#34; \u0026#34;) else: print (\u0026#34;%7d\\t\u0026#34; % (dist[i][j]),end=\u0026#39; \u0026#39;) if j == V-1: print () # Let us create the following weighted graph \u0026#34;\u0026#34;\u0026#34; 10 (0)-------\u0026gt;(3) |\t/|\\ 5 |\t| |\t| 1 \\|/\t| (1)-------\u0026gt;(2) 3\t\u0026#34;\u0026#34;\u0026#34; # Number of vertices in the graph V = 4 INF = 99999 graph = [[0, 5, INF, 10], [INF, 0, 3, INF], [INF, INF, 0, 1], [INF, INF, INF, 0] ] floydWarshall(graph) Travelling Salesman Problem \u0026#34;\u0026#34;\u0026#34; Travelling Salesman Problem (TSP): Given a set of cities and the distance between every pair of cities, the problem is to find the shortest possible route that visits every city exactly once and returns to the starting point. \u0026#34;\u0026#34;\u0026#34; n = 4 # there are four nodes in example graph (graph is 1-based) # dist[i][j] represents shortest distance to go from i to this matrix can be calculated for any given graph usin all-pair shortest path algorithms dist = [[0, 0, 0, 0, 0], [0, 0, 10, 15, 20], [ 0, 10, 0, 25, 25], [0, 15, 25, 0, 30], [0, 20, 25, 30, 0]] # memoization for top down recursion memo = [[-1]*(1 \u0026lt;\u0026lt; (n+1)) for _ in range(n+1)] def fun(i, mask): # base case # if only ith bit and 1st bit is set in our mask, it implies we have visited all other nodes already if mask == ((1 \u0026lt;\u0026lt; i) | 3): return dist[1][i] # memoization if memo[i][mask] != -1: return memo[i][mask] res = 10**9 # result of this sub-problem # we have to travel all nodes j in mask and end the path at ith node so for every node j in mask, recursively calculate cost of travelling all nodes in mask except i and then travel back from node j to node i taking # the shortest path take the minimum of all possible j nodes for j in range(1, n+1): if (mask \u0026amp; (1 \u0026lt;\u0026lt; j)) != 0 and j != i and j != 1: res = min(res, fun(j, mask \u0026amp; (~(1 \u0026lt;\u0026lt; i))) + dist[j][i]) memo[i][mask] = res # storing the minimum value return res ans = 10**9 for i in range(1, n+1): # try to go from node 1 visiting all nodes in between to i then return from i taking the shortest route to 1 ans = min(ans, fun(i, (1 \u0026lt;\u0026lt; (n+1))-1) + dist[i][1]) print(f\u0026#34;The cost of most efficient tour = {str(ans)}\u0026#34;) Graph ColouringProblem TODO Snake and Ladders Problem \u0026#34;\u0026#34;\u0026#34; On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: You start on square 1 of the board (which is always in the last row and first column). Each move, starting from square x, consists of the following: You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is \u0026lt;= N*N. (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.) If S has a snake or ladder, you move to the destination of that snake or ladder. Otherwise, you move to S. A board square on row r and column c has a “snake or ladder” if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving. (For example, if the board is [[4,-1],[-1,3]], and on the first move your destination square is 2, then you finish your first move at 3, because you do not continue moving to 4.) Return the least number of moves required to reach square N*N. If it is not possible, return -1. \u0026#34;\u0026#34;\u0026#34; import collections def snakesAndLadders(board): rows = len(board) total_square = rows*rows def next_square(step): quot, rem = divmod(step-1, rows) row = (rows - 1) - quot col = rem if row%2 != rows%2 else (rows - 1) - rem return row, col dist = {1: 0}#square and step queue = collections.deque([1]) while queue: square = queue.popleft() if square == total_square: return dist[square] for new_square in range(square+1, min(square+6, total_square) + 1): r, c = next_square(new_square) if board[r][c] != -1: new_square = board[r][c] if new_square not in dist: dist[new_square] = dist[square] + 1 queue.append(new_square) board=[ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] print(snakesAndLadders(board)) Find bridge in a graph from collections import defaultdict #This class represents an undirected graph using adjacency list representation class Graph: def __init__(self,vertices): self.V= vertices #No. of vertices self.graph = defaultdict(list) # default dictionary to store graph self.Time = 0 # function to add an edge to graph def addEdge(self,u,v): self.graph[u].append(v) self.graph[v].append(u) \u0026#39;\u0026#39;\u0026#39; A recursive function that finds and prints bridges using DFS traversal u --\u0026gt; The vertex to be visited next visited[] --\u0026gt; keeps track of visited vertices disc[] --\u0026gt; Stores discovery times of visited vertices parent[] --\u0026gt; Stores parent vertices in DFS tree \u0026#39;\u0026#39;\u0026#39; def bridgeUtil(self, u, visited, parent, low, disc): # Mark the current node as visited and print it visited[u]= True # Initialize discovery time and low value disc[u] = self.Time low[u] = self.Time self.Time += 1 #Recur for all the vertices adjacent to this vertex for v in self.graph[u]: # If v is not visited yet, then make it a child of u in DFS tree and recur for it if visited[v] == False : parent[v] = u self.bridgeUtil(v, visited, parent, low, disc) # Check if the subtree rooted with v has a connection to one of the ancestors of u low[u] = min(low[u], low[v]) \u0026#39;\u0026#39;\u0026#39; If the lowest vertex reachable from subtree under v is below u in DFS tree, then u-v is a bridge\u0026#39;\u0026#39;\u0026#39; if low[v] \u0026gt; disc[u]: print (\u0026#34;%d %d\u0026#34; %(u,v)) elif v != parent[u]: # Update low value of u for parent function calls. low[u] = min(low[u], disc[v]) # DFS based function to find all bridges. It uses recursive function bridgeUtil() def bridge(self): # Mark all the vertices as not visited and Initialize parent and visited, and ap(articulation point) arrays visited = [False] * (self.V) disc = [float(\u0026#34;Inf\u0026#34;)] * (self.V) low = [float(\u0026#34;Inf\u0026#34;)] * (self.V) parent = [-1] * (self.V) # Call the recursive helper function to find bridges in DFS tree rooted with vertex \u0026#39;i\u0026#39; for i in range(self.V): if visited[i] == False: self.bridgeUtil(i, visited, parent, low, disc) g1 = Graph(5) g1.addEdge(1, 0) g1.addEdge(0, 2) g1.addEdge(2, 1) g1.addEdge(0, 3) g1.addEdge(3, 4) print (\u0026#34;Bridges in first graph \u0026#34;) g1.bridge() g2 = Graph(4) g2.addEdge(0, 1) g2.addEdge(1, 2) g2.addEdge(2, 3) print (\u0026#34;\\nBridges in second graph \u0026#34;) g2.bridge() g3 = Graph (7) g3.addEdge(0, 1) g3.addEdge(1, 2) g3.addEdge(2, 0) g3.addEdge(1, 3) g3.addEdge(1, 4) g3.addEdge(1, 6) g3.addEdge(3, 5) g3.addEdge(4, 5) print (\u0026#34;\\nBridges in third graph \u0026#34;) g3.bridge() Count Strongly connected Components(Kosaraju Algo) from collections import defaultdict class Graph: def __init__(self,vertices): self.V= vertices self.graph = defaultdict(list) def addEdge(self,u,v): self.graph[u].append(v) # A function used by DFS def DFSUtil(self,v,visited): # Mark the current node as visited and print it visited[v]= True print (v) #Recur for all the vertices adjacent to this vertex for i in self.graph[v]: if visited[i]==False: self.DFSUtil(i,visited) def fillOrder(self,v,visited, stack): # Mark the current node as visited visited[v]= True #Recur for all the vertices adjacent to this vertex for i in self.graph[v]: if visited[i]==False: self.fillOrder(i, visited, stack) stack = stack.append(v) # Function that returns reverse (or transpose) of this graph def getTranspose(self): g = Graph(self.V) # Recur for all the vertices adjacent to this vertex for i in self.graph: for j in self.graph[i]: g.addEdge(j,i) return g # The main function that finds and prints all strongly connected components def printSCCs(self): stack = [] # Mark all the vertices as not visited (For first DFS) visited =[False]*(self.V) # Fill vertices in stack according to their finishing times for i in range(self.V): if visited[i]==False: self.fillOrder(i, visited, stack) # Create a reversed graph gr = self.getTranspose() # Mark all the vertices as not visited (For second DFS) visited =[False]*(self.V) # Now process all vertices in order defined by Stack while stack: i = stack.pop() if visited[i]==False: gr.DFSUtil(i, visited) print() # Create a graph given in the above diagram g = Graph(5) g.addEdge(1, 0) g.addEdge(0, 2) g.addEdge(2, 1) g.addEdge(0, 3) g.addEdge(3, 4) print (\u0026#34;Following are strongly connected components \u0026#34; + \u0026#34;in given graph\u0026#34;) g.printSCCs() Check whether a graph is Bipartite or Not V = 4 def colorGraph(G, color, pos, c): if color[pos] not in [-1, c]: return False # color this pos as c and all its neighbours and 1-c color[pos] = c ans = True for i in range(V): if G[pos][i]: if color[i] == -1: ans \u0026amp;= colorGraph(G, color, i, 1-c) if color[i] not in [-1, 1 - c]: return False if not ans: return False return True def isBipartite(G): color = [-1] * V #start is vertex 0 pos = 0 # two colors 1 and 0 return colorGraph(G, color, pos, 1) G = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]] if isBipartite(G): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) Longest path in a Directed Acyclic Graph def topologicalSortUtil(v): global Stack, visited, adj visited[v] = True for i in adj[v]: if (not visited[i[0]]): topologicalSortUtil(i[0]) Stack.append(v) # The function to find longest distances from a given vertex. It uses recursive topologicalSortUtil() to get topological sorting. def longestPath(s): global Stack, visited, adj, V dist = [-10**9 for _ in range(V)] # Call the recursive helper function to store Topological Sort starting from all vertices one by one for i in range(V): if (visited[i] == False): topologicalSortUtil(i) # Initialize distances to all vertices as infinite and distance to source as 0 dist[s] = 0 # Process vertices in topological order while (len(Stack) \u0026gt; 0): # Get the next vertex from topological order u = Stack[-1] del Stack[-1] # Update distances of all adjacent vertices if (dist[u] != 10**9): for i in adj[u]: if (dist[i[0]] \u0026lt; dist[u] + i[1]): dist[i[0]] = dist[u] + i[1] # Print calculated longest distances print(dist) for i in range(V): print(\u0026#34;INF \u0026#34;,end=\u0026#34;\u0026#34;) if (dist[i] == -10**9) else print(dist[i],end=\u0026#34; \u0026#34;) V, Stack, visited = 6, [], [False for _ in range(7)] adj = [[] for _ in range(7)] # Create a graph given in the above diagram. # Here vertex numbers are 0, 1, 2, 3, 4, 5 with following mappings: # 0=r, 1=s, 2=t, 3=x, 4=y, 5=z adj[0].append([1, 5]) adj[0].append([2, 3]) adj[1].append([3, 6]) adj[1].append([2, 2]) adj[2].append([4, 4]) adj[2].append([5, 2]) adj[2].append([3, 7]) adj[3].append([5, 1]) adj[3].append([4, -1]) adj[4].append([5, -2]) s = 1 print(\u0026#34;Following are longest distances from source vertex \u0026#34;,s) longestPath(s) Journey to the Moon TODO Cheapest Flights Within K Stops TODO Oliver and the Game TODO Water Jug problem using BFS \u0026#34;\u0026#34;\u0026#34; You are given an m liter jug and a n liter jug. Both the jugs are initially empty. The jugs don’t have markings to allow measuring smaller quantities. You have to use the jugs to measure d liters of water where d is less than n. (X, Y) corresponds to a state where X refers to the amount of water in Jug1 and Y refers to the amount of water in Jug2 Determine the path from the initial state (xi, yi) to the final state (xf, yf), where (xi, yi) is (0, 0) which indicates both Jugs are initially empty and (xf, yf) indicates a state which could be (0, d) or (d, 0). The operations you can perform are: Empty a Jug, (X, Y)-\u0026gt;(0, Y) Empty Jug 1 Fill a Jug, (0, 0)-\u0026gt;(X, 0) Fill Jug 1 Pour water from one jug to the other until one of the jugs is either empty or full, (X, Y) -\u0026gt; (X-d, Y+d) Examples: Input : 4 3 2 Output : {(0, 0), (0, 3), (3, 0), (3, 3), (4, 2), (0, 2)} \u0026#34;\u0026#34;\u0026#34; from collections import deque def BFS(a, b, target): # Map is used to store the states, every state is hashed to binary value to indicate either that state is visited before or not m = {} isSolvable = False path = [] # Queue to maintain states q = deque() # Initialing with initial state q.append((0, 0)) while (len(q) \u0026gt; 0): # Current state u = q.popleft() #q.pop() #pop off used state # If this state is already visited if ((u[0], u[1]) in m): continue # Doesn\u0026#39;t met jug constraints if ((u[0] \u0026gt; a or u[1] \u0026gt; b or u[0] \u0026lt; 0 or u[1] \u0026lt; 0)): continue # Filling the vector for constructing the solution path path.append([u[0], u[1]]) # Marking current state as visited m[(u[0], u[1])] = 1 # If we reach solution state, put ans=1 if (u[0] == target or u[1] == target): isSolvable = True if (u[0] == target): if (u[1] != 0): # Fill final state path.append([u[0], 0]) else: if (u[0] != 0): # Fill final state path.append([0, u[1]]) # Print the solution path sz = len(path) for i in range(sz): print(\u0026#34;(\u0026#34;, path[i][0], \u0026#34;,\u0026#34;, path[i][1], \u0026#34;)\u0026#34;) break # If we have not reached final state then, start developing intermediate states to reach solution state q.append([u[0], b]) # Fill Jug2 q.append([a, u[1]]) # Fill Jug1 for ap in range(max(a, b) + 1): # Pour amount ap from Jug2 to Jug1 c = u[0] + ap d = u[1] - ap # Check if this state is possible or not if (c == a or (d == 0 and d \u0026gt;= 0)): q.append([c, d]) # Pour amount ap from Jug 1 to Jug2 c = u[0] - ap d = u[1] + ap # Check if this state is possible or not if ((c == 0 and c \u0026gt;= 0) or d == b): q.append([c, d]) # Empty Jug2 q.append([a, 0]) # Empty Jug1 q.append([0, b]) # No, solution exists if ans=0 if (not isSolvable): print (\u0026#34;No solution\u0026#34;) Jug1, Jug2, target = 4, 3, 2 print(\u0026#34;Path from initial state to solution state ::\u0026#34;) BFS(Jug1, Jug2, target) Find if there is a path of more thank length from a source \u0026#34;\u0026#34;\u0026#34; Given a graph, a source vertex in the graph and a number k, find if there is a simple path (without any cycle) starting from given source and ending at any other vertex such that the distance from source to that vertex is atleast ‘k’ length. Example: Input : Source s = 0, k = 58 Output : True There exists a simple path 0 -\u0026gt; 7 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 8 -\u0026gt; 6 -\u0026gt; 5 -\u0026gt; 3 -\u0026gt; 4 Which has a total distance of 60 km which is more than 58. Input : Source s = 0, k = 62 Output : False In the above graph, the longest simple path has distance 61 (0 -\u0026gt; 7 -\u0026gt; 1-\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5-\u0026gt; 6 -\u0026gt; 8, so output should be false for any input greater than 61. \u0026#34;\u0026#34;\u0026#34; # Program to find if there is a simple path with # weight more than k # This class represents a dipathted graph using # adjacency list representation class Graph: # Allocates memory for adjacency list def __init__(self, V): self.V = V self.adj = [[] for _ in range(V)] # Returns true if graph has path more than k length def pathMoreThanK(self,src, k): # Create a path array with nothing included in path path = [False]*self.V # Add source vertex to path path[src] = 1 return self.pathMoreThanKUtil(src, k, path) # Prints shortest paths from src to all other vertices def pathMoreThanKUtil(self,src, k, path): # If k is 0 or negative, return true if (k \u0026lt;= 0): return True # Get all adjacent vertices of source vertex src and recursively explore all paths from src. i = 0 while i != len(self.adj[src]): # Get adjacent vertex and weight of edge v = self.adj[src][i][0] w = self.adj[src][i][1] i += 1 # If vertex v is already there in path, then there is a cycle (we ignore this edge) if (path[v] == True): continue # If weight of is more than k, return true if (w \u0026gt;= k): return True # Else add this vertex to path path[v] = True # If this adjacent can provide a path longer than k, return true. if (self.pathMoreThanKUtil(v, k-w, path)): return True # Backtrack path[v] = False # If no adjacent could produce longer path, return false return False # Utility function to an edge (u, v) of weight w def addEdge(self,u, v, w): self.adj[u].append([v, w]) self.adj[v].append([u, w]) # create the graph given in above figure V = 9 g = Graph(V) # making above shown graph g.addEdge(0, 1, 4) g.addEdge(0, 7, 8) g.addEdge(1, 2, 8) g.addEdge(1, 7, 11) g.addEdge(2, 3, 7) g.addEdge(2, 8, 2) g.addEdge(2, 5, 4) g.addEdge(3, 4, 9) g.addEdge(3, 5, 14) g.addEdge(4, 5, 10) g.addEdge(5, 6, 2) g.addEdge(6, 7, 1) g.addEdge(6, 8, 6) g.addEdge(7, 8, 7) src = 0 k = 62 if g.pathMoreThanK(src, k): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) k = 60 if g.pathMoreThanK(src, k): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) Minimum edges to reverse o make path from source to destination \u0026#34;\u0026#34;\u0026#34; Given a directed graph and a source node and destination node, we need to find how many edges we need to reverse in order to make at least 1 path from the source node to the destination node. \u0026#34;\u0026#34;\u0026#34; def addEdge(u, v, w): global adj adj[u].append((v, w)) def shortestPath(src): # Create a set to store vertices that are being preprocessed setds = {} # Create a vector for distances and initialize all distances as infinite (INF) dist = [10**18 for _ in range(V)] # Insert source itself in Set and initialize its global adj setds[(0, src)] = 1 dist[src] = 0 while setds: # The first vertex in Set is the minimum distance vertex, extract it from set. tmp = list(setds.keys())[0] del setds[tmp] # vertex label is stored in second of pair (it has to be done this way to keep the vertices sorted distance (distance must be first item in pair) u = tmp[1] # \u0026#39;i\u0026#39; is used to get all adjacent vertices of a vertex # list\u0026lt; pair\u0026lt;int, int\u0026gt; \u0026gt;::iterator i; for i in adj[u]: # Get vertex label and weight of current adjacent # of u. v = i[0]; weight = i[1] # If there is shorter path to v through u. if (dist[v] \u0026gt; dist[u] + weight): # /* If distance of v is not INF then it must be in #\tour set, so removing it and inserting again #\twith updated less distance. #\tNote : We extract only those vertices from Set #\tfor which distance is finalized. So for them, #\twe would never reach here. */ if (dist[v] != 10**18): del setds[(dist[v], v)] # Updating distance of v dist[v] = dist[u] + weight setds[(dist[v], v)] = 1 return dist # method adds reverse edge of each original edge in the graph. It gives reverse edge a weight = 1 and all original edges a weight of 0. Now, the length of the shortest path will give us the answer. If shortest path is p: it means we used p reverse edges in the shortest path. def modelGraphWithEdgeWeight(edge, E, V): global adj for i in range(E): addEdge(edge[i][0], edge[i][1], 0) # original edge : weight 0 addEdge(edge[i][1], edge[i][0], 1) # reverse edge : weight 1 # Method returns minimum number of edges to be reversed to reach from src to dest def getMinEdgeReversal(edge, E, V,src, dest): # get modified graph with edge weight modelGraphWithEdgeWeight(edge, E, V) # get shortes path vector dist = shortestPath(src) # If distance of destination is still INF, not possible return -1 if (dist[dest] == 10**18) else dist[dest] V = 7 edge = [[0, 1], [2, 1], [2, 3], [5, 1],[4, 5], [6, 4], [6, 3]] E, adj = len(edge), [[] for _ in range(V + 1)] minEdgeToReverse = getMinEdgeReversal(edge, E, V, 0, 6) if (minEdgeToReverse != -1): print(minEdgeToReverse) else: print(\u0026#34;Not possible\u0026#34;) Paths to travel each nodes using each edge(Seven Bridges) TODO Vertex Cover Problem \u0026#34;\u0026#34;\u0026#34; There are n nodes and m bridges in between these nodes. Print the possible path through each node using each edges (if possible), traveling through each edges only once. \u0026#34;\u0026#34;\u0026#34; from collections import defaultdict class Graph: def __init__(self, vertices): self.V = vertices self.graph = defaultdict(list) def addEdge(self, u, v): self.graph[u].append(v) def printVertexCover(self): # Initialize all vertices as not visited. visited = [False] * (self.V) # Consider all edges one by one for u in range(self.V): # An edge is only picked when both visited[u] and visited[v] are false if not visited[u]: # Go through all adjacents of u and pick the first not yet visited # vertex (We are basically picking an edge (u, v) from remaining edges. for v in self.graph[u]: if not visited[v]: # Add the vertices (u, v) to the # result set. We make the vertex u and v visited so that all # edges from/to them would be ignored visited[v] = True visited[u] = True break # Print the vertex cover for j in range(self.V): if visited[j]: print(j, end = \u0026#39; \u0026#39;) print() g = Graph(7) g.addEdge(0, 1) g.addEdge(0, 2) g.addEdge(1, 3) g.addEdge(3, 4) g.addEdge(4, 5) g.addEdge(5, 6) g.printVertexCover() Chinese Postman or Route Inspection TODO Number of Triangles in a Directed and Undirected Graph \u0026#34;\u0026#34;\u0026#34; Given a Graph, count number of triangles in it. The graph is can be directed or undirected. Example: Input: digraph[V][V] = { {0, 0, 1, 0}, {1, 0, 0, 1}, {0, 1, 0, 0}, {0, 0, 1, 0} }; Output: 2 Give adjacency matrix represents following directed graph. \u0026#34;\u0026#34;\u0026#34; # function to calculate the number of triangles in a simple directed/undirected graph. # isDirected is true if the graph is directed, its false otherwise def countTriangle(g, isDirected): nodes = len(g) count_Triangle = 0 # Consider every possible triplet of edges in graph for i in range(nodes): for j in range(nodes): for k in range(nodes): # check the triplet if it satisfies the condition if(i != j and i != k and j != k and g[i][j] and g[j][k] and g[k][i]): count_Triangle += 1 # If graph is directed , division is done by 3 else division by 6 is done if isDirected: return (count_Triangle//3) else: return (count_Triangle//6) # Create adjacency matrix of an undirected graph graph = [[0, 1, 1, 0], [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 1, 0]] # Create adjacency matrix of a directed graph digraph = [[0, 0, 1, 0], [1, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0]] print(\u0026#34;The Number of triangles in undirected graph : %d\u0026#34; % countTriangle(graph, False)) print(\u0026#34;The Number of triangles in directed graph : %d\u0026#34; % countTriangle(digraph, True)) Minimise the cashflow among a given set of friends who have borrowed money from each other \u0026#34;\u0026#34;\u0026#34; Given a number of friends who have to give or take some amount of money from one another. Design an algorithm by which the total cash flow among all the friends is minimized. \u0026#34;\u0026#34;\u0026#34; # Number of persons(or vertices in graph) N = 3 # A utility function that returns index of minimum value in arr[] def getMin(arr): minInd = 0 for i in range(1, N): if (arr[i] \u0026lt; arr[minInd]): minInd = i return minInd # A utility function that returns index of maximum value in arr[] def getMax(arr): maxInd = 0 for i in range(1, N): if (arr[i] \u0026gt; arr[maxInd]): maxInd = i return maxInd def minOf2(x, y): return x if x \u0026lt; y else y # amount[p] indicates the net amount to be credited/debited to/from person \u0026#39;p\u0026#39; If amount[p] is positive, then i\u0026#39;th person will amount[i] If amount[p] is negative, then i\u0026#39;th person will give -amount[i] def minCashFlowRec(amount): # Find the indexes of minimum and maximum values in amount[] amount[mxCredit] indicates the maximum amount to be given(or credited) to any person. And amount[mxDebit] indicates the maximum amount to be taken (or debited) from any person. So if there is a positive value in amount[], then there must be a negative value mxCredit = getMax(amount) mxDebit = getMin(amount) # If both amounts are 0, then all amounts are settled if (amount[mxCredit] == 0 and amount[mxDebit] == 0): return 0 # Find the minimum of two amounts min = minOf2(-amount[mxDebit], amount[mxCredit]) amount[mxCredit] -=min amount[mxDebit] += min # If minimum is the maximum amount to be print(\u0026#34;Person \u0026#34; , mxDebit , \u0026#34; pays \u0026#34; , min , \u0026#34; to \u0026#34; , \u0026#34;Person \u0026#34; , mxCredit) # Recur for the amount array. Note that it is guaranteed that the recursion would terminate as either amount[mxCredit] or amount[mxDebit] becomes 0 minCashFlowRec(amount) # Given a set of persons as graph[] where graph[i][j] indicates the amount that person i needs to pay person j, this function finds and prints the minimum cash flow to settle all debts. def minCashFlow(graph): # Create an array amount[], initialize all value in it as 0. amount = [0 for _ in range(N)] # Calculate the net amount to be paid to person \u0026#39;p\u0026#39;, and stores it in amount[p]. The value of amount[p] can be calculated by subtracting debts of \u0026#39;p\u0026#39; from credits of \u0026#39;p\u0026#39; for p in range(N): for i in range(N): amount[p] += (graph[i][p] - graph[p][i]) minCashFlowRec(amount) # graph[i][j] indicates the amount that person i needs to pay person j graph = [ [0, 1000, 2000], [0, 0, 5000], [0, 0, 0] ] minCashFlow(graph) Two Clique Problem \u0026#34;\u0026#34;\u0026#34; A Clique is a subgraph of graph such that all vertices in subgraph are completely connected with each other. Given a Graph, find if it can be divided into two Cliques. Examples: Input : G[][] = {{0, 1, 1, 0, 0}, {1, 0, 1, 1, 0}, {1, 1, 0, 0, 0}, {0, 1, 0, 0, 1}, {0, 0, 0, 1, 0}}; Output : Yes \u0026#34;\u0026#34;\u0026#34; from queue import Queue # This function returns true if subgraph reachable from src is Bipartite or not. def isBipartiteUtil(G, src, colorArr): global V colorArr[src] = 1 # Create a queue (FIFO) of vertex numbers and enqueue source vertex for BFS traversal q = Queue() q.put(src) # Run while there are vertices in queue (Similar to BFS) while (not q.empty()): # Dequeue a vertex from queue u = q.get() # Find all non-colored adjacent vertices for v in range(V): # An edge from u to v exists and destination v is not colored if (G[u][v] and colorArr[v] == -1): # Assign alternate color to this adjacent v of u colorArr[v] = 1 - colorArr[u] q.put(v) # An edge from u to v exists and destination v is colored with same color as u elif (G[u][v] and colorArr[v] == colorArr[u]): return False # If we reach here, then all adjacent vertices can be colored with alternate color return True # Returns true if a Graph G[][] is Bipartite or Note that G may not be connected. def isBipartite(G): global V # Create a color array to store colors assigned to all vertices. Vertex number is used as index in this array. The value \u0026#39;-1\u0026#39; of colorArr[i] is used to indicate that no color is assigned to vertex \u0026#39;i\u0026#39;. The value 1 is used to indicate first color is assigned and value 0 indicates second color is assigned. colorArr = [-1] * V # One by one check all not yet colored vertices. for i in range(V): if (colorArr[i] == -1): if (isBipartiteUtil(G, i, colorArr) == False): return False return True # Returns true if G can be divided into # two Cliques, else false. def canBeDividedinTwoCliques(G): global V # Find complement of G[][] All values are complemented except diagonal ones GC = [[None] * V for _ in range(V)] for i in range(V): for j in range(V): GC[i][j] = not G[i][j] if i != j else 0 # Return true if complement is Bipartite else false. return isBipartite(GC) V = 5 G = [[0, 1, 1, 1, 0], [1, 0, 1, 0, 0], [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 0]] if canBeDividedinTwoCliques(G): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/graph/","summary":"Implement Graph Implement Weighted Graph Implement BFS algorithm Implement DFS Algo Detect Cycle in Directed Graph using BFS/DFS Algo Detect Cycle in UnDirected Graph using BFS/DFS Algo Minimum Step by Knight flood fill algo Clone a graph Making wired Connections word Ladder Dijkstra algo Implement Topological Sort Minimum time taken by each job to be completed given by a Directed Acyclic Graph Find whether it is possible to finish all tasks or not from given dependencies Find the no.","title":"DSA in Python - Graph"},{"content":" Activity Selection Problem Huffman Coding Water Connection Problem Fractional Knapsack Problem Greedy Algorithm to find Minimum number of Coins Maximum trains for which stoppage can be provided Minimum Platforms Problem Buy Maximum Stocks if i stocks can be bought on i-th day Find the minimum and maximum amount to buy all N candies Minimum Cost to cut a board into squares Check if it is possible to survive on Island Maximum product subset of an array Maximize array sum after K negations Maximize the sum of arr[i]*i Maximum sum of absolute difference of an array Maximize sum of consecutive differences in a circular array Minimum sum of absolute difference of pairs of two arrays Program for Shortest Job First (or SJF) CPU Scheduling Program for Least Recently Used (LRU) Page Replacement algorithm Smallest subset with sum greater than all other elements Chocolate Distribution Problem DEFKIN -Defense of a Kingdom DIEHARD -DIE HARD GERGOVIA -Wine trading in Gergovia Picking Up Chicks CHOCOLA –Chocolate ARRANGE -Arranging Amplifiers K Centers Problem Minimum Cost of ropes Find smallest number with given number of digits and sum of digits Rearrange characters in a string such that no two adjacent are same Find maximum sum possible equal sum of three stacks Activity Selection Problem \u0026#34;\u0026#34;\u0026#34; There is one meeting room in a firm. There are N meetings in the form of (start[i], end[i]) where start[i] is start time of meeting i and end[i] is finish time of meeting i. What is the maximum number of meetings that can be accommodated in the meeting room when only one meeting can be held in the meeting room at a particular time? Note: Start time of one chosen meeting can\u0026#39;t be equal to the end time of the other chosen meeting. Example 1: Input: N = 6 start[] = {1,3,0,5,8,5} end[] = {2,4,6,7,9,9} Output: 4 Explanation: Maximum four meetings can be held with given start and end timings. The meetings are - (1, 2),(3, 4), (5,7) and (8,9) \u0026#34;\u0026#34;\u0026#34; class meeting: def __init__(self, start, end, pos): self.start = start self.end = end self.pos = pos def maxMeeting(l, n): # Sorting of meeting according to heir finish time. l.sort(key = lambda x: x.end) ans = [l[0].pos] # time_limit to check whether new meeting can be conducted or not. time_limit = l[0].end # Check for all meeting whether it can be selected or not. for i in range(1, n): if l[i].start \u0026gt; time_limit: ans.append(l[i].pos) time_limit = l[i].end # Print final selected meetings for i in ans: print(i + 1, end = \u0026#34;\u0026#34;) print() s = [ 1, 3, 0, 5, 8, 5 ]\t# Starting time f = [ 2, 4, 6, 7, 9, 9 ]\t# Finish time n = len(s) l = [meeting(s[i], f[i], i) for i in range(n)] maxMeeting(l, n) Huffman Coding # A Huffman Tree Node class node: def __init__(self, freq, symbol, left=None, right=None): # frequency of symbol self.freq = freq # symbol name (character) self.symbol = symbol # node left of current node self.left = left # node right of current node self.right = right # tree direction (0/1) self.huff = \u0026#39;\u0026#39; def printNodes(node, val=\u0026#39;\u0026#39;): # huffman code for current node newVal = val + str(node.huff) # if node is not an edge node then traverse inside it if(node.left): printNodes(node.left, newVal) if(node.right): printNodes(node.right, newVal) # if node is edge node then display its huffman code if(not node.left and not node.right): print(f\u0026#34;{node.symbol} -\u0026gt; {newVal}\u0026#34;) # characters for huffman tree chars = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] # frequency of characters freq = [ 5, 9, 12, 13, 16, 45] # list containing unused nodes nodes = [node(freq[x], chars[x]) for x in range(len(chars))] while len(nodes) \u0026gt; 1: # sort all the nodes in ascending order based on theri frequency nodes = sorted(nodes, key=lambda x: x.freq) # pick 2 smallest nodes left = nodes[0] right = nodes[1] # assign directional value to these nodes left.huff = 0 right.huff = 1 # combine the 2 smallest nodes to create new node as their parent newNode = node(left.freq+right.freq, left.symbol+right.symbol, left, right) # remove the 2 nodes and add their parent as new node among others nodes.remove(left) nodes.remove(right) nodes.append(newNode) # Huffman Tree is ready! printNodes(nodes[0]) Water Connection Problem \u0026#34;\u0026#34;\u0026#34;Every house in the colony has at most one pipe going into it and at most one pipe going out of it. Tanks and taps are to be installed in a manner such that every house with one outgoing pipe but no incoming pipe gets a tank installed on its roof and every house with only an incoming pipe and no outgoing pipe gets a tap. Given two integers n and p denoting the number of houses and the number of pipes. The connections of pipe among the houses contain three input values: a_i, b_i, d_i denoting the pipe of diameter d_i from house a_i to house b_i, find out the efficient solution for the network. The output will contain the number of pairs of tanks and taps t installed in first line and the next t lines contain three integers: house number of tank, house number of tap and the minimum diameter of pipe between them. Examples: Input: 4 2 1 2 60 3 4 50 Output: 2 1 2 60 3 4 50 Explanation: Connected components are: 1-\u0026gt;2 and 3-\u0026gt;4 Therefore, our answer is 2 followed by 1 2 60 and 3 4 50. Input: 9 6 7 4 98 5 9 72 4 6 10 2 8 22 9 7 17 3 1 66 Output: 3 2 8 22 3 1 66 5 6 10 Explanation: Connected components are 3-\u0026gt;1, 5-\u0026gt;9-\u0026gt;7-\u0026gt;4-\u0026gt;6 and 2-\u0026gt;8. Therefore, our answer is 3 followed by 2 8 22, 3 1 66, 5 6 10 \u0026#34;\u0026#34;\u0026#34; # number of houses and number of pipes n = 0 p = 0 # Array rd stores the ending vertex of pipe rd = [0]*1100 # Array wd stores the value of diameters between two pipes wt = [0]*1100 # Array cd stores the starting end of pipe cd = [0]*1100 # List a, b, c are used to store the final output a = [] b = [] c = [] ans = 0 def dfs(w): global ans if (cd[w] == 0): return w if (wt[w] \u0026lt; ans): ans = wt[w] return dfs(cd[w]) # Function performing calculations. def solve(arr): global ans i = 0 while (i \u0026lt; p): q = arr[i][0] h = arr[i][1] t = arr[i][2] cd[q] = h wt[q] = t rd[h] = q i += 1 a = [] b = [] c = [] # If a pipe has no ending vertex but has starting vertex i.e is an outgoing pipe then we need to start DFS with this vertex. for j in range(1, n + 1): if (rd[j] == 0 and cd[j]): ans = 1000000000 w = dfs(j) # We put the details of component in final output array a.append(j) b.append(w) c.append(ans) print(len(a)) for j in range(len(a)): print(a[j], b[j], c[j]) n = 9 # number of houses p = 6 # number of pipes arr = [[7, 4, 98], [5, 9, 72], [4, 6, 10 ], [2, 8, 22 ], [9, 7, 17], [3, 1, 66]] solve(arr) Fractional Knapsack Problem TODO Greedy Algorithm to find Minimum number of Coins \u0026#34;\u0026#34;\u0026#34; Given the weights and values of n items, we need to put these items in a knapsack of capacity W to get the maximum total value in the knapsack. In Fractional Knapsack, we can break items for maximizing the total value of knapsack. This problem in which we can break an item is also called the fractional knapsack problem. Input: Items as (value, weight) pairs arr[] = {{60, 10}, {100, 20}, {120, 30}} Knapsack Capacity, W = 50; Output: Maximum possible value = 240 by taking items of weight 10 and 20 kg and 2/3 fraction of 30 kg. Hence total price will be 60+100+(2/3)(120) = 240 \u0026#34;\u0026#34;\u0026#34; class ItemValue: \u0026#34;\u0026#34;\u0026#34;Item Value DataClass\u0026#34;\u0026#34;\u0026#34; def __init__(self, wt, val, ind): self.wt = wt self.val = val self.ind = ind self.cost = val // wt def __lt__(self, other): return self.cost \u0026lt; other.cost def getMaxValue(wt, val, capacity): \u0026#34;\u0026#34;\u0026#34;function to get maximum value \u0026#34;\u0026#34;\u0026#34; iVal = [ItemValue(wt[i], val[i], i) for i in range(len(wt))] # sorting items by value iVal.sort(reverse=True) totalValue = 0 for i in iVal: curWt = int(i.wt) curVal = int(i.val) if capacity - curWt \u0026gt;= 0: capacity -= curWt totalValue += curVal else: fraction = capacity / curWt totalValue += curVal * fraction capacity = int(capacity - (curWt * fraction)) break return totalValue wt = [10, 40, 20, 30] val = [60, 40, 100, 120] capacity = 50 maxValue = getMaxValue(wt, val, capacity) print(\u0026#34;Maximum value in Knapsack =\u0026#34;, maxValue) Maximum trains for which stoppage can be provided TODO Minimum Platforms Problem \u0026#34;\u0026#34;\u0026#34; Given the arrival and departure times of all trains that reach a railway station, the task is to find the minimum number of platforms required for the railway station so that no train waits. We are given two arrays that represent the arrival and departure times of trains that stop. Examples: Input: arr[] = {9:00, 9:40, 9:50, 11:00, 15:00, 18:00} dep[] = {9:10, 12:00, 11:20, 11:30, 19:00, 20:00} Output: 3 Explanation: There are at-most three trains at a time (time between 9:40 to 12:00) Input: arr[] = {9:00, 9:40} dep[] = {9:10, 12:00} Output: 1 Explanation: Only one platform is needed. \u0026#34;\u0026#34;\u0026#34; def findPlatform(arr, dep, n): # Sort arrival and departure arrays arr.sort() dep.sort() # plat_needed indicates number of platforms needed at a time plat_needed = 1 result = 1 i = 1 j = 0 # Similar to merge in merge sort to process all events in sorted order while (i \u0026lt; n and j \u0026lt; n): # If next event in sorted order is arrival, increment count of platforms needed if (arr[i] \u0026lt;= dep[j]): plat_needed += 1 i += 1 else: plat_needed -= 1 j += 1 # Update result if needed if (plat_needed \u0026gt; result): result = plat_needed return result arr = [900, 940, 950, 1100, 1500, 1800] dep = [910, 1200, 1120, 1130, 1900, 2000] n = len(arr) print(\u0026#34;Minimum Number of Platforms Required = \u0026#34;, findPlatform(arr, dep, n)) Buy Maximum Stocks if i stocks can be bought on i-th day \u0026#34;\u0026#34;\u0026#34; In a stock market, there is a product with its infinite stocks. The stock prices are given for N days, where arr[i] denotes the price of the stock on the ith day. There is a rule that a customer can buy at most i stock on the ith day. If the customer has an amount of k amount of money initially, find out the maximum number of stocks a customer can buy. For example, for 3 days the price of a stock is given as 7, 10, 4. You can buy 1 stock worth 7 rs on day 1, 2 stocks worth 10 rs each on day 2 and 3 stock worth 4 rs each on day 3. Examples: Input : price[] = { 10, 7, 19 }, k = 45. Output : 4 A customer purchases 1 stock on day 1, 2 stocks on day 2 and 1 stock on day 3 for 10, 7 * 2 = 14 and 19 respectively. Hence, total amount is 10 + 14 + 19 = 43 and number of stocks purchased is 4. Input : price[] = { 7, 10, 4 }, k = 100. Output : 6 \u0026#34;\u0026#34;\u0026#34; def buyMaximumProducts(n, k, price): # Making pair of stock cost and day number arr = [[i + 1, price[i]] for i in range(n)] # Sort based on the price of stock arr.sort(key = lambda x: x[1]) # Calculating the max stocks purchased total_purchase = 0 for i in range(n): P = min(arr[i][0], k//arr[i][1]) total_purchase += P k -= (P * arr[i][1]) return total_purchase price = [ 10, 7, 19 ] n = len(price) k = 45 print(buyMaximumProducts(n, k, price)) Find the minimum and maximum amount to buy all N candies \u0026#34;\u0026#34;\u0026#34; In a candy store, there are N different types of candies available and the prices of all the N different types of candies are provided. There is also an attractive offer by the candy store. We can buy a single candy from the store and get at most K other candies (all are different types) for free. Find the minimum amount of money we have to spend to buy all the N different candies. Find the maximum amount of money we have to spend to buy all the N different candies. In both cases, we must utilize the offer and get the maximum possible candies back. If k or more candies are available, we must take k candies for every candy purchase. If less than k candies are available, we must take all candies for a candy purchase. Examples: Input : price[] = {3, 2, 1, 4} k = 2 Output : Min = 3, Max = 7 Explanation : Since k is 2, if we buy one candy we can take atmost two more for free. So in the first case we buy the candy which costs 1 and take candies worth 3 and 4 for free, also you buy candy worth 2 as well. So min cost = 1 + 2 = 3. In the second case we buy the candy which costs 4 and take candies worth 1 and 2 for free, also We buy candy worth 3 as well. So max cost = 3 + 4 = 7. One important thing to note is, we must use the offer and get maximum candies back for every candy purchase. So if we want to minimize the money, we must buy candies at minimum cost and get candies of maximum costs for free \u0026#34;\u0026#34;\u0026#34; from math import ceil # function to find the maximum and the minimum cost required def find(arr,n,k): # Sort the array arr.sort() b = int(ceil(n/k)) # print the minimum cost print(\u0026#34;minimum \u0026#34;,sum(arr[:b])) # print the maximum cost print(\u0026#34;maximum \u0026#34;, sum(arr[-b:])) arr = [3, 2, 1, 4] n = len(arr) k = 2 find(arr,n,k) Minimum Cost to cut a board into squares \u0026#34;\u0026#34;\u0026#34; A board of length m and width n is given, we need to break this board into m*n squares such that cost of breaking is minimum. cutting cost for each edge will be given for the board. In short, we need to choose such a sequence of cutting such that cost is minimized. https://media.geeksforgeeks.org/wp-content/cdn-uploads/board.png For above board optimal way to cut into square is: Total minimum cost in above case is 42. It is evaluated using following steps. Initial Value : Total_cost = 0 Total_cost = Total_cost + edge_cost * total_pieces Cost 4 Horizontal cut Cost = 0 + 4*1 = 4 Cost 4 Vertical cut Cost = 4 + 4*2 = 12 Cost 3 Vertical cut Cost = 12 + 3*2 = 18 Cost 2 Horizontal cut Cost = 18 + 2*3 = 24 Cost 2 Vertical cut Cost = 24 + 2*3 = 30 Cost 1 Horizontal cut Cost = 30 + 1*4 = 34 Cost 1 Vertical cut Cost = 34 + 1*4 = 38 Cost 1 Vertical cut Cost = 38 + 1*4 = 42 \u0026#34;\u0026#34;\u0026#34; def minimumCostOfBreaking(X, Y, m, n): res = 0 # sort the horizontal cost in reverse order X.sort(reverse = True) # sort the vertical cost in reverse order Y.sort(reverse = True) # initialize current width as 1 hzntl = 1; vert = 1 # loop until one or both cost array are processed i = 0; j = 0 while (i \u0026lt; m and j \u0026lt; n): if (X[i] \u0026gt; Y[j]): res += X[i] * vert # increase current horizontal part count by 1 hzntl += 1 i += 1 else: res += Y[j] * hzntl # increase current vertical part count by 1 vert += 1 j += 1 # loop for horizontal array, if remains total = 0 while (i \u0026lt; m): total += X[i] i += 1 res += total * vert #loop for vertical array, if remains total = 0 while (j \u0026lt; n): total += Y[j] j += 1 res += total * hzntl return res m = 6; n = 4 X = [2, 1, 3, 1, 4] Y = [4, 1, 2] print(minimumCostOfBreaking(X, Y, m-1, n-1)) Check if it is possible to survive on Island \u0026#34;\u0026#34;\u0026#34; You are a poor person in an island. There is only one shop in this island, this shop is open on all days of the week except for Sunday. Consider following constraints: N – Maximum unit of food you can buy each day. S – Number of days you are required to survive. M – Unit of food required each day to survive. Currently, it’s Monday, and you need to survive for the next S days. Find the minimum number of days on which you need to buy food from the shop so that you can survive the next S days, or determine that it isn’t possible to survive. Examples: Input : S = 10 N = 16 M = 2 Output : Yes 2 Explanation 1: One possible solution is to buy a box on the first day (Monday), it’s sufficient to eat from this box up to 8th day (Monday) inclusive. Now, on the 9th day (Tuesday), you buy another box and use the chocolates in it to survive the 9th and 10th day. Input : 10 20 30 Output : No Explanation 2: You can’t survive even if you buy food because the maximum number of units you can buy in one day is less the required food for one day. \u0026#34;\u0026#34;\u0026#34; def survival(S, N, M): # If we can not buy at least a week supply of food during the first week OR We can not buy a day supply of food on the first day then we can\u0026#39;t survive. if (((N * 6) \u0026lt; (M * 7) and S \u0026gt; 6) or M \u0026gt; N): print(\u0026#34;No\u0026#34;) else: # If we can survive then we can buy ceil(A / N) times where A is total units of food required. days = (M * S) / N if (((M * S) % N) != 0): days += 1 print(\u0026#34;Yes \u0026#34;), print(days) S = 10; N = 16; M = 2 survival(S, N, M) Maximum product subset of an array \u0026#34;\u0026#34;\u0026#34; Given an array a, we have to find maximum product possible with the subset of elements present in the array. The maximum product can be single element also. Examples: Input: a[] = { -1, -1, -2, 4, 3 } Output: 24 Explanation : Maximum product will be ( -2 * -1 * 4 * 3 ) = 24 Input: a[] = { -1, 0 } Output: 0 Explanation: 0(single element) is maximum product possible Input: a[] = { 0, 0, 0 } Output: 0 \u0026#34;\u0026#34;\u0026#34; def maxProductSubset(a, n): if n == 1: return a[0] # Find count of negative numbers, count of zeros, negative number with least absolute value and product of non-zero numbers max_neg = -999999999999 count_neg = 0 count_zero = 0 prod = 1 for i in range(n): # If number is 0, we don\u0026#39;t multiply it with product. if a[i] == 0: count_zero += 1 continue # Count negatives and keep track of negative number with least absolute value. if a[i] \u0026lt; 0: count_neg += 1 max_neg = max(max_neg, a[i]) prod = prod * a[i] # If there are all zeros if count_zero == n: return 0 # If there are odd number of negative numbers if count_neg \u0026amp; 1: # Exceptional case: There is only negative and all other are zeros if (count_neg == 1 and count_zero \u0026gt; 0 and count_zero + count_neg == n): return 0 # Otherwise result is product of all non-zeros divided by negative number with least absolute value prod = int(prod / max_neg) return prod a = [ -1, -1, -2, 4, 3 ] n = len(a) print(maxProductSubset(a, n)) Maximize array sum after K negations \u0026#34;\u0026#34;\u0026#34; Given an array of size n and a number k. We must modify array K a number of times. Here modify array means in each operation we can replace any array element arr[i] by -arr[i]. We need to perform this operation in such a way that after K operations, the sum of the array must be maximum? Examples : Input : arr[] = {-2, 0, 5, -1, 2}, K = 4 Output: 10 Explanation: 1. Replace (-2) by -(-2), array becomes {2, 0, 5, -1, 2} 2. Replace (-1) by -(-1), array becomes {2, 0, 5, 1, 2} 3. Replace (0) by -(0), array becomes {2, 0, 5, 1, 2} 4. Replace (0) by -(0), array becomes {2, 0, 5, 1, 2} Input : arr[] = {9, 8, 8, 5}, K = 3 Output: 20 \u0026#34;\u0026#34;\u0026#34; def sol(arr, k): # Sorting given array using in-built java sort function arr.sort() i = 0 while (k \u0026gt; 0): # If we find a 0 in our sorted array, we stop if (arr[i] \u0026gt;= 0): k = 0 else: arr[i] = (-1) * arr[i] k = k - 1 i += 1 return sum(arr[j] for j in range(len(arr))) arr = [-2, 0, 5, -1, 2] print(sol(arr, 4)) Maximize the sum of arr[i]*i \u0026#34;\u0026#34;\u0026#34; Given an array of N integers. You are allowed to rearrange the elements of the array. The task is to find the maximum value of Σarr[i]*i, where i = 0, 1, 2,…., n – 1. Examples: Input : N = 4, arr[] = { 3, 5, 6, 1 } Output : 31 If we arrange arr[] as { 1, 3, 5, 6 }. Sum of arr[i]*i is 1*0 + 3*1 + 5*2 + 6*3 = 31, which is maximum Input : N = 2, arr[] = { 19, 20 } Output : 20 \u0026#34;\u0026#34;\u0026#34; def maxSum(arr,n): arr.sort() return sum(arr[i] * i for i in range(n)) arr = [3,5,6,1] n = len(arr) print(maxSum(arr,n)) Maximum sum of absolute difference of an array \u0026#34;\u0026#34;\u0026#34; Given an array, we need to find the maximum sum of absolute difference of any permutation of the given array. Examples: Input : { 1, 2, 4, 8 } Output : 18 Explanation : For the given array there are several sequence possible like : {2, 1, 4, 8} {4, 2, 1, 8} and some more. Now, the absolute difference of an array sequence will be like for this array sequence {1, 2, 4, 8}, the absolute difference sum is = |1-2| + |2-4| + |4-8| + |8-1| = 14 For the given array, we get the maximum value for the sequence {1, 8, 2, 4} = |1-8| + |8-2| + |2-4| + |4-1| = 18 \u0026#34;\u0026#34;\u0026#34; import numpy as np def MaxSumDifference(a,n): # sort the original array so that we can retrieve the large elements from the end of array elements np.sort(a); # In this loop first we will insert one smallest element not entered till that time in final sequence and then enter a highest element(not entered till that time) in final sequence so that we have large difference value. This process is repeated till all array has completely entered in sequence. Here, we have loop till n/2 because we are inserting two elements at a time in loop. j = 0 finalSequence = [0 for _ in range(n)] for i in range(int(n / 2)): finalSequence[j] = a[i] finalSequence[j + 1] = a[n - i - 1] j = j + 2 # If there are odd elements, push the middle element at the end. if (n % 2 != 0): finalSequence[n-1] = a[n//2 + 1] # variable to store the maximum sum of absolute difference MaximumSum = 0 # In this loop absolute difference of elements for the final sequence is calculated. for i in range(n - 1): MaximumSum = (MaximumSum + abs(finalSequence[i] - finalSequence[i + 1])) # absolute difference of last element and 1st element MaximumSum = (MaximumSum + abs(finalSequence[n - 1] - finalSequence[0])); print (MaximumSum) a = [ 1, 2, 4, 8 ] n = len(a) MaxSumDifference(a, n); Maximize sum of consecutive differences in a circular array \u0026#34;\u0026#34;\u0026#34; Given an array of n elements. Consider array as circular array i.e element after an is a1. The task is to find maximum mysum of the difference between consecutive elements with rearrangement of array element allowed i.e after rearrangement of element find |a1 – a2| + |a2 – a3| + …… + |an – 1 – an| + |an – a1|. Examples: Input : arr[] = { 4, 2, 1, 8 } Output : 18 Rearrange given array as : { 1, 8, 2, 4 } mysum of difference between consecutive element = |1 - 8| + |8 - 2| + |2 - 4| + |4 - 1| = 7 + 6 + 2 + 3 = 18. Input : arr[] = { 10, 12, 15 } Output : 10 \u0026#34;\u0026#34;\u0026#34; def maxSum(arr, n): mysum = 0 arr.sort() # Subtracting a1, a2, a3,....., a(n/2)-1, an/2 twice and adding a(n/2)+1, a(n/2)+2, a(n/2)+3,. ...., an - 1, an twice. for i in range(int(n / 2)): mysum -= (2 * arr[i]) mysum += (2 * arr[n - i - 1]) return mysum arr = [4, 2, 1, 8] n = len(arr) print (maxSum(arr, n)) Minimum sum of absolute difference of pairs of two arrays \u0026#34;\u0026#34;\u0026#34; Given two arrays a[] and b[] of equal length n. The task is to pair each element of array a to an element in array b, such that mysum S of absolute differences of all the pairs is minimum. Suppose, two elements a[i] and a[j] (i != j) of a are paired with elements b[p] and b[q] of b respectively, then p should not be equal to q. Examples: Input : a[] = {3, 2, 1} b[] = {2, 1, 3} Output : 0 Explanation : 1st pairing: |3 - 2| + |2 - 1| + |1 - 3| = 1 + 1 + 2 = 4 2nd pairing: |3 - 2| + |1 - 1| + |2 - 3| = 1 + 0 + 1 = 2 3rd pairing: |2 - 2| + |3 - 1| + |1 - 3| = 0 + 2 + 2 = 4 4th pairing: |1 - 2| + |2 - 1| + |3 - 3| = 1 + 1 + 0 = 2 5th pairing: |2 - 2| + |1 - 1| + |3 - 3| = 0 + 0 + 0 = 0 6th pairing: |1 - 2| + |3 - 1| + |2 - 3| = 1 + 2 + 1 = 4 Therefore, 5th pairing has minimum mysum of absolute difference. Input : n = 4 a[] = {4, 1, 8, 7} b[] = {2, 3, 6, 5} Output : 6 \u0026#34;\u0026#34;\u0026#34; def findMinSum(a, b, n): # Sort both arrays a.sort() b.sort() # Find mysum of absolute differences mysum = 0 for i in range(n): mysum = mysum + abs(a[i] - b[i]) return mysum # Both a[] and b[] must be of same size. a = [4, 1, 8, 7] b = [2, 3, 6, 5] n = len(a) print(findMinSum(a, b, n)) Program for Shortest Job First (or SJF) CPU Scheduling TODO Program for Least Recently Used (LRU) Page Replacement algorithm TODO Smallest subset with sum greater than all other elements \u0026#34;\u0026#34;\u0026#34; Given an array of non-negative integers. Our task is to find minimum number of elements such that their sum should be greater than the sum of rest of the elements of the array. Examples : Input : arr[] = {3, 1, 7, 1} Output : 1 Smallest subset is {7}. Sum of this subset is greater than all other elements {3, 1, 1} \u0026#34;\u0026#34;\u0026#34; def minElements(arr , n): # calculating HALF of array sum halfSum = 0 for i in range(n): halfSum = halfSum + arr[i] halfSum = int(halfSum / 2) # sort the array in descending order. arr.sort(reverse = True) res = 0 curr_sum = 0 for i in range(n): curr_sum += arr[i] res += 1 # current sum greater than sum if curr_sum \u0026gt; halfSum: return res return res arr = [3, 1, 7, 1] n = len(arr) print(minElements(arr, n) ) Chocolate Distribution Problem \u0026#34;\u0026#34;\u0026#34; Given an array of n integers where each value represents the number of chocolates in a packet. Each packet can have a variable number of chocolates. There are m students, the task is to distribute chocolate packets such that: Each student gets one packet. The difference between the number of chocolates in the packet with maximum chocolates and packet with minimum chocolates given to the students is minimum. Examples: Input : arr[] = {7, 3, 2, 4, 9, 12, 56} , m = 3 Output: Minimum Difference is 2 Explanation: We have seven packets of chocolates and we need to pick three packets for 3 students If we pick 2, 3 and 4, we get the minimum difference between maximum and minimum packet sizes. \u0026#34;\u0026#34;\u0026#34; # arr[0..n-1] represents sizes of packets m is number of students. Returns minimum difference between maximum and minimum values of distribution. def findMinDiff(arr, n, m): # if there are no chocolates or number of students is 0 if (m==0 or n==0): return 0 # Sort the given packets arr.sort() # Number of students cannot be more than number of packets if (n \u0026lt; m): return -1 # Largest number of chocolates min_diff = arr[n-1] - arr[0] # Find the subarray of size m such that difference between last (maximum in case of sorted) and first (minimum in case of sorted) elements of subarray is minimum. for i in range(len(arr) - m + 1): min_diff = min(min_diff , arr[i + m - 1] - arr[i]) return min_diff arr = [12, 4, 7, 9, 2, 23, 25, 41, 30, 40, 28, 42, 30, 44, 48, 43, 50] m = 7 # Number of students n = len(arr) print(\u0026#34;Minimum difference is\u0026#34;, findMinDiff(arr, n, m)) DEFKIN -Defense of a Kingdom TODO DIEHARD -DIE HARD TODO GERGOVIA -Wine trading in Gergovia TODO Picking Up Chicks TODO CHOCOLA –Chocolate TODO ARRANGE -Arranging Amplifiers TODO K Centers Problem def maxindex(dist, n): mi = 0 for i in range(n): if (dist[i] \u0026gt; dist[mi]): mi = i return mi def selectKcities(n, weights, k): dist = [0]*n centers = [] for i in range(n): dist[i] = 10**9 # index of city having the maximum distance to it\u0026#39;s closest center mymax = 0 for i in range(k): centers.append(mymax) for j in range(n): # updating the distance of the cities to their closest centers dist[j] = min(dist[j], weights[mymax][j]) # updating the index of the city with the maximum distance to it\u0026#39;s closest center mymax = maxindex(dist, n) # Printing the maximum distance of a city to a center that is our answer print() print(dist[mymax]) # Printing the cities that were chosen to be made centers for i in centers: print(i, end = \u0026#34; \u0026#34;) n = 4 weights = [ [ 0, 4, 8, 5 ], [ 4, 0, 10, 7 ], [ 8, 10, 0, 9 ], [ 5, 7, 9, 0 ] ] k = 2 selectKcities(n, weights, k) Minimum Cost of ropes \u0026#34;\u0026#34;\u0026#34;There are given n ropes of different lengths, we need to connect these ropes into one rope. The cost to connect two ropes is equal to the sum of their lengths. We need to connect the ropes with minimum cost. For example, if we are given 4 ropes of lengths 4, 3, 2, and 6. We can connect the ropes in the following ways. First, connect ropes of lengths 2 and 3. Now we have three ropes of lengths 4, 6, and 5. Now connect ropes of lengths 4 and 5. Now we have two ropes of lengths 6 and 9. Finally connect the two ropes and all ropes have connected. Total cost for connecting all ropes is 5 + 9 + 15 = 29. This is the optimized cost for connecting ropes. Other ways of connecting ropes would always have same or more cost. For example, if we connect 4 and 6 first (we get three strings of 3, 2, and 10), then connect 10 and 3 (we get two strings of 13 and 2). Finally, we connect 13 and 2. Total cost in this way is 10 + 13 + 15 = 38. \u0026#34;\u0026#34;\u0026#34; import heapq def minCost(arr, n): # Create a priority queue out of the given list heapq.heapify(arr) # Initialize result res = 0 # While size of priority queue is more than 1 while(len(arr) \u0026gt; 1): # Extract shortest two ropes from arr first = heapq.heappop(arr) second = heapq.heappop(arr) #Connect the ropes: update result and insert the new rope to arr res += first + second heapq.heappush(arr, first + second) return res lengths = [ 4, 3, 2, 6 ] size = len(lengths) print(f\u0026#34;Total cost for connecting ropes is {str(minCost(lengths, size))}\u0026#34;) Find smallest number with given number of digits and sum of digits \u0026#34;\u0026#34;\u0026#34; How to find the smallest number with given digit sum s and number of digits d? Examples : Input : s = 9, d = 2 Output : 18 There are many other possible numbers like 45, 54, 90, etc with sum of digit as 9 and number of digits as 2. The smallest of them is 18. Input : s = 20, d = 3 Output : 299 \u0026#34;\u0026#34;\u0026#34; def findSmallest(m,s): # If sum of digits is 0, then a number is possible only if number of digits is 1. if (s == 0):\tif(m == 1) : print(\u0026#34;Smallest number is 0\u0026#34;) else : print(\u0026#34;Not possible\u0026#34;) return # Sum greater than the maximum possible sum. if (s \u0026gt; 9*m): print(\u0026#34;Not possible\u0026#34;) return # Create an array to store digits of result res = [0 for _ in range(m+1)] # deduct sum by one to account for cases later (There must be 1 left for the most significant digit) s -= 1 # Fill last m-1 digits (from right to left) for i in range(m-1,0,-1): # If sum is still greater than 9, digit must be 9. if (s \u0026gt; 9): res[i] = 9 s -= 9 else: res[i] = s s = 0 # Whatever is left should be the most significant digit. The initially subtracted 1 is incorporated here. res[0] = s + 1 print(\u0026#34;Smallest number is \u0026#34;,end=\u0026#34;\u0026#34;) for i in range(m): print(res[i],end=\u0026#34;\u0026#34;) s = 9 m = 2 findSmallest(m, s) Rearrange characters in a string such that no two adjacent are same \u0026#34;\u0026#34;\u0026#34; Given a string with repeated characters, the task is to rearrange characters in a string so that no two adjacent characters are same. Note : It may be assumed that the string has only lowercase English alphabets. Examples: Input: aaabc Output: abaca Input: aaabb Output: ababa Input: aa Output: Not Possible \u0026#34;\u0026#34;\u0026#34; def getMaxCountChar(count): maxCount = 0 for i in range(26): if count[i] \u0026gt; maxCount: maxCount = count[i] maxChar = chr(i + ord(\u0026#39;a\u0026#39;)) return maxCount, maxChar # Main function for rearranging the characters def rearrangeString(S): n = len(S) # if length of string is None return False if not n: return False # create a hashmap for the alphabets count = [0] * 26 for char in S: count[ord(char) - ord(\u0026#39;a\u0026#39;)] += 1 maxCount, maxChar = getMaxCountChar(count) # if the char with maximum frequency is more than the half of the total length of the string than return False if maxCount \u0026gt; (n + 1) // 2: return False # create a list for storing the result res = [None] * n ind = 0 # place all occurrences of the char with maximum frequency in even positions while maxCount: res[ind] = maxChar ind += 2 maxCount -= 1 # replace the count of the char with maximum frequency to zero as all the maxChar are already placed in the result count[ord(maxChar) - ord(\u0026#39;a\u0026#39;)] = 0 # place all other char in the result starting from remaining even positions and then place in the odd positions for i in range(26): while count[i] \u0026gt; 0: if ind \u0026gt;= n: ind = 1 res[ind] = chr(i + ord(\u0026#39;a\u0026#39;) ) ind += 2 count[i] -= 1 # convert the result list to string and return return \u0026#39;\u0026#39;.join(res) myStr = \u0026#39;bbbaa\u0026#39; if res := rearrangeString(myStr): print(res) else: print(\u0026#39;Not valid string\u0026#39;) Find maximum sum possible equal sum of three stacks \u0026#34;\u0026#34;\u0026#34; Given three stacks of the positive numbers, the task is to find the possible equal maximum sum of the stacks with the removal of top elements allowed. Stacks are represented as an array, and the first index of the array represent the top element of the stack. Examples: Input : stack1[] = { 3, 10} stack2[] = { 4, 5 } stack3[] = { 2, 1 } Output : 0 Sum can only be equal after removing all elements from all stacks. \u0026#34;\u0026#34;\u0026#34; def maxSum(stack1, stack2, stack3, n1, n2, n3): sum1, sum2, sum3 = 0, 0, 0 # Finding the initial sum of stack1. for i in range(n1): sum1 += stack1[i] # Finding the initial sum of stack2. for i in range(n2): sum2 += stack2[i] # Finding the initial sum of stack3. for i in range(n3): sum3 += stack3[i] # As given in question, first element is top of stack.. top1, top2, top3 = 0, 0, 0 ans = 0 while True: # If any stack is empty if (top1 == n1 or top2 == n2 or top3 == n3): return 0 # If sum of all three stack are equal. if sum1 == sum2 == sum3: return sum1 # Finding the stack with maximum sum and removing its top element. if (sum1 \u0026gt;= sum2 and sum1 \u0026gt;= sum3): sum1 -= stack1[top1] top1=top1+1 elif (sum2 \u0026gt;= sum1 and sum2 \u0026gt;= sum3): sum2 -= stack2[top2] top2=top2+1 elif (sum3 \u0026gt;= sum2 and sum3 \u0026gt;= sum1): sum3 -= stack3[top3] top3=top3+1 stack1 = [ 3, 2, 1, 1, 1 ] stack2 = [ 4, 3, 2 ] stack3 = [ 1, 1, 4, 1 ] n1 = len(stack1) n2 = len(stack2) n3 = len(stack3) print (maxSum(stack1, stack2, stack3, n1, n2, n3)) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/greedy/","summary":"Activity Selection Problem Huffman Coding Water Connection Problem Fractional Knapsack Problem Greedy Algorithm to find Minimum number of Coins Maximum trains for which stoppage can be provided Minimum Platforms Problem Buy Maximum Stocks if i stocks can be bought on i-th day Find the minimum and maximum amount to buy all N candies Minimum Cost to cut a board into squares Check if it is possible to survive on Island Maximum product subset of an array Maximize array sum after K negations Maximize the sum of arr[i]*i Maximum sum of absolute difference of an array Maximize sum of consecutive differences in a circular array Minimum sum of absolute difference of pairs of two arrays Program for Shortest Job First (or SJF) CPU Scheduling Program for Least Recently Used (LRU) Page Replacement algorithm Smallest subset with sum greater than all other elements Chocolate Distribution Problem DEFKIN -Defense of a Kingdom DIEHARD -DIE HARD GERGOVIA -Wine trading in Gergovia Picking Up Chicks CHOCOLA –Chocolate ARRANGE -Arranging Amplifiers K Centers Problem Minimum Cost of ropes Find smallest number with given number of digits and sum of digits Rearrange characters in a string such that no two adjacent are same Find maximum sum possible equal sum of three stacks Activity Selection Problem \u0026#34;\u0026#34;\u0026#34; There is one meeting room in a firm.","title":"DSA in Python - Greedy"},{"content":" Implement a Maxheap/MinHeap using arrays and recursion. (Heapify) Sort an Array using heap. (HeapSort) Maximum of all subarrays of size k. “k” largest element in an array Kth smallest and largest element in an unsorted array Merge “K” sorted arrays. Merge 2 Binary Max Heaps Kth largest sum continuous subarrays Merge “K” Sorted Linked Lists Smallest range in “K” Lists Median in a stream of Integers Check if a Binary Tree is Heap Convert BST to Min Heap Convert min heap to max heap Minimum sum of two numbers formed from digits of an array Implement a Maxheap/MinHeap using arrays and recursion. (Heapify) def heapify(arr, n, i): largest = i # Initialize largest as root l = 2 * i + 1 # left = 2*i + 1 r = 2 * i + 2 # right = 2*i + 2 # If left child is larger than root if l \u0026lt; n and arr[l] \u0026gt; arr[largest]: largest = l # If right child is larger than largest so far if r \u0026lt; n and arr[r] \u0026gt; arr[largest]: largest = r # If largest is not root if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # Recursively heapify the affected sub-tree heapify(arr, n, largest) def buildHeap(arr, n): # Index of last non-leaf node startIdx = n // 2 - 1 # Perform reverse level order traversal from last non-leaf node and heapify each node for i in range(startIdx, -1, -1): heapify(arr, n, i) def printHeap(arr, n): print(\u0026#34;Array representation of Heap is:\u0026#34;) for i in range(n): print(arr[i], end=\u0026#34; \u0026#34;) print() # Binary Tree Representation of input array #\t1 #\t/ \\ #\t3\t5 #\t/ \\\t/ \\ #\t4\t6 13 10 # / \\ / \\ # 9 8 15 17 arr = [1, 3, 5, 4, 6, 13, 10, 9, 8, 15, 17] n = len(arr) buildHeap(arr, n) printHeap(arr, n) # Final Heap: #\t17 #\t/ \\ #\t15\t13 #\t/ \\\t/ \\ #\t9 6 5 10 #/ \\ / \\ #4 8 3 1 Sort an Array using heap. (HeapSort) def heapify(arr, n, i): largest = i\t# Initialize largest as root l = 2 * i + 1\t# left = 2*i + 1 r = 2 * i + 2\t# right = 2*i + 2 # See if left child of root exists and is greater than root if l \u0026lt; n and arr[largest] \u0026lt; arr[l]: largest = l # See if right child of root exists and is greater than root if r \u0026lt; n and arr[largest] \u0026lt; arr[r]: largest = r # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) def heapSort(arr): n = len(arr) # Build a maxheap. for i in range(n//2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) arr = [12, 11, 13, 5, 6, 7] heapSort(arr) n = len(arr) print(\u0026#34;Sorted array is\u0026#34;) for i in range(n): print(\u0026#34;%d\u0026#34; % arr[i],end=\u0026#34; \u0026#34;) Maximum of all subarrays of size k. \u0026#34;\u0026#34;\u0026#34; Given an array and an integer K, find the maximum for each and every contiguous subarray of size k. Examples : Input: arr[] = {1, 2, 3, 1, 4, 5, 2, 3, 6}, K = 3 Output: 3 3 4 5 5 5 6 Explanation: Maximum of 1, 2, 3 is 3 Maximum of 2, 3, 1 is 3 Maximum of 3, 1, 4 is 4 Maximum of 1, 4, 5 is 5 Maximum of 4, 5, 2 is 5 Maximum of 5, 2, 3 is 5 Maximum of 2, 3, 6 is 6 Input: arr[] = {8, 5, 10, 7, 9, 4, 15, 12, 90, 13}, K = 4 Output: 10 10 10 15 15 90 90 Explanation: Maximum of first 4 elements is 10, similarly for next 4 elements (i.e from index 1 to 4) is 10, So the sequence generated is 10 10 10 15 15 90 90 \u0026#34;\u0026#34;\u0026#34; # Python program to find the maximum for # each and every contiguous subarray of # size k from collections import deque # A Deque (Double ended queue) based # method for printing maximum element # of all subarrays of size k def printMax(arr, n, k): \u0026#34;\u0026#34;\u0026#34; Create a Double Ended Queue, Qi that will store indexes of array elements. The queue will store indexes of useful elements in every window and it will maintain decreasing order of values from front to rear in Qi, i.e., arr[Qi.front[]] to arr[Qi.rear()] are sorted in decreasing order\u0026#34;\u0026#34;\u0026#34; Qi = deque() # Process first k (or first window) elements of array for i in range(k): # For every element, the previous smaller elements are useless so remove them from Qi while Qi and arr[i] \u0026gt;= arr[Qi[-1]] : Qi.pop() # Add new element at rear of queue Qi.append(i); # Process rest of the elements, i.e. from arr[k] to arr[n-1] for i in range(k, n): # The element at the front of the queue is the largest element of previous window, so print it print(str(arr[Qi[0]]) + \u0026#34; \u0026#34;) # Remove the elements which are out of this window while Qi and Qi[0] \u0026lt;= i-k: # remove from front of deque Qi.popleft() # Remove all elements smaller than the currently being added element (Remove useless elements) while Qi and arr[i] \u0026gt;= arr[Qi[-1]] : Qi.pop() # Add current element at the rear of Qi Qi.append(i) # Print the maximum element of last window print(str(arr[Qi[0]])) arr = [12, 1, 78, 90, 57, 89, 56] k = 3 printMax(arr, len(arr), k) “k” largest element in an array import heapq as hq def FirstKelements(arr, size, k): # Creating Min Heap for given array with only k elements Create min heap using heapq module minHeap = [arr[i] for i in range(k)] hq.heapify(minHeap) # Loop For each element in array after the kth element for i in range(k, size): if minHeap[0] \u0026gt; arr[i]: continue #deleting top element of the min heap minHeap[0] = minHeap[-1] minHeap.pop() minHeap.append(arr[i]) #maintaining heap again using O(n) time operation.... hq.heapify(minHeap) # Now min heap contains k maximum elements, Iterate and print for i in minHeap: print(i, end=\u0026#34; \u0026#34;) arr = [11, 3, 2, 1, 15, 5, 4, 45, 88, 96, 50, 45] size = len(arr) # Size of Min Heap k = 3 FirstKelements(arr, size, k) Kth smallest and largest element in an unsorted array import heapq def kthSmallest(arr, n, k): pq = [] for i in range(k): # First push first K elememts into heap heapq.heappush(pq, arr[i]) heapq._heapify_max(pq) # Now check from k to last element for i in range(k, n):\t# If current element is \u0026lt; first that means there are other k-1 lesser elements are present at bottom thus, pop that element and add kth largest element into the heap till curr at last all the greater element than kth element will get pop off and at the top of heap there will be kth smallest element if arr[i] \u0026lt; pq[0]: heapq.heappop(pq) # Push curr element heapq.heappush(pq, arr[i]) heapq._heapify_max(pq) # Return first of element return pq[0] n = 10 arr = [10, 5, 4, 3, 48, 6, 2, 33, 53, 10] k = 4 print(\u0026#34;Kth Smallest Element is:\u0026#34;, kthSmallest(arr, n, k)) Merge “K” sorted arrays. TODO Merge 2 Binary Max Heaps \u0026#34;\u0026#34;\u0026#34; Given two binary max heaps as arrays, merge the given heaps. Examples : Input : a = {10, 5, 6, 2}, b = {12, 7, 9} Output : {12, 10, 9, 2, 5, 7, 6} \u0026#34;\u0026#34;\u0026#34; def MaxHeapify(arr, n, idx): # Find largest of node and its children if idx \u0026gt;= n: return l = 2 * idx + 1 r = 2 * idx + 2 Max = 0 Max = l if l \u0026lt; n and arr[l] \u0026gt; arr[idx] else idx if r \u0026lt; n and arr[r] \u0026gt; arr[Max]: Max = r # Put Maximum value at root and recur for the child with the Maximum value if Max != idx: arr[Max], arr[idx] = arr[idx], arr[Max] MaxHeapify(arr, n, Max) # Builds a Max heap of given arr[0..n-1] def buildMaxHeap(arr, n): # building the heap from first non-leaf node by calling Max heapify function for i in range(int(n / 2) - 1, -1, -1): MaxHeapify(arr, n, i) # Merges Max heaps a[] and b[] into merged[] def mergeHeaps(merged, a, b, n, m): # Copy elements of a[] and b[] one by one to merged[] for i in range(n): merged[i] = a[i] for i in range(m): merged[n + i] = b[i] # build heap for the modified array of size n+m buildMaxHeap(merged, n + m) a = [10, 5, 6, 2] b = [12, 7, 9] n = len(a) m = len(b) merged = [0] * (m + n) mergeHeaps(merged, a, b, n, m) for i in range(n + m): print(merged[i], end = \u0026#34; \u0026#34;) Kth largest sum continuous subarrays \u0026#34;\u0026#34;\u0026#34; Given an array of integers. Write a program to find the K-th largest mySum of contiguous subarray within the array of numbers which has negative and positive numbers. Examples: Input: a[] = {20, -5, -1} k = 3 Output: 14 Explanation: All mySum of contiguous subarrays are (20, 15, 14, -5, -6, -1) so the 3rd largest mySum is 14. \u0026#34;\u0026#34;\u0026#34; import heapq def kthLargestSum(arr, n, k):\t# array to store prefix sums mySum = [0, arr[0]] mySum.extend(mySum[i - 1] + arr[i - 1] for i in range(2, n + 1)) # priority_queue of min heap Q = [] heapq.heapify(Q) # loop to calculate the contiguous subarray mySum position-wise for i in range(1, n + 1): # loop to traverse all positions that form contiguous subarray for j in range(i, n + 1): x = mySum[j] - mySum[i - 1] # if queue has less then k elements, then simply push it if len(Q) \u0026lt; k: heapq.heappush(Q, x) elif Q[0] \u0026lt; x: heapq.heappop(Q) heapq.heappush(Q, x) # the top element will be then kth largest element return Q[0] a = [10,-10,20,-40] n = len(a) k = 6 print(kthLargestSum(a,n,k)) Merge “K” Sorted Linked Lists \u0026#34;\u0026#34;\u0026#34; Given K sorted linked lists of size N each, merge them and print the sorted output. Examples: Input: k = 3, n = 4 list1 = 1-\u0026gt;3-\u0026gt;5-\u0026gt;7-\u0026gt;NULL list2 = 2-\u0026gt;4-\u0026gt;6-\u0026gt;8-\u0026gt;NULL list3 = 0-\u0026gt;9-\u0026gt;10-\u0026gt;11-\u0026gt;NULL Output: 0-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;6-\u0026gt;7-\u0026gt;8-\u0026gt;9-\u0026gt;10-\u0026gt;11 Merged lists in a sorted order where every element is greater than the previous element. \u0026#34;\u0026#34;\u0026#34; class Node:\tdef __init__(self): self.data = 0 self.next = None # Function to print nodes in a given linked list def printList(node): while (node != None): print(node.data, end = \u0026#39; \u0026#39;) node = node.next def SortedMerge(a, b): result = None if a is None: return(b) elif b is None: return(a) # Pick either a or b, and recur if (a.data \u0026lt;= b.data): result = a result.next = SortedMerge(a.next, b) else: result = b result.next = SortedMerge(a, b.next) return result def mergeKLists(arr, last): # Repeat until only one list is left while (last != 0): i = 0 j = last # (i, j) forms a pair while (i \u0026lt; j): # Merge List i with List j and store merged list in List i arr[i] = SortedMerge(arr[i], arr[j]) # Consider next pair i += 1 j -= 1 # If all pairs are merged, update last if (i \u0026gt;= j): last = j return arr[0] # Utility function to create a new node. def newNode(data): temp = Node() temp.data = data temp.next = None return temp # Number of linked lists k = 3 # Number of elements in each list n = 4 # An array of pointers storing the head nodes of the linked lists arr = [0 for _ in range(k)] arr[0] = newNode(1) arr[0].next = newNode(3) arr[0].next.next = newNode(5) arr[0].next.next.next = newNode(7) arr[1] = newNode(2) arr[1].next = newNode(4) arr[1].next.next = newNode(6) arr[1].next.next.next = newNode(8) arr[2] = newNode(0) arr[2].next = newNode(9) arr[2].next.next = newNode(10) arr[2].next.next.next = newNode(11) head = mergeKLists(arr, k - 1) printList(head) Smallest range in “K” Lists \u0026#34;\u0026#34;\u0026#34; Given k sorted lists of integers of size n each, find the smallest range that includes at least one element from each of the k lists. If more than one smallest range is found, print any one of them. Example: Input: K = 3 arr1[] : [4, 7, 9, 12, 15] arr2[] : [0, 8, 10, 14, 20] arr3[] : [6, 12, 16, 30, 50] Output: The smallest range is [6 8] Explanation: Smallest range is formed by number 7 from the first list, 8 from second list and 6 from the third list. Input: k = 3 arr1[] : [4, 7] arr2[] : [1, 2] arr3[] : [20, 40] Output: The smallest range is [2 20] \u0026#34;\u0026#34;\u0026#34; def findSmallestRange(arr, n, k): i, minval, maxval, minrange, minel, maxel, flag, minind = 0, 0, 0, 0, 0, 0, 0, 0 # initializing to 0 index for i in range(k + 1): ptr[i] = 0 minrange = float(\u0026#39;inf\u0026#39;) while True: # for maintaining the index of list containing the minimum element minind = -1 minval = 10**9 maxval = -10**9 flag = 0 # iterating over all the list for i in range(k): # if every element of list[i] is traversed then break the loop if(ptr[i] == n): flag = 1 break # find minimum value among all the list elements pointing by the ptr[] array if(ptr[i] \u0026lt; n and arr[i][ptr[i]] \u0026lt; minval): minind = i # update the index of the list minval = arr[i][ptr[i]] # find maximum value among all the list elements pointing by the ptr[] array if(ptr[i] \u0026lt; n and arr[i][ptr[i]] \u0026gt; maxval): maxval = arr[i][ptr[i]] # if any list exhaust we will not get any better answer, so break the while loop if flag: break ptr[minind] += 1 # updating the minrange if((maxval-minval) \u0026lt; minrange): minel = minval maxel = maxval minrange = maxel - minel print(\u0026#34;The smallest range is [\u0026#34;, minel, maxel, \u0026#34;]\u0026#34;) N = 5 ptr = [0 for _ in range(501)] arr = [ [4, 7, 9, 12, 15], [0, 8, 10, 14, 20], [6, 12, 16, 30, 50]] k = len(arr) findSmallestRange(arr, N, k) Median in a stream of Integers \u0026#34;\u0026#34;\u0026#34; Input: 5 10 15 Output: 5, 7.5, 10 Explanation: Given the input stream as an array of integers [5,10,15]. Read integers one by one and print the median correspondingly. So, after reading first element 5,median is 5. After reading 10,median is 7.5 After reading 15 ,median is 10. Input: 1, 2, 3, 4 Output: 1, 1.5, 2, 2.5 Explanation: Given the input stream as an array of integers [1, 2, 3, 4]. Read integers one by one and print the median correspondingly. So, after reading first element 1,median is 1. After reading 2,median is 1.5 After reading 3 ,median is 2.After reading 4 ,median is 2.5. \u0026#34;\u0026#34;\u0026#34; from heapq import * def printMedians(arr, n): # max heap to store the smaller half elements s = [] # min heap to store the greater half elements g = [] heapify(s) heapify(g) med = arr[0] heappush(s, med) print(med) # reading elements of stream one by one for i in range(1, n): x = arr[i] # case1(left side heap has more elements) if len(s) \u0026gt; len(g): if x \u0026lt; med: heappush(g, heappop(s)) heappush(s, x) else: heappush(g, x) med = (nlargest(1, s)[0] + nsmallest(1, g)[0])/2 # case2(both heaps are balanced) elif len(s) == len(g): if x \u0026lt; med: heappush(s, x) med = nlargest(1, s)[0] else: heappush(g, x) med = nsmallest(1, g)[0] # case3(right side heap has more elements) else: if x \u0026gt; med: heappush(s, heappop(g)) heappush(g, x) else: heappush(s, x) med = (nlargest(1, s)[0] + nsmallest(1, g)[0])/2 print(med) arr = [5, 15, 10, 20, 3] printMedians(arr, len(arr)) Check if a Binary Tree is Heap class GFG: def __init__(self, value): self.key = value self.left = None self.right = None def count_nodes(self, root): if root is None: return 0 else: return (1 + self.count_nodes(root.left) + self.count_nodes(root.right)) def heap_property_util(self, root): if (root.left is None and root.right is None): return True if root.right is None: return root.key \u0026gt;= root.left.key if (root.key \u0026gt;= root.left.key and root.key \u0026gt;= root.right.key): return (self.heap_property_util(root.left) and self.heap_property_util(root.right)) else: return False def complete_tree_util(self, root, index, node_count): if root is None: return True if index \u0026gt;= node_count: return False return (self.complete_tree_util(root.left, 2 * index + 1, node_count) and self.complete_tree_util(root.right, 2 * index + 2, node_count)) def check_if_heap(self): node_count = self.count_nodes(self) return bool((self.complete_tree_util(self, 0, node_count) and self.heap_property_util(self))) root = GFG(5) root.left = GFG(2) root.right = GFG(3) root.left.left = GFG(1) if root.check_if_heap(): print(\u0026#34;Given binary tree is a heap\u0026#34;) else: print(\u0026#34;Given binary tree is not a Heap\u0026#34;) Convert BST to Min Heap class Node: def __init__(self, data): self.data = data self.left = None self.right = None def inorderTraversal(root, arr): if root is None: return # first recur on left subtree inorderTraversal(root.left, arr) # then copy the data of the node arr.append(root.data) # now recur for right subtree inorderTraversal(root.right, arr) def BSTToMinHeap(root, arr, i): if root is None: return # first copy data at index \u0026#39;i\u0026#39; of \u0026#39;arr\u0026#39; to the node i[0] += 1 root.data = arr[i[0]] # then recur on left subtree BSTToMinHeap(root.left, arr, i) # now recur on right subtree BSTToMinHeap(root.right, arr, i) def convertToMinHeapUtil(root): # vector to store the data of all the nodes of the BST arr = [] i = [-1] # inorder traversal to populate \u0026#39;arr\u0026#39; inorderTraversal(root, arr) # BST to MIN HEAP conversion BSTToMinHeap(root, arr, i) def preorderTraversal(root): if root is None: return print(root.data, end=\u0026#34; \u0026#34;) preorderTraversal(root.left) preorderTraversal(root.right) root = Node(4) root.left = Node(2) root.right = Node(6) root.left.left = Node(1) root.left.right = Node(3) root.right.left = Node(5) root.right.right = Node(7) convertToMinHeapUtil(root) print(\u0026#34;Preorder Traversal:\u0026#34;) preorderTraversal(root) Convert min heap to max heap def MaxHeapify(arr, i, n): l = 2 * i + 1 r = 2 * i + 2 largest = i if l \u0026lt; n and arr[l] \u0026gt; arr[i]: largest = l if r \u0026lt; n and arr[r] \u0026gt; arr[largest]: largest = r if largest != i: arr[i], arr[largest] = arr[largest], arr[i] MaxHeapify(arr, largest, n) def convertMaxHeap(arr, n): # Start from bottommost and rightmost internal mode and heapify all internal modes in bottom up way for i in range(int((n - 2) / 2), -1, -1): MaxHeapify(arr, i, n) # array representing Min Heap arr = [3, 5, 9, 6, 8, 20, 10, 12, 18, 9] n = len(arr) print(\u0026#34;Min Heap array : \u0026#34;) print(arr) convertMaxHeap(arr, n) print(\u0026#34;Max Heap array : \u0026#34;) print(arr) Minimum sum of two numbers formed from digits of an array \u0026#34;\u0026#34;\u0026#34; Given an array of digits (values are from 0 to 9), find the minimum possible sum of two numbers formed from digits of the array. All digits of given array must be used to form the two numbers. Examples : Input: [6, 8, 4, 5, 2, 3] Output: 604 The minimum sum is formed by numbers 358 and 246 Input: [5, 3, 0, 7, 4] Output: 82 The minimum sum is formed by numbers 35 and 047 \u0026#34;\u0026#34;\u0026#34; def solve(arr, n): # sort the array arr.sort() # let two numbers be a and b a = 0; b = 0 for i in range(n): # Fill a and b with every alternate digit of input array if (i % 2 != 0): a = a * 10 + arr[i] else: b = b * 10 + arr[i] return a + b arr = [6, 8, 4, 5, 2, 3] n = len(arr) print(\u0026#34;Sum is \u0026#34;, solve(arr, n)) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/heap/","summary":"Implement a Maxheap/MinHeap using arrays and recursion. (Heapify) Sort an Array using heap. (HeapSort) Maximum of all subarrays of size k. “k” largest element in an array Kth smallest and largest element in an unsorted array Merge “K” sorted arrays. Merge 2 Binary Max Heaps Kth largest sum continuous subarrays Merge “K” Sorted Linked Lists Smallest range in “K” Lists Median in a stream of Integers Check if a Binary Tree is Heap Convert BST to Min Heap Convert min heap to max heap Minimum sum of two numbers formed from digits of an array Implement a Maxheap/MinHeap using arrays and recursion.","title":"DSA in Python - Heap"},{"content":" Write a Program to reverse the Linked List. (Both Iterative and recursive) Reverse a Linked List in group of Given Size. Write a program to Detect and Delete loop in a linked list. Find the starting point of the loop. Remove Duplicates in a sorted Linked List. Remove Duplicates in a Un-sorted Linked List. Write a Program to Move the last element to Front in a Linked List. Add “1” to a number represented as a Linked List. Add two numbers represented by linked lists. Intersection of two Sorted Linked List Intersection Point of two Linked Lists Merge Sort For Linked lists Quicksort for Linked Lists Find the middle Element of a linked list Check if a linked list is a circular linked list Split a Circular linked list into two halves Write a Program to check whether the Singly Linked list is a palindrome or not Deletion from a Circular Linked List Reverse a Doubly Linked list Find pairs with a given sum in a DLL Count triplets in a sorted DLL whose sum is equal to given value “X” Sort a “k”sorted Doubly Linked list Rotate DoublyLinked list by N nodes Rotate a Doubly Linked list in group of Given Size Can we reverse a linked list in less than O(n) ? [Why Quicksort is preferred for. Arrays and Merge Sort for LinkedLists ?]](#why-quicksort-is-preferred-for-arrays-and-merge-sort-for-linkedlists-) Flatten a Linked List Sort a LL of 0\u0026rsquo;s, 1\u0026rsquo;s and 2\u0026rsquo;s Clone a linked list with next and random pointer Merge K sorted Linked list Multiply 2 no. represented by LL Delete nodes which have a greater value on right side Segregate even and odd nodes in a Linked List Program for n’th node from the end of a Linked List Find the first non-repeating character from a stream of characters Write a Program to reverse the Linked List. (Both Iterative and recursive) class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def reverse(self): prev = None current = self.head while current is not None: next = current.next current.next = prev prev = current current = next self.head = prev # Function to insert a new node at the beginning def push(self, new_data): new_node = Node(new_data) new_node.next = self.head self.head = new_node # Utility function to print the linked LinkedList def printList(self): temp = self.head while(temp): print (temp.data) temp = temp.next llist = LinkedList() llist.push(20) llist.push(4) llist.push(15) llist.push(85) print (\u0026#34;Given Linked List\u0026#34;) llist.printList() llist.reverse() print (\u0026#34;\\nReversed Linked List\u0026#34;) llist.printList() Reverse a Linked List in group of Given Size. class Node(object): def __init__(self, data = None, next = None): self.data = data self.next = next def __repr__(self): return repr(self.data) class LinkedList(object): def __init__(self): self.head = None def __repr__(self): nodes = [] curr = self.head while curr: nodes.append(repr(curr)) curr = curr.next return \u0026#39;[\u0026#39; + \u0026#39;, \u0026#39;.join(nodes) + \u0026#39;]\u0026#39; # Function to insert a new node at the beginning def prepend(self, data): self.head = Node(data = data, next = self.head) # Reverses the linked list in groups of size k and returns the pointer to the new head node. def reverse(self, k = 1): if self.head is None: return curr = self.head prev = None new_stack = [] while curr is not None: val = 0 # Terminate the loop whichever comes first either current == None or value \u0026gt;= k while curr is not None and val \u0026lt; k: new_stack.append(curr.data) curr = curr.next val += 1 # Now pop the elements of stack one by one while new_stack: # If final list has not been started yet. if prev is None: prev = Node(new_stack.pop()) self.head = prev else: prev.next = Node(new_stack.pop()) prev = prev.next # Next of last element will point to None. prev.next = None return self.head # Driver Code llist = LinkedList() llist.prepend(9) llist.prepend(8) llist.prepend(7) llist.prepend(6) llist.prepend(5) llist.prepend(4) llist.prepend(3) llist.prepend(2) llist.prepend(1) print(\u0026#34;Given linked list\u0026#34;) print(llist) llist.head = llist.reverse(3) print(\u0026#34;Reversed Linked list\u0026#34;) print(llist) Write a program to Detect and Delete loop in a linked list. class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def detectAndRemoveLoop(self): slow_p = fast_p = self.head while(slow_p and fast_p and fast_p.next): slow_p = slow_p.next fast_p = fast_p.next.next # If slow_p and fast_p meet at some point then there is a loop if slow_p == fast_p: self.removeLoop(slow_p) # Return 1 to indicate that loop is found return 1 # Return 0 to indicate that there is no loop return 0 # Function to remove loop # loop_node --\u0026gt; pointer to one of the loop nodes # head --\u0026gt; Pointer to the start node of the linked list def removeLoop(self, loop_node): ptr1 = loop_node ptr2 = loop_node # Count the number of nodes in loop k = 1 while(ptr1.next != ptr2): ptr1 = ptr1.next k += 1 # Fix one pointer to head ptr1 = self.head # And the other pointer to k nodes after head ptr2 = self.head for _ in range(k): ptr2 = ptr2.next # Move both pointers at the same place they will meet at loop starting node while(ptr2 != ptr1): ptr1 = ptr1.next ptr2 = ptr2.next # Get pointer to the last node while(ptr2.next != ptr1): ptr2 = ptr2.next # Set the next node of the loop ending node to fix the loop ptr2.next = None # Function to insert a new node at the beginning def push(self, new_data): new_node = Node(new_data) new_node.next = self.head self.head = new_node # Utility function to print the LinkedList def printList(self): temp = self.head while(temp): print(temp.data, end = \u0026#39; \u0026#39;) temp = temp.next llist = LinkedList() llist.push(10) llist.push(4) llist.push(15) llist.push(20) llist.push(50) llist.head.next.next.next.next.next = llist.head.next.next llist.detectAndRemoveLoop() print(\u0026#34;Linked List after removing loop\u0026#34;) llist.printList() Find the starting point of the loop. class Node: def __init__(self, key): self.key = key self.next = None def newNode(key): # sourcery skip: inline-immediately-returned-variable temp = Node(key) return temp # A utility function to print a linked list def printList(head): while head is not None: print(head.key, end = \u0026#39; \u0026#39;) head = head.next print() # Function to detect and remove loop in a linked list that may contain loop def detectAndRemoveLoop(head): # If list is empty or has only one node without loop if head is None or head.next is None: return None slow = head fast = head # Move slow and fast 1 and 2 steps ahead respectively. slow = slow.next fast = fast.next.next # Search for loop using slow and fast pointers while (fast and fast.next) and slow != fast: slow = slow.next fast = fast.next.next # If loop does not exist if (slow != fast): return None # If loop exists. Start slow from head and fast from meeting point. slow = head while (slow != fast): slow = slow.next fast = fast.next return slow head = newNode(50) head.next = newNode(20) head.next.next = newNode(15) head.next.next.next = newNode(4) head.next.next.next.next = newNode(10) # create a loop for testing head.next.next.next.next.next = head.next.next res = detectAndRemoveLoop(head) if res is None: print(\u0026#34;Loop does not exist\u0026#34;) else: print(f\u0026#34;Loop starting node is {str(res.key)}\u0026#34;) Remove Duplicates in a sorted Linked List. import math class Node: def __init__(self, data): self.data = data self.next = None # The function removes duplicates from the given linked list def removeDuplicates(head): # Do nothing if the list consist of only one element or empty if head is None and head.next is None: return # Construct a pointer pointing towards head current = head # Initialise a while loop till the second last node of the linkedlist while (current.next): # If the data of current and next node is equal we will skip the node between them if current.data == current.next.data: current.next = current.next.next # If the data of current and next node is different move the pointer to the next node else: current = current.next return def push(head_ref, new_data): new_node = Node(new_data) new_node.data = new_data new_node.next = head_ref\thead_ref = new_node return head_ref def printList(node): while (node != None): print(node.data, end = \u0026#34; \u0026#34;) node = node.next head = None head = push(head, 20) head = push(head, 13) head = push(head, 13) head = push(head, 11) head = push(head, 11) head = push(head, 11)\tprint(\u0026#34;List before removal of duplicates \u0026#34;, end = \u0026#34;\u0026#34;) printList(head) removeDuplicates(head) print(\u0026#34;\\nList after removal of elements \u0026#34;, end = \u0026#34;\u0026#34;) printList(head)\tRemove Duplicates in a Un-sorted Linked List. class Node(): def __init__(self, data): self.data = data self.next = None class LinkedList(): def __init__(self): self.head = None def remove_duplicates(self): ptr1 = None ptr2 = None dup = None ptr1 = self.head # Pick elements one by one while (ptr1 != None and ptr1.next != None): ptr2 = ptr1 # Compare the picked element with rest of the elements while (ptr2.next != None): # If duplicate then delete it if (ptr1.data == ptr2.next.data): # Sequence of steps is important here dup = ptr2.next ptr2.next = ptr2.next.next else: ptr2 = ptr2.next ptr1 = ptr1.next def printList(self): temp = self.head while(temp != None): print(temp.data, end=\u0026#34; \u0026#34;) temp = temp.next print() list1 = LinkedList() list1.head = Node(10) list1.head.next = Node(12) list1.head.next.next = Node(11) list1.head.next.next.next = Node(11) list1.head.next.next.next.next = Node(12) list1.head.next.next.next.next.next = Node(11) list1.head.next.next.next.next.next.next = Node(10) print(\u0026#34;Linked List before removing duplicates :\u0026#34;) list1.printList() list1.remove_duplicates() print() print(\u0026#34;Linked List after removing duplicates :\u0026#34;) list1.printList() Write a Program to Move the last element to Front in a Linked List. class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, data): new_node = Node(data) new_node.next = self.head self.head = new_node def printList(self): tmp = self.head while tmp is not None: print(tmp.data, end=\u0026#34;, \u0026#34;) tmp = tmp.next print() # Function to bring the last node to the front def moveToFront(self): tmp = self.head sec_last = None # To maintain the track of the second last node # To check whether we have not received the empty list or list with a single node if not tmp or not tmp.next: return # Iterate till the end to get the last and second last node while tmp and tmp.next : sec_last = tmp tmp = tmp.next # point the next of the second last node to None sec_last.next = None # Make the last node as the first Node tmp.next = self.head self.head = tmp llist = LinkedList() llist.push(5) llist.push(4) llist.push(3) llist.push(2) llist.push(1) print (\u0026#34;Linked List before moving last to front \u0026#34;) llist.printList() llist.moveToFront() print (\u0026#34;Linked List after moving last to front \u0026#34;) llist.printList() Add “1” to a number represented as a Linked List. import sys import math class Node: def __init__(self, data): self.data = data self.next = None def newNode(data): return Node(data) def reverseList(head): if not head: return curNode = head prevNode = head nextNode = head.next curNode.next = None while(nextNode): curNode = nextNode nextNode = nextNode.next curNode.next = prevNode prevNode = curNode return curNode def addOne(head): # Reverse linked list and add one to head head = reverseList(head) k = head carry = 0 prev = None head.data += 1 # update carry for next calculation while (head != None) and (head.data \u0026gt; 9 or carry \u0026gt; 0): prev = head head.data += carry carry = head.data // 10 head.data %= 10 head = head.next if carry \u0026gt; 0: prev.next = Node(carry) # Reverse the modified list return reverseList(k) def printList(head): if not head: return while head: print(f\u0026#34;{head.data}\u0026#34;, end=\u0026#34;\u0026#34;) head = head.next head = newNode(1) head.next = newNode(9) head.next.next = newNode(9) head.next.next.next = newNode(9) print(\u0026#34;List is: \u0026#34;, end=\u0026#34;\u0026#34;) printList(head) head = addOne(head) print(\u0026#34;\\nResultant list is: \u0026#34;, end=\u0026#34;\u0026#34;) printList(head) Add two numbers represented by linked lists. class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None # Method to traverse list and return it in a format def traverse(self): linkedListStr = \u0026#34;\u0026#34; temp = self.head while temp: linkedListStr += f\u0026#34;{str(temp.data)} -\u0026gt; \u0026#34; temp = temp.next return f\u0026#34;{linkedListStr}NULL\u0026#34; # Method to insert data in linked list def insert(self, data): newNode = Node(data) if self.head is not None: newNode.next = self.head self.head = newNode # Helper function to reverse the list def reverse(Head): if (Head is None and Head.next is None): return Head prev = None curr = Head while curr: temp = curr.next curr.next = prev prev = curr curr = temp Head = prev return Head # Function to add two lists def listSum(l1, l2): if l1 is None: return l1 if l2 is None: return l2 # Reverse first list l1 = reverse(l1) # Reverse second list l2 = reverse(l2) # Storing head whose reverse is to be returned This is where which will be final node head = l1 prev = None c = 0 sum = 0 while l1 is not None and l2 is not None: sum = c + l1.data + l2.data l1.data = sum % 10 c = int(sum / 10) prev = l1 l1 = l1.next l2 = l2.next if l1 is not None or l2 is not None: if l2 is not None: prev.next = l2 l1 = prev.next while l1 is not None: sum = c + l1.data l1.data = sum % 10 c = int(sum / 10) prev = l1 l1 = l1.next\tif c \u0026gt; 0: prev.next = Node(c) return reverse(head) linkedList1 = LinkedList() linkedList1.insert(3) linkedList1.insert(6) linkedList1.insert(5) linkedList2 = LinkedList() linkedList2.insert(2) linkedList2.insert(4) linkedList2.insert(8) linkedList3 = LinkedList() linkedList3.head = listSum(linkedList1.head, linkedList2.head) print(linkedList3.traverse()) Intersection of two Sorted Linked List class Node: def __init__(self): self.data = 0 self.next = None def printList(node): while (node != None): print(node.data, end=\u0026#34; \u0026#34;) node = node.next def new_node(data): return Node() def push(head_ref, new_data): new_node = Node() new_node.data = new_data new_node.next = head_ref head_ref = new_node return head_ref def intersection(tmp1,tmp2,k): res = [0]*k set1 = set() while (tmp1 != None): set1.add(tmp1.data) tmp1 = tmp1.next cnt = 0 while (tmp2 != None): if tmp2.data in set1: res[cnt] = tmp2.data cnt += 1 tmp2 = tmp2.next return res def printList(node): while (node != None): print(node.data, end=\u0026#34; \u0026#34;) node = node.next\t# Start with the empty lists ll = None ll1 = None ll = push(ll , 7) ll = push(ll , 6) ll = push(ll , 5) ll = push(ll , 4) ll = push(ll , 3) ll = push(ll , 2) ll = push(ll , 1) ll = push(ll , 0) ll1 = push(ll1 , 7) ll1 = push(ll1 , 6) ll1 = push(ll1 , 5) ll1 = push(ll1 , 4) ll1 = push(ll1 , 3) ll1 = push(ll1 , 12) ll1 = push(ll1 , 0) ll1 = push(ll1 , 9) arr = intersection(ll , ll1 , 6) print(arr) Intersection Point of two Linked Lists class Node: def __init__(self, data): self.data = data self.next = None # function to get the intersection point of two linked lists head1 and head def getIntersectionNode(head1, head2): while head2: temp = head1 while temp: # if both Nodes are same if temp == head2: return head2 temp = temp.next head2 = head2.next # intersection is not present between the lists return None \u0026#39;\u0026#39;\u0026#39; Create two linked lists 1st 3-\u0026gt;6-\u0026gt;9-\u0026gt;15-\u0026gt;30 2nd 10-\u0026gt;15-\u0026gt;30 15 is the intersection point \u0026#39;\u0026#39;\u0026#39; newNode = Node(10) head1 = newNode newNode = Node(3) head2 = newNode newNode = Node(6) head2.next = newNode newNode = Node(9) head2.next.next = newNode newNode = Node(15) head1.next = newNode head2.next.next.next = newNode newNode = Node(30) head1.next.next = newNode if intersectionPoint := getIntersectionNode(head1, head2): print(\u0026#34;Intersection Point:\u0026#34;, intersectionPoint.data) else: print(\u0026#34; No Intersection Point \u0026#34;) Merge Sort For Linked lists class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None # push new value to linked list using append method def append(self, new_value): # Allocate new node new_node = Node(new_value) # if head is None, initialize it to new node if self.head is None: self.head = new_node return curr_node = self.head while curr_node.next is not None: curr_node = curr_node.next # Append the new node at the end of the linked list curr_node.next = new_node def sortedMerge(self, a, b): result = None # Base cases if a is None: return b if b is None: return a # pick either a or b and recur.. if a.data \u0026lt;= b.data: result = a result.next = self.sortedMerge(a.next, b) else: result = b result.next = self.sortedMerge(a, b.next) return result def mergeSort(self, h): # Base case if head is None if h is None or h.next is None: return h # get the middle of the list middle = self.getMiddle(h) nexttomiddle = middle.next # set the next of middle node to None middle.next = None # Apply mergeSort on left list left = self.mergeSort(h) # Apply mergeSort on right list right = self.mergeSort(nexttomiddle) return self.sortedMerge(left, right) def getMiddle(self, head): if head is None: return head slow = head fast = head while (fast.next != None and fast.next.next != None): slow = slow.next fast = fast.next.next return slow def printList(head): if head is None: print(\u0026#39; \u0026#39;) return curr_node = head while curr_node: print(curr_node.data, end = \u0026#34; \u0026#34;) curr_node = curr_node.next print(\u0026#39; \u0026#39;) li = LinkedList() li.append(15) li.append(10) li.append(5) li.append(20) li.append(3) li.append(2) li.head = li.mergeSort(li.head) print (\u0026#34;Sorted Linked List is:\u0026#34;) printList(li.head) Quicksort for Linked Lists class Node: def __init__(self, val): self.data = val self.next = None class QuickSortLinkedList: def __init__(self): self.head=None def addNode(self,data): if self.head is None: self.head = Node(data) return curr = self.head while (curr.next != None): curr = curr.next newNode = Node(data) curr.next = newNode def printList(self,n): while (n != None): print(n.data, end=\u0026#34; \u0026#34;) n = n.next \u0026#39;\u0026#39;\u0026#39; takes first and last node,but do not break any links in the whole linked list\u0026#39;\u0026#39;\u0026#39; def paritionLast(self,start, end): if start == end or start is None or end is None: return start pivot_prev = start curr = start pivot = end.data \u0026#39;\u0026#39;\u0026#39;iterate till one before the end, no need to iterate till the end because end is pivot\u0026#39;\u0026#39;\u0026#39; while (start != end): if (start.data \u0026lt; pivot): # keep tracks of last modified item pivot_prev = curr temp = curr.data curr.data = start.data start.data = temp curr = curr.next start = start.next \u0026#39;\u0026#39;\u0026#39;swap the position of curr i.e. next suitable index and pivot\u0026#39;\u0026#39;\u0026#39; temp = curr.data curr.data = pivot end.data = temp \u0026#39;\u0026#39;\u0026#39; return one previous to current because current is now pointing to pivot \u0026#39;\u0026#39;\u0026#39; return pivot_prev def sort(self, start, end): if start is None or start == end or start == end.next: return # split list and partition recurse pivot_prev = self.paritionLast(start, end) self.sort(start, pivot_prev) \u0026#39;\u0026#39;\u0026#39; if pivot is picked and moved to the start, that means start and pivot is same so pick from next of pivot \u0026#39;\u0026#39;\u0026#39; if(pivot_prev != None and pivot_prev == start): self.sort(pivot_prev.next, end) # if pivot is in between of the list,start from next of pivot, since we have pivot_prev, so we move two nodes elif (pivot_prev != None and pivot_prev.next != None): self.sort(pivot_prev.next.next, end) ll = QuickSortLinkedList() ll.addNode(30) ll.addNode(3) ll.addNode(4) ll.addNode(20) ll.addNode(5) n = ll.head while n.next is not None: n = n.next print(\u0026#34;\\nLinked List before sorting\u0026#34;) ll.printList(ll.head) ll.sort(ll.head, n) print(\u0026#34;\\nLinked List after sorting\u0026#34;); ll.printList(ll.head) Find the middle Element of a linked list class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, new_data): new_node = Node(new_data) new_node.next = self.head self.head = new_node def printList(self): node = self.head while node: print(f\u0026#34;{str(node.data)}-\u0026gt;\u0026#34;, end=\u0026#34;\u0026#34;) node = node.next print(\u0026#34;NULL\u0026#34;) def printMiddle(self): # Initialize two pointers, one will go one step a time (slow), another two at a time (fast) slow = self.head fast = self.head # Iterate till fast\u0026#39;s next is null (fast reaches end) while fast and fast.next: slow = slow.next fast = fast.next.next # return the slow\u0026#39;s data, which would be the middle element. print(\u0026#34;The middle element is \u0026#34;, slow.data) # Start with the empty list llist = LinkedList() for i in range(5, 0, -1): llist.push(i) llist.printList() llist.printMiddle() Check if a linked list is a circular linked list class Node: def __init__(self, data): self.data = data # Assign data self.next = None # Initialize next as null class LinkedList: def __init__(self): self.head = None def Circular(head): if head is None: return True node = head.next i = 0 while((node is not None) and (node is not head)): i = i + 1 node = node.next return node==head llist = LinkedList() llist.head = Node(1) second = Node(2) third = Node(3) fourth = Node(4) llist.head.next = second; second.next = third; third.next = fourth if (Circular(llist.head)): print(\u0026#39;Yes\u0026#39;) else: print(\u0026#39;No\u0026#39;) fourth.next = llist.head if (Circular(llist.head)): print(\u0026#39;Yes\u0026#39;) else: print(\u0026#39;No\u0026#39;) Split a Circular linked list into two halves class Node: def __init__(self, data): self.data = data self.next = None class CircularLinkedList: def __init__(self): self.head = None # circular linked list def push(self, data): ptr1 = Node(data) temp = self.head ptr1.next = self.head # If linked list is not None then set the next of last node if self.head is not None: while(temp.next != self.head): temp = temp.next temp.next = ptr1 else: ptr1.next = ptr1 # For the first node self.head = ptr1 def printList(self): temp = self.head if self.head is not None: while(True): print (\u0026#34;%d\u0026#34; %(temp.data),end=\u0026#39; \u0026#39;) temp = temp.next if (temp == self.head): break # Function to split a list (starting with head) into two lists. head1 and head2 are the head nodes of the two resultant linked lists def splitList(self, head1, head2): slow_ptr = self.head fast_ptr = self.head if self.head is None: return # If there are odd nodes in the circular list then fast_ptr-\u0026gt;next becomes head and for even nodes fast_ptr-\u0026gt;next-\u0026gt;next becomes head while(fast_ptr.next != self.head and fast_ptr.next.next != self.head ): fast_ptr = fast_ptr.next.next slow_ptr = slow_ptr.next # If there are even elements in list then move fast_ptr if fast_ptr.next.next == self.head: fast_ptr = fast_ptr.next # Set the head pointer of first half head1.head = self.head # Set the head pointer of second half if self.head.next != self.head: head2.head = slow_ptr.next # Make second half circular fast_ptr.next = slow_ptr.next # Make first half circular slow_ptr.next = self.head # Initialize lists as empty head = CircularLinkedList() head1 = CircularLinkedList() head2 = CircularLinkedList() head.push(12) head.push(56) head.push(2) head.push(11) print (\u0026#34;Original Circular Linked List\u0026#34;) head.printList() # Split the list head.splitList(head1 , head2) print (\u0026#34;\\nFirst Circular Linked List\u0026#34;) head1.printList() print (\u0026#34;\\nSecond Circular Linked List\u0026#34;) head2.printList() Write a Program to check whether the Singly Linked list is a palindrome or not class Node: def __init__(self,data): self.data = data self.ptr = None def ispalindrome(head): # Temp pointer slow = head # Declare a stack stack = [] ispalin = True # Push all elements of the list to the stack while slow != None: stack.append(slow.data) # Move ahead slow = slow.ptr # Iterate in the list again and check by popping from the stack while head != None: # Get the top most element i = stack.pop() # Check if data is not same as popped element if head.data == i: ispalin = True else: ispalin = False break # Move ahead head = head.ptr return ispalin # Addition of linked list one = Node(1) two = Node(2) three = Node(3) four = Node(4) five = Node(3) six = Node(2) seven = Node(1) # Initialize the next pointer of every current pointer one.ptr = two two.ptr = three three.ptr = four four.ptr = five five.ptr = six six.ptr = seven seven.ptr = None result = ispalindrome(one) print(\u0026#34;isPalindrome:\u0026#34;, result) Deletion from a Circular Linked List class Node: def __init__(self, data): self.data = data self.next = None def deleteNode(head, key): t = head while t and t.next != head: if t.next.data == key: t.next = t.next.next t = t.next def reverse(head): arr = [] t = head arr.append(t.data) t = t.next while t != head: arr.append(t.data) t = t.next arr = arr[::-1] t = head i = 0 while t != None: if t.next == head: t.data = arr[len(arr)-1] break else: t.data = arr[i] t = t.next i+=1 def push(data, prev): if prev is None: prev = Node(data) return prev tmp = Node(data) prev.next = tmp return tmp def printList(head): flg = False tmp = head while flg is False or tmp != head: flg = True print(tmp.data, end=\u0026#34; \u0026#34;) tmp = tmp.next print() n = 5 arr = [1,2,3,4,5] delNode = 4 head = Node(None) prev = head for i in arr: prev = push(i, prev) head = head.next prev.next = head deleteNode(head, delNode) reverse(head) printList(head) Reverse a Doubly Linked list class Node: def __init__(self, data): self.data = data self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None def reverse(self): temp = None current = self.head # Swap next and prev for all nodes of doubly linked list while current is not None: temp = current.prev current.prev = current.next current.next = temp current = current.prev # Before changing head, check for the cases like empty list and list with only one node if temp is not None: self.head = temp.prev # Given a reference to the head of a list and an integer,inserts a new node on the front of list def push(self, new_data): new_node = Node(new_data) new_node.next = self.head if self.head is not None: self.head.prev = new_node self.head = new_node def printList(self, node): while(node is not None): print(node.data,end=\u0026#39; \u0026#39;) node = node.next dll = DoublyLinkedList() dll.push(2) dll.push(4) dll.push(8) dll.push(10) print (\u0026#34;\\nOriginal Linked List\u0026#34;) dll.printList(dll.head) dll.reverse() print (\u0026#34;\\nReversed Linked List\u0026#34;) dll.printList(dll.head) Find pairs with a given sum in a DLL class Node: def __init__(self, x): self.data = x self.next = None self.prev = None def pairSum(head, x): # Set two pointers, first to the beginning of DLL and second to the end of DLL. first = head second = head while (second.next != None): second = second.next # To track if we find a pair or not found = False # The loop terminates when they cross each other (second.next == first), or they become same (first == second) while (first != second and second.next != first): # Pair found if ((first.data + second.data) == x): found = True print(\u0026#34;Pair found: \u0026#34;, first.data, second.data) # Move first in forward direction first = first.next # Move second in backward direction second = second.prev elif ((first.data + second.data) \u0026lt; x): first = first.next else: second = second.prev # If pair is not present if not found: print(\u0026#34;No pair found\u0026#34;) def insert(head, data): temp = Node(data) if head: temp.next = head head.prev = temp head = temp return head head = None head = insert(head, 9) head = insert(head, 8) head = insert(head, 6) head = insert(head, 5) head = insert(head, 4) head = insert(head, 2) head = insert(head, 1) x = 7 pairSum(head, x) Count triplets in a sorted DLL whose sum is equal to given value “X” class Node: def __init__(self, x): self.data = x self.next = None self.prev = None def countPairs(first, second, value): count = 0 # The loop terminates when either of two pointers become None, or they cross each other (second.next == first), or they become same (first == second) while (first != None and second != None and first != second and second.next != first): # Pair found if ((first.data + second.data) == value): # Increment count count += 1 # Move first in forward direction first = first.next # Move second in backward direction second = second.prev # If sum is greater than \u0026#39;value\u0026#39; move second in backward direction elif ((first.data + second.data) \u0026gt; value): second = second.prev # Else move first in forward direction else: first = first.next # Required count of pairs return count def countTriplets(head, x): # If list is empty if head is None: return 0 current, first, last = head, None, None count = 0 # Get pointer to the last node of the doubly linked list last = head while (last.next != None): last = last.next # Traversing the doubly linked list while current != None: # For each current node first = current.next # count pairs with sum(x - current.data) in the range first to last and add it to the \u0026#39;count\u0026#39; of triplets count, current = count + countPairs( first, last, x - current.data), current.next # Required count of triplets return count def insert(head, data): temp = Node(data) if head != None: temp.next = head head.prev = temp head = temp return head head = None head = insert(head, 9) head = insert(head, 8) head = insert(head, 6) head = insert(head, 5) head = insert(head, 4) head = insert(head, 2) head = insert(head, 1) x = 17 print(\u0026#34;Count = \u0026#34;, countTriplets(head, x)) Sort a “k”sorted Doubly Linked list class Node: def __init__(self, val): self.data = val self.prev = None self.next = None # function to sort a k sorted doubly linked list Using Insertion Sort # Time Complexity: O(n*k) # Space Complexity: O(1) def sortAKSortedDLL(head , k): if head is None or head.next is None: return head # perform on all the nodes in list i = head.next while (i != None): j = i # There will be atmost k swaps for each element in the list since each node is k steps away from its correct position while (j.prev != None and j.data \u0026lt; j.prev.data): # swap j and j.prev node temp = j.prev.prev temp2 = j.prev temp3 = j.next j.prev.next = temp3 j.prev.prev = j j.prev = temp j.next = temp2 if (temp != None): temp.next = j if (temp3 != None): temp3.prev = temp2 # if j is now the new head then reset head if j.prev is None: head = j i = i.next return head # Function to insert a node at the beginning of the Doubly Linked List def push(new_data): global head new_node = Node(new_data) new_node.prev = None new_node.next = head if (head != None): head.prev = new_node head = new_node def printList(node): while (node != None): print(node.data,end = \u0026#34; \u0026#34;) node = node.next head = None # Let us create a k sorted doubly linked list to test the functions Created doubly linked list will be 3\u0026lt;-\u0026gt;6\u0026lt;-\u0026gt;2\u0026lt;-\u0026gt;12\u0026lt;-\u0026gt;56\u0026lt;-\u0026gt;8 push(8) push(56) push(12) push(2) push(6) push(3) k = 2 print(\u0026#34;Original Doubly linked list:\u0026#34;) printList(head) sortedDLL = sortAKSortedDLL(head, k) print(\u0026#34;\u0026#34;) print(\u0026#34;Doubly Linked List after sorting:\u0026#34;) printList(sortedDLL) Rotate DoublyLinked list by N nodes class Node: def __init__(self, next = None, prev = None, data = None): self.next = next self.prev = prev self.data = data def push(head, new_data): new_node = Node(data = new_data) new_node.next = head new_node.prev = None if head is not None: head.prev = new_node head = new_node return head def printList(head): node = head print(\u0026#34;Given linked list\u0026#34;) while(node is not None): print(node.data, end = \u0026#34; \u0026#34;) last = node node = node.next def rotate(start, N): if N == 0 : return # Let us understand the below code for example N = 2 and list = a \u0026lt;-\u0026gt; b \u0026lt;-\u0026gt; c \u0026lt;-\u0026gt; d \u0026lt;-\u0026gt; e. current = start # current will either point to Nth or None after this loop. Current will point to node \u0026#39;b\u0026#39; in the above example count = 1 while count \u0026lt; N and current != None : current = current.next count += 1 # If current is None, N is greater than or equal to count of nodes in linked list. Don\u0026#39;t change the list in this case if current is None: return # current points to Nth node. Store it in a variable. NthNode points to node \u0026#39;b\u0026#39; in the above example NthNode = current # current will point to last node after this loop current will point to node \u0026#39;e\u0026#39; in the above example while current.next != None : current = current.next # Change next of last node to previous head. Next of \u0026#39;e\u0026#39; is now changed to node \u0026#39;a\u0026#39; current.next = start # Change prev of Head node to current Prev of \u0026#39;a\u0026#39; is now changed to node \u0026#39;e\u0026#39; start.prev = current # Change head to (N+1)th node head is now changed to node \u0026#39;c\u0026#39; start = NthNode.next # Change prev of New Head node to None Because Prev of Head Node in Doubly linked list is None start.prev = None # change next of Nth node to None next of \u0026#39;b\u0026#39; is now None NthNode.next = None return start head = None head = push(head, \u0026#39;e\u0026#39;) head = push(head, \u0026#39;d\u0026#39;) head = push(head, \u0026#39;c\u0026#39;) head = push(head, \u0026#39;b\u0026#39;) head = push(head, \u0026#39;a\u0026#39;) printList(head) print(\u0026#34;\\n\u0026#34;) N = 2 head = rotate(head, N) printList(head) Rotate a Doubly Linked list in group of Given Size class Node: def __init__(self): self.data = 0 self.next = None self.next = None def insertAtEnd(head, data): new_Node = Node() new_Node.data = data new_Node.next = None temp = head if head is None: new_Node.prev = None head = new_Node return head while (temp.next != None): temp = temp.next temp.next = new_Node new_Node.prev = temp return head def printDLL(head): while (head != None): print(head.data, end=\u0026#34; \u0026#34;) head = head.next print() # Function to Reverse a doubly linked list in groups of given size def reverseByN(head, k): if head is None: return None head.prev = None temp=None curr = head newHead = None count = 0 while (curr != None and count \u0026lt; k): newHead = curr temp = curr.prev curr.prev = curr.next curr.next = temp curr = curr.prev count += 1 # Checking if the reversed LinkedList size is equal to K or not. If it is not equal to k that means we have reversed the last set of size K and we don\u0026#39;t need to call the recursive function if (count \u0026gt;= k): rest = reverseByN(curr, k) head.next = rest if (rest != None): # it is required for prev link otherwise u wont be backtrack list due to broken links rest.prev = head return newHead head = None for i in range(1,11): head = insertAtEnd(head, i) printDLL(head) n = 4 head = reverseByN(head, n) printDLL(head) Can we reverse a linked list in less than O(n) ? It is not possible to reverse a simple singly linked list in less than O(n). A simple singly linked list can only be reversed in O(n) time using recursive and iterative methods. A doubly linked list with head and tail pointers while only requiring swapping the head and tail pointers which require lesser operations than a singly linked list can also not be done in less than O(n) since we need to traverse till the end of the list anyway to find the tail node. Why Quicksort is preferred for. Arrays and Merge Sort for LinkedLists ?] Quick Sort in its general form is an in-place sort (i.e. it doesn’t require any extra storage) whereas merge sort requires O(N) extra storage, N denoting the array size which may be quite expensive. Allocating and de-allocating the extra space used for merge sort increases the running time of the algorithm. Comparing average complexity we find that both type of sorts have O(NlogN) average complexity but the constants differ. For arrays, merge sort loses due to the use of extra O(N) storage space. Most practical implementations of Quick Sort use randomized version. The randomized version has expected time complexity of O(nLogn). The worst case is possible in randomized version also, but worst case doesn’t occur for a particular pattern (like sorted array) and randomized Quick Sort works well in practice. Quick Sort is also a cache friendly sorting algorithm as it has good locality of reference when used for arrays. Quick Sort is also tail recursive, therefore tail call optimizations is done. Why is Merge Sort preferred for Linked Lists? In case of linked lists the case is different mainly due to difference in memory allocation of arrays and linked lists. Unlike arrays, linked list nodes may not be adjacent in memory. Unlike array, in linked list, we can insert items in the middle in O(1) extra space and O(1) time if we are given reference/pointer to the previous node. Therefore merge operation of merge sort can be implemented without extra space for linked lists. In arrays, we can do random access as elements are continuous in memory. Let us say we have an integer (4-byte) array A and let the address of A[0] be x then to access A[i], we can directly access the memory at (x + i*4). Unlike arrays, we can not do random access in linked list. Quick Sort requires a lot of this kind of access. In linked list to access i’th index, we have to travel each and every node from the head to i’th node as we don’t have continuous block of memory. Therefore, the overhead increases for quick sort. Merge sort accesses data sequentially and the need of random access is low. Flatten a Linked List class Node(): def __init__(self,data): self.data = data self.right = None self.down = None class LinkedList(): def __init__(self): self.head = None def push(self,head_ref,data): new_node = Node(data) new_node.down = head_ref head_ref = new_node return head_ref def printList(self): temp = self.head while(temp != None): print(temp.data,end=\u0026#34; \u0026#34;) temp = temp.down print() def merge(self, a, b): # if first linked list is empty then second is the answer if a is None: return b # if second linked list is empty then first is the result if b is None: return a # compare the data members of the two linked lists and put the larger one in the result result = None if (a.data \u0026lt; b.data): result = a result.down = self.merge(a.down,b) else: result = b result.down = self.merge(a,b.down) result.right = None return result def flatten(self, root): # Base Case if root is None or root.right is None: return root # recur for list on right root.right = self.flatten(root.right) # now merge root = self.merge(root, root.right) # return the root it will be in turn merged with its left return root \u0026#39;\u0026#39;\u0026#39; Let us create the following linked list 5 -\u0026gt; 10 -\u0026gt; 19 -\u0026gt; 28 | |\t|\t| V V\tV\tV 7 20 22 35 |\t|\t| V\tV\tV 8\t50 40 |\t| V\tV 30\t45 \u0026#39;\u0026#39;\u0026#39; L = LinkedList() L.head = L.push(L.head, 30); L.head = L.push(L.head, 8); L.head = L.push(L.head, 7); L.head = L.push(L.head, 5); L.head.right = L.push(L.head.right, 20); L.head.right = L.push(L.head.right, 10); L.head.right.right = L.push(L.head.right.right, 50); L.head.right.right = L.push(L.head.right.right, 22); L.head.right.right = L.push(L.head.right.right, 19); L.head.right.right.right = L.push(L.head.right.right.right, 45); L.head.right.right.right = L.push(L.head.right.right.right, 40); L.head.right.right.right = L.push(L.head.right.right.right, 35); L.head.right.right.right = L.push(L.head.right.right.right, 20); L.head = L.flatten(L.head); L.printList() Sort a LL of 0\u0026rsquo;s, 1\u0026rsquo;s and 2\u0026rsquo;s import math class Node: def __init__(self, data): self.data = data self.next = None def sortList(head): if head is None or head.next is None: return head # Create three dummy nodes to point to beginning of three linked lists. These dummy nodes are created to avoid many None checks. zeroD = Node(0) oneD = Node(0) twoD = Node(0) # Initialize current pointers for three lists and whole list. zero = zeroD one = oneD two = twoD # Traverse list curr = head while curr: if (curr.data == 0): zero.next = curr zero = zero.next elif curr.data == 1: one.next = curr one = one.next else: two.next = curr two = two.next curr = curr.next # Attach three lists zero.next = oneD.next or twoD.next one.next = twoD.next two.next = None # Updated head head = zeroD.next # Delete dummy nodes return head # function to create and return a node def newNode(data): newNode = Node(data) newNode.data = data newNode.next = None return newNode # Function to print linked list def printList(node): while (node != None): print(node.data, end = \u0026#34; \u0026#34;) node = node.next head = newNode(1) head.next = newNode(2) head.next.next = newNode(0) head.next.next.next = newNode(1) print(\u0026#34;Linked List Before Sorting\u0026#34;) printList(head) head = sortList(head) print(\u0026#34;\\nLinked List After Sorting\u0026#34;) printList(head) Clone a linked list with next and random pointer class Node: def __init__(self, data): self.data = data\tself.next = None self.random = None class MyDictionary(dict): def __init__(self): super().__init__() self = {} def add(self, key, value): self[key] = value class LinkedList: def __init__(self, node): self.head = node def __repr__(self): temp = self.head while temp is not None: random = temp.random random_data = (random.data if random is not None else -1) data = temp.data print( f\u0026#34;Data-{data}, Random data: {random_data}\u0026#34;) temp = temp.next return \u0026#34;\\n\u0026#34; def push(self, data): node = Node(data) node.next = self.head self.head = node def clone(self): # Initialize two references, one with original list\u0026#39;s head. original = self.head clone = None # Initialize two references, one with original list\u0026#39;s head. mp = MyDictionary() # Traverse the original list and make a copy of that in the clone linked list while original is not None: clone = Node(original.data) mp.add(original, clone) original = original.next # Adjusting the original list reference again. original = self.head # Traversal of original list again to adjust the next and random references of clone list using hash map. while original is not None: clone = mp.get(original) clone.next = mp.get(original.next) clone.random = mp.get(original.random) original = original.next # Return the head reference of the clone list. return LinkedList(self.head) l = LinkedList(Node(5)) l.push(4) l.push(3) l.push(2) l.push(1) l.head.random = l.head.next.next l.head.next.random = l.head.next.next.next l.head.next.next.random = l.head.next.next.next.next l.head.next.next.next.random = (l.head.next.next.next. next.next) l.head.next.next.next.next.random = l.head.next clone = l.clone() print(\u0026#34;Original linked list\u0026#34;) print(l) print(\u0026#34;Cloned linked list\u0026#34;) print(clone) Merge K sorted Linked list class Node: def __init__(self): self.data = 0 self.next = None def printList(node): while (node != None): print(node.data, end = \u0026#39; \u0026#39;) node = node.next def SortedMerge(a, b): result = None # Base cases if a is None: return b elif b is None: return a # Pick either a or b, and recur if (a.data \u0026lt;= b.data): result = a result.next = SortedMerge(a.next, b) else: result = b result.next = SortedMerge(a, b.next) return result def mergeKLists(arr, last): # Repeat until only one list is left while (last != 0): i = 0 j = last # (i, j) forms a pair while (i \u0026lt; j): # Merge List i with List j and store merged list in List i arr[i] = SortedMerge(arr[i], arr[j]) # Consider next pair i += 1 j -= 1 # If all pairs are merged, update last if (i \u0026gt;= j): last = j return arr[0] def newNode(data): temp = Node() temp.data = data temp.next = None return temp k = 3 # Number of linked lists n = 4 # Number of elements in each list arr = [0 for _ in range(k)] arr[0] = newNode(1) arr[0].next = newNode(3) arr[0].next.next = newNode(5) arr[0].next.next.next = newNode(7) arr[1] = newNode(2) arr[1].next = newNode(4) arr[1].next.next = newNode(6) arr[1].next.next.next = newNode(8) arr[2] = newNode(0) arr[2].next = newNode(9) arr[2].next.next = newNode(10) arr[2].next.next.next = newNode(11) head = mergeKLists(arr, k - 1) printList(head) Multiply 2 no. represented by LL class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, new_data): new_node = Node(new_data) new_node.next = self.head self.head = new_node def printList(self): ptr = self.head while (ptr != None): print(ptr.data, end = \u0026#39;\u0026#39;) if ptr.next != None: print(\u0026#39;-\u0026gt;\u0026#39;, end = \u0026#39;\u0026#39;) ptr = ptr.next\tprint() # Multiply contents of two Linked Lists def multiplyTwoLists(first, second): num1 = 0 num2 = 0 first_ptr = first.head second_ptr = second.head while first_ptr != None or second_ptr != None: if first_ptr != None: num1 = (num1 * 10) + first_ptr.data first_ptr = first_ptr.next if second_ptr != None: num2 = (num2 * 10) + second_ptr.data second_ptr = second_ptr.next return num1 * num2 first = LinkedList() second = LinkedList() # Create first Linked List 9-\u0026gt;4-\u0026gt;6 first.push(6) first.push(4) first.push(9) print(\u0026#34;First list is: \u0026#34;, end = \u0026#39;\u0026#39;) first.printList() # Create second Linked List 8-\u0026gt;4 second.push(4) second.push(8) print(\u0026#34;Second List is: \u0026#34;, end = \u0026#39;\u0026#39;) second.printList() result = multiplyTwoLists(first, second) print(\u0026#34;Result is: \u0026#34;, result) Delete nodes which have a greater value on right side class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, new_data): new_node = Node(new_data) new_node.next = self.head self.head = new_node def printList(self): temp = self.head while(temp): print (temp.data,end=\u0026#34; \u0026#34;) temp = temp.next def del_gr_right(self): i = self.head while i: value = i.data found = False j = i.next while j: if j.data \u0026gt; value: found = True break j = j.next if found: temp = i.next i.data = i.next.data i.next = i.next.next temp = None else: i = i.next llist = LinkedList() llist.push(11) llist.push(18) llist.push(20) llist.push(14) llist.push(15) print (\u0026#34;Given Linked List is:\u0026#34;) llist.printList() print() llist.del_gr_right() print (\u0026#34;\\nLinked list after deletion is\u0026#34;) llist.printList() Segregate even and odd nodes in a Linked List class Node: def __init__(self, data): self.data = data self.next =None # Function to segregate even and odd nodes. def segregateEvenOdd(): global head evenStart = None # Starting node of list having even values. evenEnd = None # Ending node of even values list.\toddStart = None # Starting node of odd values list.\toddEnd = None # Ending node of odd values list.\tcurrNode = head # Node to traverse the list. while (currNode != None): val = currNode.data # If current value is even, add it to even values list. if (val % 2 == 0): if evenStart is None: evenStart = currNode evenEnd = evenStart else: evenEnd . next = currNode evenEnd = evenEnd . next elif oddStart is None: oddStart = currNode oddEnd = oddStart else: oddEnd . next = currNode oddEnd = oddEnd . next # Move head pointer one step in forward direction currNode = currNode . next # If either odd list or even list is empty, no change is required as all elements are either even or odd. if oddStart is None or evenStart is None: return # Add odd list after even list.\tevenEnd.next = oddStart oddEnd.next = None # Modify head pointer to starting of even list. head = evenStart def push(new_data): global head new_node = Node(new_data) new_node.next = head head = new_node def printList(): global head node = head while (node != None): print(node.data, end = \u0026#34; \u0026#34;) node = node.next print() \u0026#39;\u0026#39;\u0026#39; Let us create a sample linked list as following 0.1.4.6.9.10.11 \u0026#39;\u0026#39;\u0026#39; head = None push(11) push(10) push(9) push(6) push(4) push(1) push(0) print(\u0026#34;Original Linked list\u0026#34;) printList() segregateEvenOdd() print(\u0026#34;Modified Linked list\u0026#34;) printList() Program for n’th node from the end of a Linked List class Node: def __init__(self, new_data): self.data = new_data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, new_data): new_node = Node(new_data) new_node.next = self.head self.head = new_node def printNthFromLast(self, n): temp = self.head # used temp variable length = 0 while temp is not None: temp = temp.next length += 1 # print count if n \u0026gt; length: # if entered location is greater than length of linked list print(\u0026#39;Location is greater than the length of LinkedList\u0026#39;) return temp = self.head for _ in range(length - n): temp = temp.next print(temp.data) llist = LinkedList() llist.push(20) llist.push(4) llist.push(15) llist.push(35) llist.printNthFromLast(4) Find the first non-repeating character from a stream of characters from queue import Queue def firstnonrepeating(Str): global MAX_CHAR q = Queue() charCount = [0] * MAX_CHAR # traverse whole Stream for i in range(len(Str)): # push each character in queue q.put(Str[i]) # increment the frequency count charCount[ord(Str[i]) - ord(\u0026#39;a\u0026#39;)] += 1 # check for the non repeating character while (not q.empty()): if (charCount[ord(q.queue[0]) - ord(\u0026#39;a\u0026#39;)] \u0026gt; 1): q.get() else: print(q.queue[0], end = \u0026#34; \u0026#34;) break if (q.empty()): print(-1, end = \u0026#34; \u0026#34;) print() MAX_CHAR = 26 Str = \u0026#34;aabc\u0026#34; firstnonrepeating(Str) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/ll/","summary":"Write a Program to reverse the Linked List. (Both Iterative and recursive) Reverse a Linked List in group of Given Size. Write a program to Detect and Delete loop in a linked list. Find the starting point of the loop. Remove Duplicates in a sorted Linked List. Remove Duplicates in a Un-sorted Linked List. Write a Program to Move the last element to Front in a Linked List. Add “1” to a number represented as a Linked List.","title":"DSA in Python - Linked List"},{"content":" Spiral traversal on a Matrix Search an element in a matrix Find median in a row wise sorted matrix Find row with maximum no. of 1\u0026rsquo;s Print elements in sorted order using row-column wise sorted matrix Maximum size rectangle Find a specific pair in matrix Rotate matrix by 90 degrees Kth smallest element in a row-column wise sorted matrix Common elements in all rows of a given matrix Spiral traversal on a Matrix def spiralOrder(matrix): ans = [] if (len(matrix) == 0): return ans m = len(matrix) n = len(matrix[0]) seen = [[0 for _ in range(n)] for _ in range(m)] dr = [0, 1, 0, -1] dc = [1, 0, -1, 0] x = 0 y = 0 di = 0 # Iterate from 0 to R * C - 1 for _ in range(m * n): ans.append(matrix[x][y]) seen[x][y] = True cr = x + dr[di] cc = y + dc[di] if cr \u0026gt;= 0 and cr \u0026lt; m and cc \u0026gt;= 0 and cc \u0026lt; n and not (seen[cr][cc]): x = cr y = cc else: di = (di + 1) % 4 x += dr[di] y += dc[di] return ans a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] for x in spiralOrder(a): print(x, end=\u0026#34; \u0026#34;) print() Search an element in a matrix def search(mat, n, x): if(n == 0): return -1 for i in range(n): for j in range(n): if(mat[i][j] == x): print(\u0026#34;Element found at (\u0026#34;, i, \u0026#34;,\u0026#34;, j, \u0026#34;)\u0026#34;) return 1 print(\u0026#34; Element not found\u0026#34;) return 0 mat = [[10, 20, 30, 40], [15, 25, 35, 45],[27, 29, 37, 48],[32, 33, 39, 50]] search(mat, 4, 29) Find median in a row wise sorted matrix from bisect import bisect_right as upper_bound MAX = 100; def binaryMedian(m, r, d): mi = m[0][0] mx = 0 for i in range(r): if m[i][0] \u0026lt; mi: mi = m[i][0] if m[i][d-1] \u0026gt; mx : mx = m[i][d-1] desired = (r * d + 1) // 2 while (mi \u0026lt; mx): mid = mi + (mx - mi) // 2 place = [0]; for i in range(r): j = upper_bound(m[i], mid) place[0] = place[0] + j if place[0] \u0026lt; desired: mi = mid + 1 else: mx = mid print (\u0026#34;Median is\u0026#34;, mi) return r, d = 3, 3 m = [ [1, 3, 5], [2, 6, 9], [3, 6, 9]] binaryMedian(m, r, d) Find row with maximum no. of 1\u0026rsquo;s def first(arr , low , high): if(high \u0026gt;= low): # Get the middle index mid = low + (high - low)//2 # Check if the element at middle index is first 1 if ( ( mid == 0 or arr[mid-1] == 0) and arr[mid] == 1): return mid # If the element is 0, recur for right side elif (arr[mid] == 0): return first(arr, (mid + 1), high); # If element is not first 1, recur for left side else: return first(arr, low, (mid -1)); return -1 def rowWithMax1s(mat): # Initialize max values max_row_index,Max = 0,-1 # Traverse for each row and count number of 1s by finding the index of first 1 for i in range(R): index = first (mat[i], 0, C-1) if (index != -1 and C-index \u0026gt; Max): Max = C - index; max_row_index = i return max_row_index R,C = 4,4 mat = [[0, 0, 0, 1], [0, 1, 1, 1], [1, 1, 1, 1], [0, 0, 0, 0]] print(f\u0026#34;Index of row with maximum 1s is {str(rowWithMax1s(mat))}\u0026#34;) Print elements in sorted order using row-column wise sorted matrix import sys INF = sys.maxsize # A utility function to youngify a Young Tableau. This is different from standard youngify. It assumes that the value at mat[0][0] is infinite. def youngify(mat, i, j): # Find the values at down and right sides of mat[i][j] downVal = mat[i + 1][j] if (i + 1 \u0026lt; N) else INF rightVal = mat[i][j + 1] if (j + 1 \u0026lt; N) else INF # If mat[i][j] is the down right corner element, return if (downVal == INF and rightVal == INF): return # Move the smaller of two values (downVal and rightVal) to mat[i][j] and recur for smaller value if (downVal \u0026lt; rightVal): mat[i][j] = downVal mat[i + 1][j] = INF youngify(mat, i + 1, j) else: mat[i][j] = rightVal mat[i][j + 1] = INF youngify(mat, i, j + 1) # A utility function to extract minimum element from Young tableau def extractMin(mat): ret = mat[0][0] mat[0][0] = INF youngify(mat, 0, 0) return ret def printSorted(mat): print(\u0026#34;Elements of matrix in sorted order n\u0026#34;) i = 0 while i \u0026lt; N * N: print(extractMin(mat), end = \u0026#34; \u0026#34;) i += 1 N = 4 mat = [[10, 20, 30, 40], [15, 25, 35, 45], [27, 29, 37, 48], [32, 33, 39, 50]] printSorted(mat) Maximum size rectangle class Solution(): def maxHist(self, row): # Create an empty stack. The stack holds indexes of hist array / The bars stored in stack are always in increasing order of their heights. result = [] top_val = 0 # Top of stack max_area = 0 # Initialize max area in current area = 0 # Initialize area with current top # Run through all bars of given histogram (or row) i = 0 while (i \u0026lt; len(row)): # If this bar is higher than the bar on top stack, push it to stack if not result or row[result[-1]] \u0026lt;= row[i]: result.append(i) i += 1 else: # If this bar is lower than top of stack, then calculate area of rectangle with stack top as the smallest (or minimum height) bar. \u0026#39;i\u0026#39; is \u0026#39;right index\u0026#39; for the top and element before top in stack is \u0026#39;left index\u0026#39; top_val = row[result.pop()] area = top_val * i if (len(result)): area = top_val * (i - result[-1] - 1) max_area = max(area, max_area) # Now pop the remaining bars from stack and calculate area with every popped bar as the smallest bar while (len(result)): top_val = row[result.pop()] area = top_val * i if (len(result)): area = top_val * (i - result[-1] - 1) max_area = max(area, max_area) return max_area # Returns area of the largest rectangle with all 1s in A def maxRectangle(self, A): # Calculate area for first row and initialize it as result result = self.maxHist(A[0]) # iterate over row to find maximum rectangular area considering each row as histogram for i in range(1, len(A)): for j in range(len(A[i])): # if A[i][j] is 1 then add A[i -1][j] if (A[i][j]): A[i][j] += A[i - 1][j] # Update result if area with current row (as last row) of rectangle) is more result = max(result, self.maxHist(A[i])) return result A = [[0, 1, 1, 0], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 0, 0]] ans = Solution() print(\u0026#34;Area of maximum rectangle is\u0026#34;, ans.maxRectangle(A)) Find a specific pair in matrix import sys # The function returns maximum value A(c,d) - A(a,b) over all choices of indexes such that both c \u0026gt; a and d \u0026gt; b. def findMaxValue(mat): # stores maximum value maxValue = -sys.maxsize -1 # maxArr[i][j] stores max of elements in matrix from (i, j) to (N-1, N-1) maxArr = [[0 for _ in range(N)] for _ in range(N)] # last element of maxArr will be same\u0026#39;s as of the input matrix maxArr[N - 1][N - 1] = mat[N - 1][N - 1] # preprocess last row maxv = mat[N - 1][N - 1] for j in range (N - 2, -1, -1): if (mat[N - 1][j] \u0026gt; maxv): maxv = mat[N - 1][j] maxArr[N - 1][j] = maxv # preprocess last column maxv = mat[N - 1][N - 1] # Initialize max for i in range (N - 2, -1, -1): if (mat[i][N - 1] \u0026gt; maxv): maxv = mat[i][N - 1] maxArr[i][N - 1] = maxv # preprocess rest of the matrix from bottom for i in range (N - 2, -1, -1): for j in range (N - 2, -1, -1): # Update maxValue if (maxArr[i + 1][j + 1] - mat[i][j] \u0026gt; maxValue): maxValue = (maxArr[i + 1][j + 1] - mat[i][j]) # set maxArr (i, j) maxArr[i][j] = max(mat[i][j], max(maxArr[i][j + 1], maxArr[i + 1][j])) return maxValue N = 5 mat = [[ 1, 2, -1, -4, -20 ], [-8, -3, 4, 2, 1 ], [ 3, 8, 6, 1, 3 ], [ -4, -1, 1, 7, -6] , [0, -4, 10, -5, 1 ]] print (\u0026#34;Maximum Value is\u0026#34;, findMaxValue(mat)) Rotate matrix by 90 degrees N = 4 def rotate90Clockwise(arr) : global N for j in range(N) : for i in range(N - 1, -1, -1) : print(arr[i][j], end = \u0026#34; \u0026#34;) print() # Driver code\tarr = [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ], [ 9, 10, 11, 12 ], [ 13, 14, 15, 16 ] ] rotate90Clockwise(arr); Kth smallest element in a row-column wise sorted matrix def kthSmallest(mat, n, k): a = [0 for _ in range(n*n)] v=0 for i in range(n): for j in range(n): a[v] = mat[i][j] v += 1 a.sort() return a[k - 1] mat = [ [ 10, 20, 30, 40 ], [ 15, 25, 35, 45 ], [ 25, 29, 37, 48 ], [ 32, 33, 39, 50 ] ] res = kthSmallest(mat, 4, 7) print(f\u0026#34;7th smallest element is {str(res)}\u0026#34;) Common elements in all rows of a given matrix def printCommonElements(mat): mp = {mat[0][j]: 1 for j in range(N)} # traverse the matrix for i in range(1, M): for j in range(N): # If element is present in the map and is not duplicated in current row. if mat[i][j] in mp and mp[mat[i][j]] == i: # we increment count of the element in map by 1 mp[mat[i][j]] = i + 1 # If this is last row if i == M - 1: print(mat[i][j], end = \u0026#34; \u0026#34;) # Specify number of rows and columns M = 4 N = 5 mat = [[1, 2, 1, 4, 8], [3, 7, 8, 5, 1], [8, 7, 7, 3, 1], [8, 1, 2, 7, 9]] printCommonElements(mat) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/matrix/","summary":"Spiral traversal on a Matrix Search an element in a matrix Find median in a row wise sorted matrix Find row with maximum no. of 1\u0026rsquo;s Print elements in sorted order using row-column wise sorted matrix Maximum size rectangle Find a specific pair in matrix Rotate matrix by 90 degrees Kth smallest element in a row-column wise sorted matrix Common elements in all rows of a given matrix Spiral traversal on a Matrix def spiralOrder(matrix): ans = [] if (len(matrix) == 0): return ans m = len(matrix) n = len(matrix[0]) seen = [[0 for _ in range(n)] for _ in range(m)] dr = [0, 1, 0, -1] dc = [1, 0, -1, 0] x = 0 y = 0 di = 0 # Iterate from 0 to R * C - 1 for _ in range(m * n): ans.","title":"DSA in Python - Matrix"},{"content":" Bubble Sort Selection Sort Insertion Sort Merge Sort Quick Sort Counting Sort Heap Sort Radix Sort Linear Search Binary Search Interpolation Search Find first and last positions of an element in a sorted array Find a Fixed Point (Value equal to index) in a given array Search in a rotated sorted array square root of an integer Find the repeating and the missing Searching in an array where adjacent differ by at most k find a pair with a given difference find two elements that sum to a given value - TwoSum find four elements that sum to a given value - ThreeSum find four elements that sum to a given value - FourSum maximum sum such that no 2 elements are adjacent Count triplet with sum smaller than a given value print all subarrays with 0 sum Product array Puzzle Sort array according to count of set bits minimum no. of swaps required to sort the array Find pivot element in a sorted array K-th Element of Two Sorted Arrays Aggressive cows Book Allocation Problem EKOSPOJ Missing Number in AP Smallest number with atleastn trailing zeroes infactorial ROTI-Prata SPOJ DoubleHelix SPOJ Subset Sums Implement Merge-sort in-place Bubble Sort def bubble_sort(array): n=len(array) for i in range(n): for j in range(n-i-1): if array[j] \u0026gt; array[j + 1]: array[j], array[j + 1] = array[j + 1], array[j] array=[5,2,3,1,4, -99, 0] bubble_sort(array) print(array) Selection Sort def selection_sort(array): global iterations iterations = 0 for i in range(len(array)): minimum_index = i for j in range(i + 1, len(array)): iterations += 1 if array[minimum_index] \u0026gt; array[j]: minimum_index = j # Swap the found minimum element with the first element if minimum_index != i: array[i], array[minimum_index] = array[minimum_index], array[i] array=[5,2,3,1,4, -99, 0] selection_sort(array) print(array) Insertion Sort def insertion_sort(array): global iterations iterations = 0 for i in range(1, len(array)): current_value = array[i] for j in range(i - 1, -1, -1): iterations += 1 if array[j] \u0026gt; current_value: array[j], array[j + 1] = array[j + 1], array[j] # swap else: array[j + 1] = current_value break array=[5,2,3,1,4, -99, 0] insertion_sort(array) print(array) Merge Sort def merge_sort(array): if len(array) \u0026lt; 2: return array mid = len(array) // 2 left = merge_sort(array[:mid]) right = merge_sort(array[mid:]) return merge(left, right) def merge(left, right): result = [] i, j = 0, 0 while i \u0026lt; len(left) or j \u0026lt; len(right): if left[i] \u0026lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 if i == len(left) or j == len(right): result.extend(left[i:] or right[j:]) break return result array=[5,2,3,1,4, -99, 0] print(merge_sort(array)) Quick Sort def partition(array, low, high): i = low - 1 # index of smaller element pivot = array[high] # pivot for j in range(low, high): # If current element is smaller than the pivot if array[j] \u0026lt; pivot: # increment index of smaller element i += 1 array[i], array[j] = array[j], array[i] array[i + 1], array[high] = array[high], array[i + 1] return i + 1 def quick_sort(array, low, high): if low \u0026lt; high: # pi is partitioning index, arr[p] is now at right place temp = partition(array, low, high) # Separately sort elements before partition and after partition quick_sort(array, low, temp - 1) quick_sort(array, temp + 1, high) array=[5,2,3,1,4, -99, 0] quick_sort(array, 0, len(array)-1) print(array) Counting Sort # Counting sort in Python programming def countingSort(array): size = len(array) output = [0] * size # Initialize count array count = [0] * 10 # Store the count of each elements in count array for i in range(size): count[array[i]] += 1 # Store the cummulative count for i in range(1, 10): count[i] += count[i - 1] # Find the index of each element of the original array in count array # place the elements in output array i = size - 1 while i \u0026gt;= 0: output[count[array[i]] - 1] = array[i] count[array[i]] -= 1 i -= 1 # Copy the sorted elements into original array for i in range(size): array[i] = output[i] array = [4,0,2, 2, 8, 3, 3, 1] countingSort(array) print(array) Heap Sort def heapify(nums, heap_size, root_index): # Assume the index of the largest element is the root index largest = root_index left_child = (2 * root_index) + 1 right_child = (2 * root_index) + 2 if left_child \u0026lt; heap_size and nums[left_child] \u0026gt; nums[largest]: largest = left_child if right_child \u0026lt; heap_size and nums[right_child] \u0026gt; nums[largest]: largest = right_child if largest != root_index: nums[root_index], nums[largest] = nums[largest], nums[root_index] # Heapify the new root element to ensure it\u0026#39;s the largest heapify(nums, heap_size, largest) def heap_sort(nums): n = len(nums) for i in range(n, -1, -1): heapify(nums, n, i) # Move the root of the max heap to the end of for i in range(n - 1, 0, -1): nums[i], nums[0] = nums[0], nums[i] heapify(nums, i, 0) random_list_of_nums = [35, 12, 43, 8, 51] heap_sort(random_list_of_nums) print(random_list_of_nums) Radix Sort from math import log10 from random import randint def get_num(num, base, pos): return (num // base ** pos) % base def prefix_sum(array): for i in range(1, len(array)): array[i] = array[i] + array[i-1] return array def radixsort(l, base=10): passes = int(log10(max(l))+1) output = [0] * len(l) for pos in range(passes): count = [0] * base for i in l: digit = get_num(i, base, pos) count[digit] +=1 count = prefix_sum(count) for i in reversed(l): digit = get_num(i, base, pos) count[digit] -= 1 new_pos = count[digit] output[new_pos] = i l = list(output) return output l = [randint(1, 99999) for _ in range(100)] sortedarr = radixsort(l) print(sortedarr) Linear Search def linearSearch(array, n, x): for i in range(n): if (array[i] == x): return i return -1 array = [2, 4, 0, 1, 9] x = 1 n = len(array) result = linearSearch(array, n, x) if(result == -1): print(\u0026#34;Element not found\u0026#34;) else: print(\u0026#34;Element found at index: \u0026#34;, result) Binary Search def binarySearch(array, x, low, high): while low \u0026lt;= high: mid = low + (high - low)//2 if array[mid] == x: return mid elif array[mid] \u0026lt; x: low = mid + 1 else: high = mid - 1 return -1 array = [3, 4, 5, 6, 7, 8, 9] x = 4 result = binarySearch(array, x, 0, len(array)-1) if result != -1: print(f\u0026#34;Element is present at index {str(result)}\u0026#34;) else: print(\u0026#34;Not found\u0026#34;) Interpolation Search # Function to determine if target exists in the sorted list `A` or not # using an interpolation search algorithm def interpolationSearch(A, target): if not A: return -1 (left, right) = (0, len(A) - 1) while A[right] != A[left] and A[left] \u0026lt;= target \u0026lt;= A[right]: mid = left + (target - A[left]) * (right - left) // (A[right] - A[left]) if target == A[mid]: return mid elif target \u0026lt; A[mid]: right = mid - 1 else: left = mid + 1 if target == A[left]: return left return -1 A = [2, 5, 6, 8, 9, 10] key = 5 index = interpolationSearch(A, key) if index != -1: print(\u0026#39;Element found at index\u0026#39;, index) else: print(\u0026#39;Element found not in the list\u0026#39;) Find first and last positions of an element in a sorted array def first(arr, x, n): low = 0 high = n - 1 res = -1 while (low \u0026lt;= high): mid = (low + high) // 2\tif arr[mid] \u0026gt; x: high = mid - 1 elif arr[mid] \u0026lt; x: low = mid + 1 else: res = mid high = mid - 1 return res # If x is present in arr[] then returns the index of FIRST occurrence of x in arr[0..n-1], otherwise returns -1 def last(arr, x, n): low = 0 high = n - 1 res = -1 while(low \u0026lt;= high): mid = (low + high) // 2 if arr[mid] \u0026gt; x: high = mid - 1 elif arr[mid] \u0026lt; x: low = mid + 1 else: res = mid low = mid + 1 return res arr = [ 1, 2, 2, 2, 2, 3, 4, 7, 8, 8 ] n = len(arr) x = 8 print(\u0026#34;First Occurrence =\u0026#34;, first(arr, x, n)) print(\u0026#34;Last Occurrence =\u0026#34;, last(arr, x, n)) Find a Fixed Point (Value equal to index) in a given array \u0026#34;\u0026#34;\u0026#34; Input: arr[] = {-10, -5, 0, 3, 7} Output: 3 // arr[3] == 3 Input: arr[] = {0, 2, 5, 8, 17} Output: 0 // arr[0] == 0 Input: arr[] = {-10, -5, 3, 4, 7, 9} Output: -1 // No Fixed Point \u0026#34;\u0026#34;\u0026#34; def binarySearch(arr, low, high): if high \u0026gt;= low : mid = low + (high - low)//2 if mid == arr[mid]: return mid res = -1 if mid + 1 \u0026lt;= arr[high]: res = binarySearch(arr, (mid + 1), high) if res !=-1: return res if mid-1 \u0026gt;= arr[low]: return binarySearch(arr, low, (mid -1)) return -1 arr = [-10, -1, 0, 3, 10, 11, 30, 50, 100] # NOTE: ARRAY WILL BE SORTED n = len(arr) print(f\u0026#34;Fixed Point is {str(binarySearch(arr, 0, n-1))}\u0026#34;) Search in a rotated sorted array def search(nums, target): low, high = 0, len(nums)-1 while low\u0026lt;=high: mid = low + ((high - low))//2 if nums[mid]==target: return mid elif nums[low] \u0026lt;= nums[mid]: if nums[low] \u0026lt;= target \u0026lt; nums[mid]: high = mid-1 else: low = mid+1 elif nums[mid] \u0026lt; target \u0026lt;= nums[high]: low = mid+1 else: high = mid-1 return -1 target=5 nums=[5,6,1,2,3,4] print(target, \u0026#34;found at index: \u0026#34;,search(nums,target)) square root of an integer def floorSqrt(x): if x in [0, 1]: return x i = 1 result = 1 while (result \u0026lt;= x): i += 1 result = i**2 return i - 1 x = 11 print(floorSqrt(x)) Find the repeating and the missing def missandrepeat():\tarr = [ 4, 3, 6, 2, 1, 1 ] numberMap = {} max = len(arr) for i in arr: if i not in numberMap: numberMap[i] = True else: print(\u0026#34;Repeating =\u0026#34;, i) for i in range(1, max + 1): if i not in numberMap: print(\u0026#34;Missing =\u0026#34;, i) missandrepeat() Searching in an array where adjacent differ by at most k \u0026#34;\u0026#34;\u0026#34; Input : arr[] = {4, 5, 6, 7, 6} k = 1 x = 6 Output : 2 The first index of 6 is 2. Input : arr[] = {20, 40, 50, 70, 70, 60} k = 20 x = 60 Output : 5 The index of 60 is 5 \u0026#34;\u0026#34;\u0026#34; def search(arr, n, x, k): # Traverse the given array starting from leftmost element i = 0 while (i \u0026lt; n): if (arr[i] == x): return i # Jump the difference between current array element and x divided by k # We use max here to make sure that i moves at-least one step ahead. i += max(1, int(abs(arr[i] - x) / k)) print(\u0026#34;number is not present!\u0026#34;) return -1 arr = [2, 4, 5, 7, 7, 6] x = 6 k = 2 n = len(arr) print(\u0026#34;Element\u0026#34;, x, \u0026#34;is present at index\u0026#34;,search(arr, n, x, k)) find a pair with a given difference \u0026#34;\u0026#34;\u0026#34; Input : arr[] = {4, 5, 6, 7, 6} k = 1 x = 6 Output : 2 The first index of 6 is 2. Input : arr[] = {20, 40, 50, 70, 70, 60} k = 20 x = 60 Output : 5 The index of 60 is 5 \u0026#34;\u0026#34;\u0026#34; def findPair(arr,n): size = len(arr) i,j = 0,1 while i \u0026lt; size and j \u0026lt; size: if i != j and arr[j]-arr[i] == n: print (f\u0026#34;Pair found ({arr[i]} ,{arr[j]})\u0026#34;) return True elif arr[j] - arr[i] \u0026lt; n: j+=1 else: i+=1 print (\u0026#34;No pair found\u0026#34;) return False arr = [1, 8, 30, 40, 100] n = 60 findPair(arr, n) find two elements that sum to a given value - TwoSum def findPair(nums, target): d = {} for i, e in enumerate(nums): if target - e in d: print(\u0026#39;Pair found\u0026#39;, (nums[d.get(target - e)], nums[i])) return d[e] = i print(\u0026#39;Pair not found\u0026#39;) nums = [8, 7, 2, 5, 3, 1] target = 10 findPair(nums, target) find four elements that sum to a given value - ThreeSum def isTripletExist(nums, target): d = {e: i for i, e in enumerate(nums)} for i in range(len(nums) - 1): for j in range(i + 1, len(nums)): val = target - (nums[i] + nums[j]) if val in d and d[val] not in [i, j]: return True return False nums = [2, 7, 4, 0, 9, 5, 1, 3] target = 6 if isTripletExist(nums, target): print(\u0026#39;Triplet exists\u0026#39;) else: print(\u0026#39;Triplet doesn\\\u0026#39;t exist\u0026#39;) find four elements that sum to a given value - FourSum def hasQuadruplet(nums, target): # create an empty dictionary # key —\u0026gt; target of a pair in the list # value —\u0026gt; list storing an index of every pair having that sum d = {} for i in range(len(nums) - 1): for j in range(i + 1, len(nums)): val = target - (nums[i] + nums[j]) if val in d: for pair in d[val]: x, y = pair if x not in [i, j] and y not in [i, j]: print(\u0026#39;Quadruplet Found\u0026#39;, (nums[i], nums[j], nums[x], nums[y])) return True d.setdefault(nums[i] + nums[j], []).append((i, j)) return False nums = [2, 7, 4, 0, 9, 5, 1, 3] target = 20 if not hasQuadruplet(nums, target): print(\u0026#39;Quadruplet doesn\\\u0026#39;t exist\u0026#39;) maximum sum such that no 2 elements are adjacent \u0026#34;\u0026#34;\u0026#34; Input: arr[] = {5, 5, 10, 100, 10, 5} Output: 110 Explanation: Pick the subsequence {5, 100, 5}. The sum is 110 and no two elements are adjacent. This is the highest possible sum. Input: arr[] = {3, 2, 7, 10} Output: 13 Explanation: The subsequence is {3, 10}. This gives sum = 13. This is the highest possible sum of a subsequence following the given criteria Input: arr[] = {3, 2, 5, 10, 7} Output: 15 Explanation: Pick the subsequence {3, 5, 7}. The sum is 15. \u0026#34;\u0026#34;\u0026#34; def findMaxSum(arr, n): incl = 0 excl = 0 for i in arr: new_excl = max (excl, incl) incl = excl + i excl = new_excl return max(excl, incl) arr = [5, 5, 10, 100, 10, 5] N = 6 print (findMaxSum(arr, N)) Count triplet with sum smaller than a given value def countTriplets(arr,n,sum): arr.sort() ans = 0 # Every iteration of loop counts triplet with first element as arr[i]. for i in range(n-2): # Initialize other two elements as corner elements of subarray arr[j+1..k] j = i + 1 k = n-1 while(j \u0026lt; k): # If sum of current triplet is more or equal, move right corner to look for smaller values if (arr[i]+arr[j]+arr[k] \u0026gt;=sum): k = k-1 # Else move left corner else: # This is important. For current i and j, there can be total k-j third elements. ans += (k - j) j = j+1 return ans arr = [5, 1, 3, 4, 7] n = len(arr) target = 12 print(countTriplets(arr, n, target)) print all subarrays with 0 sum def findSubArrays(arr,n): # create a python dict hashMap = {} # create a python list equivalent to ArrayList out = [] # tracker for sum of elements sum1 = 0 for i in range(n): sum1 += arr[i] if sum1 == 0: out.append((0, i)) al = [] if sum1 in hashMap: al = hashMap.get(sum1) for it in range(len(al)): out.append((al[it] + 1, i)) al.append(i) hashMap[sum1] = al return out def printOutput(output): for i in output: print(f\u0026#34;Subarray found from Index {str(i[0])} to {str(i[1])}\u0026#34;) arr = [6, 3, -1, -3, 4, -2, 2, 4, 6, -12, -7] n = len(arr) out = findSubArrays(arr, n) # if we did not find any subarray with 0 sum, then subarray does not exists if (len(out) == 0): print (\u0026#34;No subarray exists\u0026#34;) else: printOutput (out) Product array Puzzle \u0026#34;\u0026#34;\u0026#34; Given an array arr[] of n integers, construct a Product Array prod[] (of same size) such that prod[i] is equal to the product of all the elements of arr[] except arr[i]. Solve it without division operator and in O(n). Example: Input: arr[] = {10, 3, 5, 6, 2} Output: prod[] = {180, 600, 360, 300, 900} The elements of output array are {3*5*6*2, 10*5*6*2, 10*3*6*2, 10*3*5*2, 10*3*5*6} Input: arr[] = {1, 2, 1, 3, 4} Output: prod[] = {24, 12, 24, 8, 6} The elements of output array are {3*4*1*2, 1*1*3*4, 4*3*2*1, 1*1*4*2, 1*1*3*2} \u0026#34;\u0026#34;\u0026#34; def solve(arr, n): # Initialize a variable to store the total product of the array elements prod = 1 for i in arr: prod *= i # we know x / y mathematically is same as x*(y to power -1) for i in arr: print(int(prod*(i**-1)), end =\u0026#34; \u0026#34;) arr = [10, 3, 5, 6, 2] n = len(arr) solve(arr, n) Sort array according to count of set bits \u0026#34;\u0026#34;\u0026#34; Input: arr[] = {5, 2, 3, 9, 4, 6, 7, 15, 32}; Output: 15 7 5 3 9 6 2 4 32 Explanation: The integers in their binary representation are: 15 -1111 7 -0111 5 -0101 3 -0011 9 -1001 6 -0110 2 -0010 4- -0100 32 -10000 hence the non-increasing sorted order is: {15}, {7}, {5, 3, 9, 6}, {2, 4, 32} \u0026#34;\u0026#34;\u0026#34; def countSetBits(val): cnt = 0 while val: cnt += val % 2 val = val//2 return cnt # Using custom comparator lambda function arr = [1, 2, 3, 4, 5, 6] # form a tuple with val, index n = len(arr) arr = [(arr[i], i) for i in range(n)] # first criteria to sort is number of set bits, then the index sorted_arr = sorted(arr, key=lambda val: ( countSetBits(val[0]), n-val[1]), reverse=True) sorted_arr = [val[0] for val in sorted_arr] print(sorted_arr) minimum no. of swaps required to sort the array \u0026#34;\u0026#34;\u0026#34; Given an array of n distinct elements, find the minimum number of swaps required to sort the array. Input: {4, 3, 2, 1} Output: 2 Explanation: Swap index 0 with 3 and 1 with 2 to form the sorted array {1, 2, 3, 4}.\t\u0026#34;\u0026#34;\u0026#34; def minSwaps(arr, N): ans = 0 temp = arr.copy() temp.sort() for i in range(N): # This is checking whether the current element is at the right place or not if (arr[i] != temp[i]): ans += 1 # Swap the current element with the right index so that arr[0] to arr[i] is sorted swap(arr, i, indexOf(arr, temp[i])) return ans def swap(arr, i, j): arr[i], arr[j]= arr[j], arr[i] def indexOf(arr, ele): for i in range(len(arr)):\tif (arr[i] == ele): return i return -1 a = [101, 758, 315, 730, 472, 619, 460, 479] n = len(a) print(minSwaps(a, n)) Find pivot element in a sorted array def findPivot(arr, left, right): if right\u0026lt; left: return -1 if right == left: return left mid = (left+right)//2 if mid\u0026lt;right and arr[mid]\u0026gt;arr[mid+1]: return mid if mid\u0026gt;left and arr[mid]\u0026lt;arr[mid-1]: return mid-1 if arr[left]\u0026lt;arr[mid]: return findPivot(arr, mid+1, right) else: return findPivot(arr, left, mid-1) arr=[14, 23, 7, 9, 3, 6, 18, 22, 16, 36] start=0 n=len(arr)-1 pivot=findPivot(arr, start, n) pivot+=1 # pivot is the index of the first element in the right subarray print(f\u0026#39;Pivot is {arr[pivot]}\u0026#39;) K-th Element of Two Sorted Arrays \u0026#34;\u0026#34;\u0026#34;Given two sorted arrays of size m and n respectively, you are tasked with finding the element that would be at the k’th position of the final sorted array. Examples: Input : Array 1 - 2 3 6 7 9 Array 2 - 1 4 8 10 k = 5 Output : 6 Explanation: The final sorted array would be - 1, 2, 3, 4, 6, 7, 8, 9, 10 The 5th element of this array is 6. \u0026#34;\u0026#34;\u0026#34; def find(A, B, m, n, k_req): i, j, k = 0, 0, 0 # Keep taking smaller of the current elements of two sorted arrays and keep incrementing k while i \u0026lt; len(A) and j \u0026lt; len(B): k += 1 if A[i] \u0026lt; B[j]: if k == k_req: return A[i] i += 1 elif k == k_req: return B[j] else: j += 1 # If array B[] is completely traversed while i \u0026lt; len(A): k += 1 if k == k_req: return A[i] i += 1 # If array A[] is completely traversed while j \u0026lt; len(B): k += 1 if k == k_req: return B[j] j += 1 A = [2, 3, 6, 7, 9] B = [1, 4, 8, 10] k = 5; print(find(A, B, 5, 4, k)) Aggressive cows \u0026#34;\u0026#34;\u0026#34; Problem Statement: There is a new barn with N stalls and C cows. The stalls are located on a straight line at positions x1,….,xN (0 \u0026lt;= xi \u0026lt;= 1,000,000,000). We want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance? Examples: Input: No of stalls = 5 Array: {1,2,8,4,9} And number of cows: 3 Output: One integer, the largest minimum distance 3 \u0026#34;\u0026#34;\u0026#34; def isPossible(a, n, cows, mid): CntCows = 1 lastPlacedCow=a[0] for i in range(1, n): if a[i] -lastPlacedCow \u0026gt;= mid: CntCows+=1 lastPlacedCow=a[i] return CntCows \u0026gt;= cows n = 5 cows = 3; a=[1,2,8,4,9] a.sort() low = 1 high = a[n - 1] - a[0] while low\u0026lt; high: mid = (low + high)//2 if isPossible(a, n, cows, mid): low=mid+1 else: high=mid-1 print(f\u0026#39;Largest minimum distance is: {high}\u0026#39;) Book Allocation Problem \u0026#34;\u0026#34;\u0026#34; Given number of pages in n different books and m students. The books are arranged in ascending order of number of pages. Every student is assigned to read some consecutive books. The task is to assign books in such a way that the maximum number of pages assigned to a student is minimum. Example : Input : pages[] = {12, 34, 67, 90} , m = 2 Output : 113 Explanation: There are 2 number of students. Books can be distributed in following fashion : 1) [12] and [34, 67, 90] Max number of pages is allocated to student \u0026#39;2\u0026#39; with 34 + 67 + 90 = 191 pages 2) [12, 34] and [67, 90] Max number of pages is allocated to student \u0026#39;2\u0026#39; with 67 + 90 = 157 pages 3) [12, 34, 67] and [90] Max number of pages is allocated to student \u0026#39;1\u0026#39; with 12 + 34 + 67 = 113 pages Of the 3 cases, Option 3 has the minimum pages = 113. \u0026#34;\u0026#34;\u0026#34; def isPossible(arr, n, m, curr_min): studentsRequired = 1 curr_sum = 0 for i in range(n): # check if current number of pages are greater than curr_min that means we will get the result after mid no. of pages if (arr[i] \u0026gt; curr_min): return False # count how many students are required to distribute curr_min pages if (curr_sum + arr[i] \u0026gt; curr_min): # increment student count studentsRequired += 1 # update curr_sum curr_sum = arr[i] # if students required becomes greater than given no. of students, return False if (studentsRequired \u0026gt; m): return False # else update curr_sum else: curr_sum += arr[i] return True # function to find minimum pages def findPages(arr, n, m): # return -1 if no. of books is less than no. of students if (n \u0026lt; m): return -1 mysum = sum(arr[i] for i in range(n)) # initialize start as 0 pages and end as total pages start, end = 0, mysum result = 10**9 # traverse until start \u0026lt;= end while (start \u0026lt;= end): # check if it is possible to distribute books by using mid as current minimum mid = (start + end) // 2 if (isPossible(arr, n, m, mid)): # update result to current distribution as it\u0026#39;s the best we have found till now. result = mid # as we are finding minimum and books are sorted so reduce end = mid -1 that means end = mid - 1 else: # if not possible means pages should be increased so update start = mid + 1 start = mid + 1 # at-last return minimum no. of pages return result arr = [12, 34, 67, 90] # Number of pages in books n = len(arr) m = 2 # No. of students print(\u0026#34;Minimum number of pages = \u0026#34;,findPages(arr, n, m)) EKOSPOJ TODO Missing Number in AP \u0026#34;\u0026#34;\u0026#34; Given an array that represents elements of arithmetic progression in order. One element is missing in the progression, find the missing number. Examples: Input: arr[] = {2, 4, 8, 10, 12, 14} Output: 6 Input: arr[] = {1, 6, 11, 16, 21, 31}; Output: 26 \u0026#34;\u0026#34;\u0026#34; def find_missing(arr, n): first = arr[0] last = arr[-1] if (first + last) % 2: s = (n + 1) / 2 s *= (first + last) else: s = (first + last) / 2 s *= (n + 1) return s - sum(arr) arr = [2, 4, 8, 10, 12, 14] n = len(arr) missing = find_missing(arr, n) print(missing) Smallest number with atleastn trailing zeroes infactorial \u0026#34;\u0026#34;\u0026#34; Given a number n. The task is to find the smallest number whose factorial contains at least n trailing zeroes. Examples : Input : n = 1 Output : 5 1!, 2!, 3!, 4! does not contain trailing zero. 5! = 120, which contains one trailing zero. Input : n = 6 Output : 25 \u0026#34;\u0026#34;\u0026#34; def check(p,n): temp = p count = 0 f = 5 while (f \u0026lt;= temp): count += temp//f f *= 5 return (count \u0026gt;= n) # Return smallest number whose factorial contains at least n trailing zeroes def findNum(n): # If n equal to 1, return 5. since 5! = 120. if (n==1): return 5 # Initializing low and high for binary search. low = 0 high = 5*n while (low \u0026lt;high): mid = (low + high) \u0026gt;\u0026gt; 1 # Checking if mid\u0026#39;s factorial contains n trailing zeroes. if (check(mid, n)): high = mid else: low = mid+1 return low n = 6 print(findNum(n)) ROTI-Prata SPOJ TODO DoubleHelix SPOJ TODO Subset Sums \u0026#34;\u0026#34;\u0026#34; Given an array of integers, print sums of all subsets in it. Output sums can be printed in any order. Examples : Input : arr[] = {2, 3} Output: 0 2 3 5 Input : arr[] = {2, 4, 5} Output : 0 2 4 5 6 7 9 11 \u0026#34;\u0026#34;\u0026#34; def subsetSums(arr, l, r, sum=0): # Print current subset if l \u0026gt; r: print(sum, end=\u0026#34; \u0026#34;) return # Subset including arr[l] subsetSums(arr, l + 1, r, sum + arr[l]) # Subset excluding arr[l] subsetSums(arr, l + 1, r, sum) arr = [5, 4, 3] n = len(arr) subsetSums(arr, 0, n - 1) Implement Merge-sort in-place \u0026#34;\u0026#34;\u0026#34; NOTE: TIME COMPLEXITY IS HIGHER THAN STANDARD MERGE SORT BUT SPACE COMPLEXITY IS O(1) \u0026#34;\u0026#34;\u0026#34; def merge(arr, start, mid, end): start2 = mid + 1 # If the direct merge is already sorted if (arr[mid] \u0026lt;= arr[start2]): return # Two pointers to maintain start of both arrays to merge while (start \u0026lt;= mid and start2 \u0026lt;= end): # If element 1 is in right place if arr[start] \u0026gt; arr[start2]: value = arr[start2] index = start2 # Shift all the elements between element 1 element 2, right by 1. while (index != start): arr[index] = arr[index - 1] index -= 1 arr[start] = value mid += 1 start2 += 1 start += 1 def mergeSort(arr, l, r): if (l \u0026lt; r): # Same as (l + r) / 2, but avoids overflow for large l and r m = l + (r - l) // 2 # Sort first and second halves mergeSort(arr, l, m) mergeSort(arr, m + 1, r) merge(arr, l, m, r) arr = [12, 11, 13, 5, 6, 7] arr_size = len(arr) mergeSort(arr, 0, arr_size - 1) print(arr) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/search-and-sort/","summary":"Bubble Sort Selection Sort Insertion Sort Merge Sort Quick Sort Counting Sort Heap Sort Radix Sort Linear Search Binary Search Interpolation Search Find first and last positions of an element in a sorted array Find a Fixed Point (Value equal to index) in a given array Search in a rotated sorted array square root of an integer Find the repeating and the missing Searching in an array where adjacent differ by at most k find a pair with a given difference find two elements that sum to a given value - TwoSum find four elements that sum to a given value - ThreeSum find four elements that sum to a given value - FourSum maximum sum such that no 2 elements are adjacent Count triplet with sum smaller than a given value print all subarrays with 0 sum Product array Puzzle Sort array according to count of set bits minimum no.","title":"DSA in Python - Search and Sort"},{"content":" Implement Stack from Scratch Implement Queue from Scratch Implement 2 stack in an array find the middle element of a stack Implement \u0026ldquo;N\u0026rdquo; stacks in an Array Check the expression has valid or Balanced parenthesis or not. Reverse a String using Stack Design a Stack that supports getMin() in O(1) time and O(1) extra space. Find the next Greater element The celebrity Problem Evaluation of Postfix expression Reverse a stack using recursion Sort a Stack using recursion Merge Overlapping Intervals Largest rectangular Area in Histogram Length of the Longest Valid Substring Expression contains redundant bracket or not Implement Stack using Queue Implement Stack using Deque Stack Permutations (Check if an array is stack permutation of other) Implement Queue using Stack Implement \u0026ldquo;n\u0026rdquo; queue in an array Implement a Circular queue LRU Cache Implementation Reverse a Queue using recursion Reverse the first “K” elements of a queue Interleave the first half of the queue with second half Find the first circular tour that visits all Petrol Pumps Minimum time required to rot all oranges Distance of nearest cell having 1 in a binary matrix First negative integer in every window of size “k” Check if all levels of two trees are anagrams or not. Sum of minimum and maximum elements of all subarrays of size “k”. Minimum sum of squares of character counts in a given string after removing “k” characters. Next Smaller Element Implement Stack from Scratch class Stack: def __init__(self, size): self.arr = [None] * size self.capacity = size self.top = -1 def push(self, val): if self.isFull(): print(\u0026#39;Stack Overflow!! Calling exit()…\u0026#39;) exit(-1) print(f\u0026#39;Inserting {val} into the stack…\u0026#39;) self.top = self.top + 1 self.arr[self.top] = val def pop(self): if self.isEmpty(): print(\u0026#39;Stack Underflow!! Calling exit()…\u0026#39;) exit(-1) print(f\u0026#39;Removing {self.peek()} from the stack\u0026#39;) # decrease stack size by 1 and (optionally) return the popped element top = self.arr[self.top] self.top = self.top - 1 return top def peek(self): if self.isEmpty(): exit(-1) return self.arr[self.top] def size(self): return self.top + 1 def isEmpty(self): return self.size() == 0 def isFull(self): return self.size() == self.capacity stack = Stack(3) stack.push(1) # Inserting 1 in the stack stack.push(2) # Inserting 2 in the stack stack.pop() # removing the top element (2) stack.pop() # removing the top element (1) stack.push(3) # Inserting 3 in the stack print(\u0026#39;Top element is\u0026#39;, stack.peek()) print(\u0026#39;The stack size is\u0026#39;, stack.size()) stack.pop() # removing the top element (3) if stack.isEmpty(): print(\u0026#39;The stack is empty\u0026#39;) else: print(\u0026#39;The stack is not empty\u0026#39;) Implement Queue from Scratch class Queue: def __init__(self, size=1000): self.q = [None] * size # list to store queue elements self.capacity = size # maximum capacity of the queue self.front = 0 # front points to the front element in the queue self.rear = -1 # rear points to the last element in the queue self.count = 0 # current size of the queue def dequeue(self): # check for queue underflow if self.isEmpty(): print(\u0026#39;Queue Underflow!! Terminating process.\u0026#39;) exit(-1) x = self.q[self.front] print(\u0026#39;Removing element…\u0026#39;, x) self.front = (self.front + 1) % self.capacity self.count = self.count - 1 return x def enqueue(self, value): # check for queue overflow if self.isFull(): print(\u0026#39;Overflow!! Terminating process.\u0026#39;) exit(-1) print(\u0026#39;Inserting element…\u0026#39;, value) self.rear = (self.rear + 1) % self.capacity self.q[self.rear] = value self.count = self.count + 1 def peek(self): if self.isEmpty(): print(\u0026#39;Queue UnderFlow!! Terminating process.\u0026#39;) exit(-1) return self.q[self.front] def size(self): return self.count def isEmpty(self): return self.size() == 0 def isFull(self): return self.size() == self.capacity # create a queue of capacity 5 q = Queue(5) q.enqueue(1) q.enqueue(2) q.enqueue(3) print(\u0026#39;The queue size is\u0026#39;, q.size()) print(\u0026#39;The front element is\u0026#39;, q.peek()) q.dequeue() print(\u0026#39;The front element is\u0026#39;, q.peek()) q.dequeue() q.dequeue() if q.isEmpty(): print(\u0026#39;The queue is empty\u0026#39;) else: print(\u0026#39;The queue is not empty\u0026#39;) Implement 2 stack in an array class Stack: # Constructor def __init__(self, n): self.capacity = n self.A = [None] * n self.top1 = -1 self.top2 = n # Function to insert a given element into the first stack def push_first(self, key): # check if the list is full if self.top1 + 1 == self.top2: print(\u0026#39;Stack Overflow\u0026#39;) exit(-1) self.top1 = self.top1 + 1 self.A[self.top1] = key # Function to insert a given element into the second stack def push_second(self, key): # check if the list is full if self.top1 + 1 == self.top2: print(\u0026#39;Stack Overflow\u0026#39;) exit(-1) self.top2 = self.top2 - 1 self.A[self.top2] = key # Function to pop an element from the first stack def pop_first(self): # if no elements are left in the list if self.top1 \u0026lt; 0: print(\u0026#39;Stack Underflow\u0026#39;) exit(-1) top = self.A[self.top1] self.top1 = self.top1 - 1 return top # Function to pop an element from the second stack def pop_second(self): # if no elements are left in the list if self.top2 \u0026gt;= self.capacity: print(\u0026#39;Stack Underflow\u0026#39;) exit(-1) top = self.A[self.top2] self.top2 = self.top2 + 1 return top first = [1, 2, 3, 4, 5] second = [6, 7, 8, 9, 10] stack = Stack(len(first) + len(second)) [stack.push_first(i) for i in first] [stack.push_second(j) for j in second] print(\u0026#39;Popping element from the first stack:\u0026#39;, stack.pop_first()) print(\u0026#39;Popping element from the second stack:\u0026#39;, stack.pop_second()) find the middle element of a stack # Recursive function to find the peak element in a list def findPeak(nums, left=None, right=None): # Initialize left and right if left is None and right is None: left, right = 0, len(nums) - 1 # find the middle element. To avoid overflow, use mid = left + (right - left) / 2 mid = (left + right) // 2 # check if the middle element is greater than its neighbors if ((mid == 0 or nums[mid - 1] \u0026lt;= nums[mid]) and (mid == len(nums) - 1 or nums[mid + 1] \u0026lt;= nums[mid])): return mid def findMiddleElement(nums): if not nums: exit(-1) index = findPeak(nums) return nums[index] nums = [8, 9, 10, 11, 2, 5, 6] print(\u0026#39;The middle element is\u0026#39;, findPeakElement(nums)) Implement \u0026ldquo;N\u0026rdquo; stacks in an Array class KStacks:\tdef __init__(self, k, n): self.k = k # Number of stacks. self.n = n # Total size of array holding all the \u0026#39;k\u0026#39; stacks. # Array which holds \u0026#39;k\u0026#39; stacks. self.arr = [0] * self.n # All stacks are empty to begin with (-1 denotes stack is empty). self.top = [-1] * self.k # Top of the free stack. self.free = 0 # Points to the next element in either 1. One of the \u0026#39;k\u0026#39; stacks or, 2. The \u0026#39;free\u0026#39; stack. self.next = [i + 1 for i in range(self.n)] self.next[self.n - 1] = -1 # Check whether given stack is empty. def isEmpty(self, sn): return self.top[sn] == -1 # Check whether there is space left for pushing new elements or not. def isFull(self): return self.free == -1 # Push \u0026#39;item\u0026#39; onto given stack number \u0026#39;sn\u0026#39;. def push(self, item, sn): if self.isFull(): print(\u0026#34;Stack Overflow\u0026#34;) return # Get the first free position to insert at. insert_at = self.free # Adjust the free position. self.free = self.next[self.free] # Insert the item at the free position we obtained above. self.arr[insert_at] = item # Adjust next to point to the old top of stack element. self.next[insert_at] = self.top[sn] # Set the new top of the stack. self.top[sn] = insert_at # Pop item from given stack number \u0026#39;sn\u0026#39;. def pop(self, sn): if self.isEmpty(sn): return None # Get the item at the top of the stack. top_of_stack = self.top[sn] # Set new top of stack. self.top[sn] = self.next[self.top[sn]] # Push the old top_of_stack to the \u0026#39;free\u0026#39; stack. self.next[top_of_stack] = self.free self.free = top_of_stack return self.arr[top_of_stack] def printstack(self, sn): top_index = self.top[sn] while (top_index != -1): print(self.arr[top_index]) top_index = self.next[top_index] # Create 3 stacks using an array of size 10. kstacks = KStacks(3, 10) # Push some items onto stack number 2. kstacks.push(15, 2) kstacks.push(45, 2) # Push some items onto stack number 1. kstacks.push(17, 1) kstacks.push(49, 1) kstacks.push(39, 1) # Push some items onto stack number 0. kstacks.push(11, 0) kstacks.push(9, 0) kstacks.push(7, 0) print(f\u0026#34;Popped element from stack 2 is {str(kstacks.pop(2))}\u0026#34;) print(f\u0026#34;Popped element from stack 1 is {str(kstacks.pop(1))}\u0026#34;) print(f\u0026#34;Popped element from stack 0 is {str(kstacks.pop(0))}\u0026#34;) kstacks.printstack(0) Check the expression has valid or Balanced parenthesis or not. from collections import deque def isBalanced(exp): if not exp or len(exp) \u0026amp; 1: return False # take an empty stack of characters stack = deque() # traverse the input expression for ch in exp: # if the current character in the expression is an opening brace, push the corresponding closing brace into the stack. if ch == \u0026#39;(\u0026#39;: stack.append(\u0026#39;)\u0026#39;) elif ch == \u0026#39;{\u0026#39;: stack.append(\u0026#39;}\u0026#39;) elif ch == \u0026#39;[\u0026#39;: stack.append(\u0026#39;]\u0026#39;) # return false if the popped character is not the same as the current character elif not stack or stack.pop() != ch: return False # the expression is only balanced if the stack is empty at this point return not stack exp = \u0026#39;{()}[{}]\u0026#39; if isBalanced(exp): print(\u0026#39;The expression is balanced\u0026#39;) else: print(\u0026#39;The expression is not balanced\u0026#39;) Reverse a String using Stack from collections import deque def reverse(s): stack = deque(s) return \u0026#39;\u0026#39;.join(stack.pop() for _ in range(len(s))) s = \u0026#39;Reverse me\u0026#39; s = reverse(s) print(s) Design a Stack that supports getMin() in O(1) time and O(1) extra space. class stack: def __init__(self): self.array = [] self.top = -1 self.max = 100 def isEmpty(self): return self.top == -1 def isFull(self): return self.top == self.max - 1 def push(self, data): if self.isFull(): print(\u0026#39;Stack OverFlow\u0026#39;) return else: self.top += 1 self.array.append(data) def pop(self): if self.isEmpty(): print(\u0026#39;Stack UnderFlow\u0026#39;) return else: self.top -= 1 return self.array.pop() # A class that supports all the stack operations and one additional operation getMin() that returns the minimum element from stack at any time. This class inherits from the stack class and uses an auxiliary stack that holds minimum elements class SpecialStack(stack): def __init__(self): super().__init__() self.Min = stack() def push(self, x): if self.isEmpty(): super().push(x) self.Min.push(x) else: super().push(x) y = self.Min.pop() self.Min.push(y) if x \u0026lt;= y: self.Min.push(x) else: self.Min.push(y) def pop(self): x = super().pop() self.Min.pop() return x def getmin(self): x = self.Min.pop() self.Min.push(x) return x s = SpecialStack() s.push(10) s.push(20) s.push(30) print(s.getmin()) s.push(5) print(s.getmin()) Find the next Greater element from collections import deque def findNextGreaterElements(arr): if not arr: return result = [-1] * len(arr) s = deque() for i in range(len(arr)): # loop till we have a greater element on top or stack becomes empty. Keep popping elements from the stack smaller than the current element, and set their next greater element to the current element while s and arr[s[-1]] \u0026lt; arr[i]: result[s[-1]] = arr[i] s.pop() # push current \u0026#34;index\u0026#34; into the stack s.append(i) return result arr = [2, 7, 3, 5, 4, 6, 8] print(findNextGreaterElements(arr)) The celebrity Problem \u0026#34;\u0026#34;\u0026#34; In a party of N people, only one person is known to everyone. Such a person may be present in the party, if yes, (s)he doesn’t know anyone in the party. We can only ask questions like “does A know B? “. Find the stranger (celebrity) in the minimum number of questions. We can describe the problem input as an array of numbers/characters representing persons in the party. We also have a hypothetical function HaveAcquaintance(A, B) which returns true if A knows B, false otherwise. How can we solve the problem. Examples: Input: MATRIX = { {0, 0, 1, 0}, {0, 0, 1, 0}, {0, 0, 0, 0}, {0, 0, 1, 0} } Output:id = 2 Explanation: The person with ID 2 does not know anyone but everyone knows him Input: MATRIX = { {0, 0, 1, 0}, {0, 0, 1, 0}, {0, 1, 0, 0}, {0, 0, 1, 0} } Output: No celebrity Explanation: There is no celebrity. \u0026#34;\u0026#34;\u0026#34; # Max # of persons in the party N = 8 # Person with 2 is celebrity MATRIX = [ [ 0, 0, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 1, 0 ] ] def knows(a, b): return MATRIX[a][b] def findCelebrity(n): # Handle trivial case of size = 2 s = list(range(n)) # Find a potential celebrity while (len(s) \u0026gt; 1): # Pop out the first two elements from stack A = s.pop() B = s.pop() # if A knows B, we find that B might be the celebrity and vice versa if (knows(A, B)): s.append(B) else: s.append(A) # If there are only two people and there is no potential candidate if not s: return -1 # Potential candidate? C = s.pop(); # Last candidate was not examined, it leads one excess comparison (optimize) if (knows(C, B)): C = B if (knows(C, A)): C = A # Check if C is actually a celebrity or not for i in range(n): # If any person doesn\u0026#39;t know \u0026#39;a\u0026#39; or \u0026#39;a\u0026#39; doesn\u0026#39;t know any person, return -1 if ((i != C) and (knows(C, i) or not(knows(i, C)))): return -1 return C n = 4 id_ = findCelebrity(n) if id_ == -1: print(\u0026#34;No celebrity\u0026#34;) else: print(\u0026#34;Celebrity ID \u0026#34;, id_) Evaluation of Postfix expression from collections import deque def evalPostfix(exp): if not exp: exit(-1) stack = deque() for ch in exp: # if the current is an operand, push it into the stack if ch.isdigit(): stack.append(int(ch)) # if the current is an operator else: # remove the top two elements from the stack x = stack.pop() y = stack.pop() # evaluate the expression \u0026#39;x op y\u0026#39;, and push the result back to the stack if ch == \u0026#39;+\u0026#39;: stack.append(y + x) elif ch == \u0026#39;-\u0026#39;: stack.append(y - x) elif ch == \u0026#39;*\u0026#39;: stack.append(y * x) elif ch == \u0026#39;/\u0026#39;: stack.append(y // x) # At this point, the stack is left with only one element, i.e., expression result return stack.pop() exp = \u0026#39;138*+\u0026#39; print(evalPostfix(exp)) Reverse a stack using recursion from collections import deque def insertAtBottom(s, item): # base case: if the stack is empty, insert the given item at the bottom if not s: s.append(item) return # Pop all items from the stack and hold them in the call stack top = s.pop() insertAtBottom(s, item) # After the recursion unfolds, push each item in the call stack at the top of the stack s.append(top) def reverseStack(s): if not s: return item = s.pop() reverseStack(s) insertAtBottom(s, item) s = deque(range(1, 6)) print(\u0026#39;Original stack is\u0026#39;, s) reverseStack(s) print(\u0026#39;Reversed stack is\u0026#39;, s) Sort a Stack using recursion from collections import deque def sortedInsert(stack, key): # base case: if the stack is empty or the key is greater than all elements in the stack if not stack or key \u0026gt; stack[-1]: stack.append(key) return \u0026#39;\u0026#39;\u0026#39; We reach here when the key is smaller than the top element \u0026#39;\u0026#39;\u0026#39; top = stack.pop() sortedInsert(stack, key) stack.append(top) def sortStack(stack): if not stack: return top = stack.pop() sortStack(stack) sortedInsert(stack, top) A = [5, -2, 9, -7, 3] stack = deque(A) print(\u0026#39;Stack before sorting:\u0026#39;, list(stack)) sortStack(stack) print(\u0026#39;Stack after sorting:\u0026#39;, list(stack)) Merge Overlapping Intervals \u0026#34;\u0026#34;\u0026#34; Consider an event where a log register is maintained containing the guest’s arrival and departure times. Given an array of arrival and departure times from entries in the log register, find the point when there were maximum guests present in the event. Note that if an arrival and departure event coincides, the arrival time is preferred over the departure time. For example, Input: arrival = { 1, 2, 4, 7, 8, 12 } departure = { 2, 7, 8, 12, 10, 15 } Output: Maximum number of guests is 3, present at time 7 \u0026#34;\u0026#34;\u0026#34; def findMaxGuests(arrival, departure): # Find the time when the last guest leaves the event t = max(departure) # create a count array initialized by 0 count = [0] * (t + 2) for i in range(len(arrival)): count[arrival[i]] += 1 count[departure[i] + 1] -= 1 # keep track of the time when there are maximum guests max_event_tm = count[0] # perform a prefix sum computation to determine the guest count at each point for i in range(1, t + 1): count[i] += count[i - 1] if count[max_event_tm] \u0026lt; count[i]: max_event_tm = i print(\u0026#34;Event Time:\u0026#34;, max_event_tm) print(\u0026#34;The maximum number of guests is\u0026#34;, count[max_event_tm]) arrival = [1, 2, 4, 7, 8, 12] departure = [2, 7, 8, 12, 10, 15] findMaxGuests(arrival, departure) Largest rectangular Area in Histogram \u0026#34;\u0026#34;\u0026#34; ind the largest rectangular area possible in a given histogram where the largest rectangle can be made of a number of contiguous bars. For simplicity, assume that all bars have same width and the width is 1 unit. For example, consider the following histogram with 7 bars of heights {6, 2, 5, 4, 5, 1, 6}. The largest possible rectangle possible is 12 (see the below figure, the max area rectangle is highlighted in red) \u0026#34;\u0026#34;\u0026#34; def getMaxArea(arr): s = [-1] n = len(arr) area = 0 left_smaller = [-1]*n right_smaller = [n]*n for i in range(n): while s and (s[-1] != -1) and (arr[s[-1]] \u0026gt; arr[i]): right_smaller[s[-1]] = i s.pop() if((i \u0026gt; 0) and (arr[i] == arr[i-1])): left_smaller[i] = left_smaller[i-1] else: left_smaller[i] = s[-1] s.append(i) for j in range(n): area = max(area, arr[j]*(right_smaller[j]-left_smaller[j]-1)) return area hist = [6, 2, 5, 4, 5, 1, 6] print(\u0026#34;maxArea = \u0026#34;, getMaxArea(hist)) Length of the Longest Valid Substring from collections import deque def findMaxLen(s): if not s: return 0 # create a stack of integers for storing an index of parenthesis in the string stack = deque() # initialize the stack by -1 stack.append(-1) # stores the length of the longest balanced parenthesis length = 0 # iterate over the characters of the string for i, e in enumerate(s): # if the current character is an opening parenthesis, push its index in the stack if e == \u0026#39;(\u0026#39;: stack.append(i) # if the current character is a closing parenthesis else: # pop the top index from the stack stack.pop() # if the stack becomes empty, push the current index into the stack if not stack: stack.append(i) continue # get the length of the longest balanced parenthesis ending at the current character curr_len = i - stack[-1] # update the length of the longest balanced parenthesis if length \u0026lt; curr_len: length = curr_len return length print(findMaxLen(\u0026#39;((()()\u0026#39;)) # prints 4 print(findMaxLen(\u0026#39;(((()\u0026#39;)) # prints 2 print(findMaxLen(\u0026#39;((((\u0026#39;)) # prints 0 print(findMaxLen(\u0026#39;()()\u0026#39;)) # prints 4 print(findMaxLen(\u0026#39;(()())(()\u0026#39;)) # prints 6 Expression contains redundant bracket or not from collections import deque def hasDuplicateParenthesis(exp): if not exp or len(exp) \u0026lt;= 3: return False stack = deque() # traverse the input expression for c in exp: # if the current char in the expression is not a closing parenthesis if c != \u0026#39;)\u0026#39;: stack.append(c) # if the current char in the expression is a closing parenthesis else: # if the stack\u0026#39;s top element is an opening parenthesis, the subexpression of the form ((exp)) is found if stack[-1] == \u0026#39;(\u0026#39;: return True # pop till \u0026#39;(\u0026#39; is found for current \u0026#39;)\u0026#39; while stack[-1] != \u0026#39;(\u0026#39;: stack.pop() # pop \u0026#39;(\u0026#39; stack.pop() # if we reach here, then the expression does not have any duplicate parenthesis return False exp = \u0026#39;((x+y))\u0026#39; # assumes valid expression if hasDuplicateParenthesis(exp): print(\u0026#39;The expression has duplicate parenthesis.\u0026#39;) else: print(\u0026#39;The expression does not have duplicate parenthesis\u0026#39;) Implement Stack using Queue from collections import deque class Stack: def __init__(self): self.q1 = deque() self.q2 = deque() # Insert an item into the stack def add(self, data): # Move all elements from the first queue to the second queue while len(self.q1): self.q2.append(self.q1.pop()) # Push the given item into the first queue self.q1.append(data) # Move all elements back to the first queue from the second queue while len(self.q2): self.q1.append(self.q2.pop()) def pop(self): # if the first queue is empty if not self.q1: print(\u0026#39;Underflow!!\u0026#39;) exit(0) front = self.q1.popleft() return front keys = [1, 2, 3, 4, 5] s = Stack() for key in keys: s.add(key) while s: print(s.pop()) print(s.pop()) Implement Stack using Deque from collections import deque class Stack: def __init__(self): self.q1 = deque() self.q2 = deque() # Insert an item into the stack def add(self, data): self.q1.append(data) # Remove the top item from the stack def poll(self): # if the first queue is empty if not self.q1: print(\u0026#39;Stack Underflow!!\u0026#39;) exit(0) # Move all elements except last from the first queue to the second queue front = None while self.q1: if len(self.q1) == 1: front = self.q1.popleft() else: self.q2.append(self.q1.popleft()) # Return the last element after moving all elements back to the first queue. while self.q2: self.q1.append(self.q2.popleft()) return front keys = [1, 2, 3, 4, 5] s = Stack() for key in keys: s.add(key) while s: print(s.poll()) Stack Permutations (Check if an array is stack permutation of other) \u0026#34;\u0026#34;\u0026#34; Given two arrays, both of unique elements. One represents the input queue and the other represents the output queue. Our task is to check if the given output is possible through stack permutation. Examples: Input : First array: 1, 2, 3 Second array: 2, 1, 3 Output : Yes Procedure: push 1 from input to stack push 2 from input to stack pop 2 from stack to output pop 1 from stack to output push 3 from input to stack pop 3 from stack to output Input : First array: 1, 2, 3 Second array: 3, 1, 2 Output : Not Possible \u0026#34;\u0026#34;\u0026#34; def checkStackPermutation(ip, op, n): # we will be appending elements from input array to stack uptill top of our stack matches with first element of output array s = [] # will maintain a variable j to iterate on output array j = 0 # will iterate one by one in input array for i in range(n): # appended an element from input array to stack s.append(ip[i]) # if our stack isn\u0026#39;t empty and top matches with output array then we will keep popping out from stack uptill top matches with output array while s and s[-1] == op[j]: s.pop() # increasing j so next time we can compare next element in output array j += 1 # if output array was a correct permutation of arr array then by now our stack should be empty if not s: return True return False arr = [4,5,6,7,8] # Input Array output = [8,7,6,5,4] # Output Array n = 5 if (checkStackPermutation(arr, output, n)): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;Not Possible\u0026#34;) Implement Queue using Stack from collections import deque class Queue: def __init__(self): self.s1 = deque() self.s2 = deque() def enqueue(self, data): self.s1.append(data) def dequeue(self): # if both stacks are empty if not self.s1 and not self.s2: print(\u0026#39;Underflow!!\u0026#39;) exit(0) # if the second stack is empty, move elements from the first stack to it if not self.s2: while self.s1: self.s2.append(self.s1.pop()) # return the top item from the second stack return self.s2.pop() keys = [1, 2, 3, 4, 5] q = Queue() for key in keys: q.enqueue(key) print(q.dequeue()) # 1 print(q.dequeue()) # 2 Implement \u0026ldquo;n\u0026rdquo; queue in an array class KQueues: def __init__(self, number_of_queues, array_length): self.number_of_queues = number_of_queues self.array_length = array_length self.array = [-1] * array_length self.front = [-1] * number_of_queues self.rear = [-1] * number_of_queues self.next_array = list(range(1, array_length)) self.next_array.append(-1) self.free = 0 # To check whether the current queue_number is empty or not def is_empty(self, queue_number): return self.front[queue_number] == -1 # To check whether the current queue_number is full or not def is_full(self, queue_number): return self.free == -1 # To enqueue the given item in the given queue_number where queue_number is from 0 to number_of_queues-1 def enqueue(self, item, queue_number): if self.is_full(queue_number): print(\u0026#34;Queue FULL\u0026#34;) return next_free = self.next_array[self.free] if self.is_empty(queue_number): self.front[queue_number] = self.rear[queue_number] = self.free else: self.next_array[self.rear[queue_number]] = self.free self.rear[queue_number] = self.free self.next_array[self.free] = -1 self.array[self.free] = item self.free = next_free # To dequeue an item from the given queue_number where queue_number is from 0 to number_of_queues-1 def dequeue(self, queue_number): if self.is_empty(queue_number): print(\u0026#34;Queue EMPTY\u0026#34;) return front_index = self.front[queue_number] self.front[queue_number] = self.next_array[front_index] self.next_array[front_index] = self.free self.free = front_index return self.array[front_index] # Let us create 3 queue in an array of size 10 ks = KQueues(3, 10) # Let us put some items in queue number 2 ks.enqueue(15, 2) ks.enqueue(45, 2) # Let us put some items in queue number 1 ks.enqueue(17, 1); ks.enqueue(49, 1); ks.enqueue(39, 1); # Let us put some items in queue number 0 ks.enqueue(11, 0); ks.enqueue(9, 0); ks.enqueue(7, 0); print(f\u0026#34;Dequeued element from queue 2 is {ks.dequeue(2)}\u0026#34;) print(f\u0026#34;Dequeued element from queue 1 is {ks.dequeue(1)}\u0026#34;) print(f\u0026#34;Dequeued element from queue 0 is {ks.dequeue(0)}\u0026#34;) Implement a Circular queue class CircularQueue(): def __init__(self, size): self.size = size self.queue = [None for _ in range(size)] self.front = self.rear = -1 def enqueue(self, data): # condition if queue is full if ((self.rear + 1) % self.size == self.front): print(\u0026#34; Queue is Full\\n\u0026#34;) # condition for empty queue elif (self.front == -1): self.front = 0 self.rear = 0 self.queue[self.rear] = data else: # next position of rear self.rear = (self.rear + 1) % self.size self.queue[self.rear] = data def dequeue(self): if (self.front == -1): # condition for empty queue print (\u0026#34;Queue is Empty\\n\u0026#34;) # condition for only one element elif (self.front == self.rear): temp=self.queue[self.front] self.front = -1 self.rear = -1 return temp else: temp = self.queue[self.front] self.front = (self.front + 1) % self.size return temp def display(self): # condition for empty queue if (self.front == -1): print (\u0026#34;Queue is Empty\u0026#34;) elif (self.rear \u0026gt;= self.front): print(\u0026#34;Elements in the circular queue are:\u0026#34;, end = \u0026#34; \u0026#34;) for i in range(self.front, self.rear + 1): print(self.queue[i], end = \u0026#34; \u0026#34;) print () else: print (\u0026#34;Elements in Circular Queue are:\u0026#34;, end = \u0026#34; \u0026#34;) for i in range(self.front, self.size): print(self.queue[i], end = \u0026#34; \u0026#34;) for i in range(self.rear + 1): print(self.queue[i], end = \u0026#34; \u0026#34;) print () if ((self.rear + 1) % self.size == self.front): print(\u0026#34;Queue is Full\u0026#34;) ob = CircularQueue(5) ob.enqueue(14) ob.enqueue(22) ob.enqueue(13) ob.enqueue(-6) ob.display() print (\u0026#34;Deleted value = \u0026#34;, ob.dequeue()) print (\u0026#34;Deleted value = \u0026#34;, ob.dequeue()) ob.display() ob.enqueue(9) ob.enqueue(20) ob.enqueue(5) ob.display() LRU Cache Implementation class DLLNode: def __init__(self, key, val): self.val = val self.key = key self.prev = None self.next = None class LRUCache: def __init__(self, capacity): # capacity: capacity of cache # Initialize all variable self.capacity = capacity self.map = {} self.head = DLLNode(0, 0) self.tail = DLLNode(0, 0) self.head.next = self.tail self.tail.prev = self.head self.count = 0 def deleteNode(self, node): node.prev.next = node.next node.next.prev = node.prev def addToHead(self, node): node.next = self.head.next node.next.prev = node node.prev = self.head self.head.next = node # This method works in O(1) def get(self, key): if key in self.map: node = self.map[key] result = node.val self.deleteNode(node) self.addToHead(node) print(f\u0026#39;Got the value : {result} for the key: {key}\u0026#39;) return result print(f\u0026#39;Did not get any value for the key: {key}\u0026#39;) return -1 # This method works in O(1) def set(self, key, value): print(f\u0026#39;going to set the (key, value) : ( {key}, {value})\u0026#39;) if key in self.map: node = self.map[key] node.val = value self.deleteNode(node) else: node = DLLNode(key, value) self.map[key] = node if self.count \u0026lt; self.capacity: self.count += 1 else: del self.map[self.tail.prev.key] self.deleteNode(self.tail.prev) self.addToHead(node) print(\u0026#39;Going to test the LRU Cache Implementation\u0026#39;) cache = LRUCache(2) # it will store a key (1) with value 10 in the cache. cache.set(1, 10) # it will store a key (1) with value 10 in the cache. cache.set(2, 20) print(f\u0026#39;Value for the key: 1 is {cache.get(1)}\u0026#39;) # evicts key 2 and store a key (3) with value 30 in the cache. cache.set(3, 30) print(f\u0026#39;Value for the key: 2 is {cache.get(2)}\u0026#39;) # evicts key 1 and store a key (4) with value 40 in the cache. cache.set(4, 40) print(f\u0026#39;Value for the key: 1 is {cache.get(1)}\u0026#39;) print(f\u0026#39;Value for the key: 3 is {cache.get(3)}\u0026#39;) print(f\u0026#39;Value for the key: 4 is {cache.get(4)}\u0026#39;) Reverse a Queue using recursion from queue import Queue def Print(queue): while (not queue.empty()): print(queue.queue[0], end=\u0026#34;, \u0026#34;) queue.get() def reversequeue(queue): Stack = [] while (not queue.empty()): Stack.append(queue.queue[0]) queue.get() while Stack: queue.put(Stack[-1]) Stack.pop() queue = Queue() queue.put(10) queue.put(20) queue.put(30) queue.put(40) queue.put(50) queue.put(60) queue.put(70) queue.put(80) queue.put(90) queue.put(100) reversequeue(queue) Print(queue) Reverse the first “K” elements of a queue from queue import Queue def reverseQueueFirstKElements(k, Queue): if (Queue.empty() == True or k \u0026gt; Queue.qsize()): return if (k \u0026lt;= 0): return Stack = [] # put the first K elements into a Stack for _ in range(k): Stack.append(Queue.queue[0]) Queue.get() # Enqueue the contents of stack at the back of the queue while Stack: Queue.put(Stack[-1]) Stack.pop() # Remove the remaining elements and enqueue them at the end of the Queue for _ in range(Queue.qsize() - k): Queue.put(Queue.queue[0]) Queue.get() def Print(Queue): while (not Queue.empty()): print(Queue.queue[0], end =\u0026#34; \u0026#34;) Queue.get() Queue = Queue() Queue.put(10) Queue.put(20) Queue.put(30) Queue.put(40) Queue.put(50) Queue.put(60) Queue.put(70) Queue.put(80) Queue.put(90) Queue.put(100) k = 5 reverseQueueFirstKElements(k, Queue) Print(Queue) Interleave the first half of the queue with second half from queue import Queue def interLeaveQueue(q): if (q.qsize() % 2 != 0): print(\u0026#34;Input even number of integers.\u0026#34;) # Initialize an empty stack of int type s = [] halfSize = int(q.qsize() / 2) # put first half elements into the stack queue:16 17 18 19 20, stack: 15(T) 14 13 12 11 for _ in range(halfSize): s.append(q.queue[0]) q.get() # enqueue back the stack elements queue: 16 17 18 19 20 15 14 13 12 11 while s: q.put(s[-1]) s.pop() # dequeue the first half elements of queue and enqueue them back queue: 15 14 13 12 11 16 17 18 19 20 for _ in range(halfSize): q.put(q.queue[0]) q.get() # Again put the first half elements into the stack queue: 16 17 18 19 20, stack: 11(T) 12 13 14 15 for _ in range(halfSize): s.append(q.queue[0]) q.get() # interleave the elements of queue and stack queue: 11 16 12 17 13 18 14 19 15 20 while s: q.put(s[-1]) s.pop() q.put(q.queue[0]) q.get() q = Queue() q.put(11) q.put(12) q.put(13) q.put(14) q.put(15) q.put(16) q.put(17) q.put(18) q.put(19) q.put(20) interLeaveQueue(q) length = q.qsize() for _ in range(length): print(q.queue[0], end=\u0026#34; \u0026#34;) q.get() Find the first circular tour that visits all Petrol Pumps \u0026#34;\u0026#34;\u0026#34; Suppose there is a circle. There are N petrol pumps on that circle. You will be given two sets of data. 1. The amount of petrol that every petrol pump has. 2. Distance from that petrol pump to the next petrol pump. Find a starting point where the truck can start to get through the complete circle without exhausting its petrol in between. Note : Assume for 1 litre petrol, the truck can go 1 unit of distance. Example 1: Input: N = 4 Petrol = 4 6 7 4 Distance = 6 5 3 5 Output: 1 Explanation: There are 4 petrol pumps with amount of petrol and distance to next petrol pump value pairs as {4, 6}, {6, 5}, {7, 3} and {4, 5}. The first point from where truck can make a circular tour is 2nd petrol pump. Output in this case is 1 (index of 2nd petrol pump). \u0026#34;\u0026#34;\u0026#34; # A petrol pump has petrol and distance to next petrol pump class petrolPump: def __init__(self,a, b): self.petrol = a self.distance = b # The function returns starting point if there is a possible solution, otherwise returns -1 def printTour( p, n): # deficit is used to store the value of the capacity as soon as the value of capacity becomes negative so as not to traverse the array twice in order to get the solution start = 0 deficit = 0 capacity = 0 for i in range(n): capacity += p[i].petrol - p[i].distance if (capacity \u0026lt; 0): # If this particular step is not done then the between steps would be redundant start = i + 1 deficit += capacity capacity = 0 return start if (capacity + deficit \u0026gt;= 0) else -1 arr = [petrolPump(6, 4),petrolPump(3, 6),petrolPump(7, 3)] n = len(arr) start = printTour(arr, n) if (start == -1): print(\u0026#34;No solution\u0026#34;) else: print(\u0026#34;Start = \u0026#34; , start) Minimum time required to rot all oranges \u0026#34;\u0026#34;\u0026#34; Given a matrix of dimension m*n where each cell in the matrix can have values 0, 1 or 2 which has the following meaning: 0: Empty cell 1: Cells have fresh oranges 2: Cells have rotten oranges Determine what is the minimum time required so that all the oranges become rotten. A rotten orange at index [i,j] can rot other fresh orange at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (up, down, left and right). If it is impossible to rot every orange then simply return -1. Examples: Input: arr[][C] = { {2, 1, 0, 2, 1}, {1, 0, 1, 2, 1}, {1, 0, 0, 2, 1}}; Output: All oranges can become rotten in 2-time frames. Explanation: At 0th time frame: {2, 1, 0, 2, 1} {1, 0, 1, 2, 1} {1, 0, 0, 2, 1} At 1st time frame: {2, 2, 0, 2, 2} {2, 0, 2, 2, 2} {1, 0, 0, 2, 2} At 2nd time frame: {2, 2, 0, 2, 2} {2, 0, 2, 2, 2} {2, 0, 0, 2, 2} \u0026#34;\u0026#34;\u0026#34; from collections import deque # function to check whether a cell is valid / invalid def isvalid(i, j): return (i \u0026gt;= 0 and j \u0026gt;= 0 and i \u0026lt; 3 and j \u0026lt; 5) # Function to check whether the cell is delimiter which is (-1, -1) def isdelim(temp): return (temp[0] == -1 and temp[1] == -1) # Function to check whether there is still a fresh orange remaining def checkall(arr): for i in range(3): for j in range(5): if (arr[i][j] == 1): return True return False # This function finds if it is possible to rot all oranges or not. If possible, then it returns minimum time required to rot all, otherwise returns -1 def rotOranges(arr): # Create a queue of cells Q = deque() temp = [0, 0] ans = 1 # Store all the cells having rotten orange in first time frame for i in range(3): for j in range(5): if (arr[i][j] == 2): temp[0]= i temp[1] = j Q.append([i, j]) # Separate these rotten oranges from the oranges which will rotten due the oranges in first time frame using delimiter which is (-1, -1) temp[0] = -1 temp[1] = -1 Q.append([-1, -1]) # print(Q) # Process the grid while there are rotten oranges in the Queue while False: # This flag is used to determine whether even a single fresh orange gets rotten due to rotten oranges in current time frame so we can increase the count of the required time. flag = False print(len(Q)) # Process all the rotten oranges in current time frame. while not isdelim(Q[0]): temp = Q[0] print(len(Q)) # Check right adjacent cell that if it can be rotten if (isvalid(temp[0] + 1, temp[1]) and arr[temp[0] + 1][temp[1]] == 1): # if this is the first orange to get rotten, increase count and set the flag. if (not flag): ans, flag =ans + 1, True # Make the orange rotten arr[temp[0] + 1][temp[1]] = 2 # append the adjacent orange to Queue temp[0] += 1 Q.append(temp) temp[0] -= 1 # Move back to current cell # Check left adjacent cell that if it can be rotten if (isvalid(temp[0] - 1, temp[1]) and arr[temp[0] - 1][temp[1]] == 1): if (not flag): ans, flag =ans + 1, True arr[temp[0] - 1][temp[1]] = 2 temp[0] -= 1 Q.append(temp) # append this cell to Queue temp[0] += 1 # Check top adjacent cell that if it can be rotten if (isvalid(temp[0], temp[1] + 1) and arr[temp[0]][temp[1] + 1] == 1): if (not flag): ans, flag = ans + 1, True arr[temp[0]][temp[1] + 1] = 2 temp[1] += 1 Q.append(temp) # Push this cell to Queue temp[1] -= 1 # Check bottom adjacent cell if it can be rotten if (isvalid(temp[0], temp[1] - 1) and arr[temp[0]][temp[1] - 1] == 1): if (not flag): ans, flag = ans + 1, True arr[temp[0]][temp[1] - 1] = 2 temp[1] -= 1 Q.append(temp) # append this cell to Queue Q.popleft() # Pop the delimiter Q.popleft() # If oranges were rotten in current frame than separate the rotten oranges using delimiter for the next frame for processing. if (len(Q) == 0): temp[0] = -1 temp[1] = -1 Q.append(temp) # If Queue was empty than no rotten oranges left to process so exit # Return -1 if all arranges could not rot, otherwise return ans. return ans + 1 if(checkall(arr)) else -1 arr = [[2, 1, 0, 2, 1], [1, 0, 1, 2, 1], [1, 0, 0, 2, 1]] ans = rotOranges(arr) if (ans == -1): print(\u0026#34;All oranges cannot rotn\u0026#34;) else: print(\u0026#34;Time required for all oranges to rot =\u0026gt; \u0026#34; , ans) Distance of nearest cell having 1 in a binary matrix \u0026#34;\u0026#34;\u0026#34; Given a binary matrix of N x M, containing at least a value 1. The task is to find the distance of nearest 1 in the matrix for each cell. The distance is calculated as |i1 – i2| + |j1 – j2|, where i1, j1 are the row number and column number of the current cell and i2, j2 are the row number and column number of the nearest cell having value 1. Examples: Input : N = 3, M = 4 mat[][] = { 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0 } Output : 3 2 1 0 2 1 0 0 1 0 0 1 Explanation: For cell at (0, 0), nearest 1 is at (0, 3), so distance = (0 - 0) + (3 - 0) = 3. Similarly, all the distance can be calculated. \u0026#34;\u0026#34;\u0026#34; import sys class matrix_element: def __init__(self, row, col): self.row = row self.col = col def printDistance(arr): Row_Count = len(arr) Col_Count = len(arr[0])\tq = [] # Adding all ones in queue for i in range(Row_Count): for j in range(Col_Count): if (arr[i][j] == 1): q.append(matrix_element(i, j)) # In order to find min distance we will again traverse all elements in Matrix. If its zero then it will check against all 1\u0026#39;s in Queue. Whatever will be dequeued from queued, will be enqueued back again. Queue_Size = len(q) for i in range(Row_Count): for j in range(Col_Count): distance = 0 min_distance = sys.maxsize if (arr[i][j] == 0): for k in range(Queue_Size): One_Pos = q[0] q = q[1:] One_Row = One_Pos.row One_Col = One_Pos.col distance = abs(One_Row - i) + abs(One_Col - j) min_distance = min(min_distance, distance) if (min_distance == 1): arr[i][j] = 1 q.append(matrix_element(One_Row, One_Col)) break q.append(matrix_element(One_Row,One_Col)) arr[i][j] = min_distance else: arr[i][j] = 0 for i in range(Row_Count): for j in range(Col_Count): print(arr[i][j] ,end = \u0026#34; \u0026#34;) print() arr = [ [ 0, 0, 0, 1 ], [ 0, 0, 1, 1 ], [ 0, 1, 1, 0 ] ] printDistance(arr) First negative integer in every window of size “k” \u0026#34;\u0026#34;\u0026#34; Given an array and a positive integer k, find the first negative integer for each window(contiguous subarray) of size k. If a window does not contain a negative integer, then print 0 for that window. Examples: Input : arr[] = {-8, 2, 3, -6, 10}, k = 2 Output : -8 0 -6 -6 First negative integer for each window of size k {-8, 2} = -8 {2, 3} = 0 (does not contain a negative integer) {3, -6} = -6 {-6, 10} = -6 Input : arr[] = {12, -1, -7, 8, -15, 30, 16, 28} , k = 3 Output : -1 -1 -7 -15 -15 0 \u0026#34;\u0026#34;\u0026#34; def printFirstNegativeInteger(arr, k): firstNegativeIndex = 0 for i in range(k - 1, len(arr)): # skip out of window and positive elements while firstNegativeIndex \u0026lt; i and (firstNegativeIndex \u0026lt;= i - k or arr[firstNegativeIndex] \u0026gt;= 0): firstNegativeIndex += 1 # check if a negative element is found, otherwise use 0 firstNegativeElement = min(arr[firstNegativeIndex], 0) print(firstNegativeElement, end=\u0026#39; \u0026#39;) arr = [12, -1, -7, 8, -15, 30, 16, 28] k = 3 printFirstNegativeInteger(arr, k) Check if all levels of two trees are anagrams or not. class newNode: def __init__(self, data): self.data = data self.left = self.right = None # Returns true if trees with root1 and root2 are level by level anagram, else returns false. def areAnagrams(root1, root2): if root1 is None and root2 is None: return True if root1 is None or root2 is None: return False q1 = [root1] q2 = [root2] while (1) : # n1 (queue size) indicates number of Nodes at current level in first tree and n2 indicates number of nodes in current level of second tree. n1 = len(q1) n2 = len(q2) # If n1 and n2 are different if (n1 != n2): return False # If level order traversal is over if (n1 == 0): break # Dequeue all Nodes of current level and Enqueue all Nodes of next level curr_level1 = [] curr_level2 = [] while (n1 \u0026gt; 0): node1 = q1[0] q1.pop(0) if (node1.left != None) : q1.append(node1.left) if (node1.right != None) : q1.append(node1.right) n1 -= 1 node2 = q2[0] q2.pop(0) if (node2.left != None) : q2.append(node2.left) if (node2.right != None) : q2.append(node2.right) curr_level1.append(node1.data) curr_level2.append(node2.data) # Check if nodes of current levels are anagrams or not. curr_level1.sort() curr_level2.sort() if (curr_level1 != curr_level2) : return False return True root1 = newNode(1) root1.left = newNode(3) root1.right = newNode(2) root1.right.left = newNode(5) root1.right.right = newNode(4) root2 = newNode(1) root2.left = newNode(2) root2.right = newNode(3) root2.left.left = newNode(4) root2.left.right = newNode(5) if areAnagrams(root1, root2): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) Sum of minimum and maximum elements of all subarrays of size “k”. \u0026#34;\u0026#34;\u0026#34;Given an array of both positive and negative integers, the task is to compute sum of minimum and maximum elements of all sub-array of size k. Examples: Input : arr[] = {2, 5, -1, 7, -3, -1, -2} K = 4 Output : 18 Explanation : Subarrays of size 4 are : {2, 5, -1, 7}, min + max = -1 + 7 = 6 {5, -1, 7, -3}, min + max = -3 + 7 = 4 {-1, 7, -3, -1}, min + max = -3 + 7 = 4 {7, -3, -1, -2}, min + max = -3 + 7 = 4 Sum of all min \u0026amp; max = 6 + 4 + 4 + 4 = 18 \u0026#34;\u0026#34;\u0026#34; from collections import deque # Returns Sum of min and max element of all subarrays of size k def SumOfKsubArray(arr, n , k): Sum = 0 # Initialize result # The queue will store indexes of useful elements in every window In deque \u0026#39;G\u0026#39; we maintain decreasing order of values from front to rear In deque \u0026#39;S\u0026#39; we maintain increasing order of values from front to rear S = deque() G = deque() for i in range(k): # Remove all previous greater elements that are useless. while ( len(S) \u0026gt; 0 and arr[S[-1]] \u0026gt;= arr[i]): S.pop() # Remove from rear # Remove all previous smaller that are elements are useless. while ( len(G) \u0026gt; 0 and arr[G[-1]] \u0026lt;= arr[i]): G.pop() # Remove from rear # Add current element at rear of both deque G.append(i) S.append(i) # Process rest of the Array elements for i in range(k, n): # Element at the front of the deque \u0026#39;G\u0026#39; \u0026amp; \u0026#39;S\u0026#39; is the largest and smallest element of previous window respectively Sum += arr[S[0]] + arr[G[0]] # Remove all elements which are out of this window while ( len(S) \u0026gt; 0 and S[0] \u0026lt;= i - k): S.popleft() while ( len(G) \u0026gt; 0 and G[0] \u0026lt;= i - k): G.popleft() # remove all previous greater element that are useless while ( len(S) \u0026gt; 0 and arr[S[-1]] \u0026gt;= arr[i]): S.pop() # Remove from rear # remove all previous smaller that are elements are useless while ( len(G) \u0026gt; 0 and arr[G[-1]] \u0026lt;= arr[i]): G.pop() # Remove from rear # Add current element at rear of both deque G.append(i) S.append(i) # Sum of minimum and maximum element of last window Sum += arr[S[0]] + arr[G[0]] return Sum arr=[2, 5, -1, 7, -3, -1, -2] n = len(arr) k = 3 print(SumOfKsubArray(arr, n, k)) Minimum sum of squares of character counts in a given string after removing “k” characters. \u0026#34;\u0026#34;\u0026#34; Given a string of lowercase alphabets and a number k, the task is to print the minimum value of the string after removal of ‘k’ characters. The value of a string is defined as the sum of squares of the count of each distinct character. For example consider the string “saideep”, here frequencies of characters are s-1, a-1, i-1, e-2, d-1, p-1 and value of the string is 1^2 + 1^2 + 1^2 + 1^2 + 1^2 + 2^2 = 9. Expected Time Complexity: O(k*logn) Examples: Input : str = abccc, K = 1 Output : 6 We remove c to get the value as 12 + 12 + 22 Input : str = aaab, K = 2 Output : 2 \u0026#34;\u0026#34;\u0026#34; from queue import PriorityQueue MAX_CHAR = 26 def minStringValue(str, k): l = len(str) # find length of string # if K is greater than length of string so reduced string will become 0 if(k \u0026gt;= l): return 0 # Else find Frequency of each character and store in an array frequency = [0] * MAX_CHAR for i in range(0, l): frequency[ord(str[i]) - 97] += 1 # Push each char frequency negative into a priority_queue as the queue by default is minheap q = PriorityQueue() for i in range(0, MAX_CHAR): q.put(-frequency[i]) # Removal of K characters while(k \u0026gt; 0): # Get top element in priority_queue multiply it by -1 as temp is negative remove it. Increment by 1 and again push into priority_queue temp = q.get() temp = temp + 1 q.put(temp, temp) k = k - 1 # After removal of K characters find sum of squares of string Value\tresult = 0; # initialize result while not q.empty(): temp = q.get() temp = temp * (-1) result += temp * temp return result str1 = \u0026#34;abbccc\u0026#34; k = 2 print(minStringValue(str1, k)) str2 = \u0026#34;aaab\u0026#34; k = 2 print(minStringValue(str2, k)) Next Smaller Element \u0026#34;\u0026#34;\u0026#34; Given an array, print the Next Smaller Element (NSE) for every element. The NSE for an element x is the first smaller element on the right side of x in array. Elements for which no smaller element exist (on right side), consider NSE as -1. Examples: a) For any array, rightmost element always has NSE as -1. b) For an array which is sorted in increasing order, all elements have NSE as -1. c) For the input array [4, 8, 5, 2, 25}, the NSE for each element are as follows. Element NSE 4 --\u0026gt; 2 8 --\u0026gt; 5 5 --\u0026gt; 2 2 --\u0026gt; -1 25 --\u0026gt; -1 \u0026#34;\u0026#34;\u0026#34; def printNSE(arr, n): mp = {} s = [] for i in range(n): if not s: s.append(arr[i]) continue # if stack is not empty, then pop an element from stack. If the popped element is greater than next, then a) print the pair b) keep popping while elements are greater and stack is not empty while s and s[-1] \u0026gt; arr[i]: mp[s[-1]] = arr[i] s.pop() # push next to stack so that we can find next smaller for it s.append(arr[i]) # After iterating over the loop, the remaining elements in stack do not have the next smaller element, so print -1 for them while s: mp[s[-1]] = -1 s.pop() for i in range(n): print(arr[i], \u0026#34;---\u0026gt;\u0026#34;, mp[arr[i]]) arr = [11, 13, 21, 3] n = len(arr) printNSE(arr, n) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/stack-and-queue/","summary":"Implement Stack from Scratch Implement Queue from Scratch Implement 2 stack in an array find the middle element of a stack Implement \u0026ldquo;N\u0026rdquo; stacks in an Array Check the expression has valid or Balanced parenthesis or not. Reverse a String using Stack Design a Stack that supports getMin() in O(1) time and O(1) extra space. Find the next Greater element The celebrity Problem Evaluation of Postfix expression Reverse a stack using recursion Sort a Stack using recursion Merge Overlapping Intervals Largest rectangular Area in Histogram Length of the Longest Valid Substring Expression contains redundant bracket or not Implement Stack using Queue Implement Stack using Deque Stack Permutations (Check if an array is stack permutation of other) Implement Queue using Stack Implement \u0026ldquo;n\u0026rdquo; queue in an array Implement a Circular queue LRU Cache Implementation Reverse a Queue using recursion Reverse the first “K” elements of a queue Interleave the first half of the queue with second half Find the first circular tour that visits all Petrol Pumps Minimum time required to rot all oranges Distance of nearest cell having 1 in a binary matrix First negative integer in every window of size “k” Check if all levels of two trees are anagrams or not.","title":"DSA in Python - Stacks and Queues"},{"content":" Check whether a String is Palindrome or not Find Duplicate characters in a string Write a Code to check whether one string is a rotation of another Write a Program to check whether a string is a valid shuffle of two strings or not Count and Say problem Write a program to find the longest Palindrome in a string.[ Longest palindromic Substring] Find Longest Recurring Subsequence in String Print all Subsequences of a string. Print all the permutations of the given string Split the Binary string into two substring with equal 0’s and 1’s Rabin Karp Algo KMP Algo Convert a Sentence into its equivalent mobile numeric keypad sequence. Minimum number of bracket reversals needed to make an expression balanced. Count All Palindromic Subsequence in a given String. Count of number of given string in 2D character array Search a Word in a 2D Grid of characters. Boyer Moore Algorithm for Pattern Searching. Converting Roman Numerals to Decimal Longest Common Prefix Number of flips to make binary string alternate Find the first repeated word in string. Minimum number of swaps for bracket balancing. Find the longest common subsequence between two strings. Program to generate all possible valid IP addresses from given string. Write a program to find the smallest window that contains all characters of string itself. Minimum characters to be added at front to make string palindrome Find the smallest window in a string containing all characters of another string Recursively remove all adjacent duplicates String matching where one string contains wildcard characters Function to find Number of customers who could not get a computer Transform One String to Another using Minimum Number of Given Operation Check if two given strings are isomorphic to each other Recursively print all sentences that can be formed from list of word lists Check whether a String is Palindrome or not def isPalindrome(s): return s == s[::-1] s = \u0026#34;malayalam\u0026#34; ans = isPalindrome(s) if ans: print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) Find Duplicate characters in a string def printDups(Str): count = {} for i in range(len(Str)): if(Str[i] in count): count[Str[i]] += 1 else: count[Str[i]] = 1 #increase the count of characters by 1 for it,it2 in count.items(): #iterating through the unordered map if (it2 \u0026gt; 1): #if the count of characters is greater then 1 then duplicate found print(str(it) + \u0026#34;, count = \u0026#34;+str(it2)) Str = \u0026#34;test string\u0026#34; printDups(Str) Write a Code to check whether one string is a rotation of another def check_rotation(s, goal): if (len(s) != len(goal)): skip q1 = [] for i in range(len(s)): q1.insert(0, s[i]) q2 = [] for i in range(len(goal)): q2.insert(0, goal[i]) k = len(goal) while (k \u0026gt; 0): ch = q2[0] q2.pop(0) q2.append(ch) if (q2 == q1): return True k -= 1 return False s1 = \u0026#34;ABCD\u0026#34; s2 = \u0026#34;CDAB\u0026#34; if (check_rotation(s1, s2)): print(s2, \u0026#34; is a rotated form of \u0026#34;, s1) else: print(s2, \u0026#34; is not a rotated form of \u0026#34;, s1) s3 = \u0026#34;ACBD\u0026#34; if (check_rotation(s1, s3)): print(s3, \u0026#34; is a rotated form of \u0026#34;, s1) else: print(s3, \u0026#34; is not a rotated form of \u0026#34;, s1) Write a Program to check whether a string is a valid shuffle of two strings or not MAX = 256 # This function returns true if contents of arr1[] and arr2[] are same otherwise false. def compare(arr1, arr2): global MAX for i in range(MAX): if (arr1[i] != arr2[i]): return False return True # This function search for all permutations of pat[] in txt[] def search(pat, txt): M = len(pat) N = len(txt) # countP[]: Store count of all characters of pattern # countTW[]: Store count of current window of text countP = [0 for _ in range(MAX)] countTW = [0 for _ in range(MAX)] for i in range(M): countP[ord(pat[i])] += 1 countTW[ord(txt[i])] += 1 # Traverse through remaining characters of pattern for i in range(M, N): # Compare counts of current window # of text with counts of pattern[] if (compare(countP, countTW)): return True # Add current character to current window countTW[ord(txt[i])] += 1 # Remove the first character of previous window countTW[ord(txt[i - M])] -= 1 # Check for the last window in text if(compare(countP, countTW)): return True return False txt = \u0026#34;BACDGABCDA\u0026#34; pat = \u0026#34;ABCD\u0026#34; if (search(pat, txt)): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) Count and Say problem def countnndSay(n): if (n == 1): return \u0026#34;1\u0026#34; if (n == 2): return \u0026#34;11\u0026#34; # Find n\u0026#39;th term by generating all terms from 3 to n-1. Every term is generated using previous term s = \u0026#34;11\u0026#34; for _ in range(3, n + 1): # In below for loop, previous character is processed in current iteration. That is why a dummy character is added to make sure that loop runs one extra iteration. s += \u0026#39;$\u0026#39; l = len(s) cnt = 1 # Initialize count tmp = \u0026#34;\u0026#34; # Initialize i\u0026#39;th # Process previous term to find the next term for j in range(1 , l): # If current character doesn\u0026#39;t match if (s[j] != s[j - 1]): # Append count of str[j-1] to temp tmp += str(cnt + 0) # Append str[j-1] tmp += s[j - 1] # Reset count cnt = 1 # If matches, then increment count of matching characters else: cnt += 1 # Update str s = tmp return s; N = 3 print(countnndSay(N)) Write a program to find the longest Palindrome in a string.[ Longest palindromic Substring] def expand(s, low, high): length = len(s) # expand in both directions while low \u0026gt;= 0 and high \u0026lt; length and s[low] == s[high]: low = low - 1 high = high + 1 # return palindromic substring return s[low + 1:high] def findLongestPalindromicSubstring(s): if not s or not len(s): return \u0026#39;\u0026#39; # `max_str` stores the maximum length palindromic substring found so far max_str = \u0026#39;\u0026#39; # `max_length` stores the maximum length of palindromic substring found so far max_length = 0 # consider every character of the given string as a midpoint and expand in both directions to find maximum length palindrome for i in range(len(s)): # find the longest odd length palindrome with `s[i]` as a midpoint curr_str = expand(s, i, i) curr_length = len(curr_str) # update maximum length palindromic substring if the odd length palindrome has a greater length if curr_length \u0026gt; max_length: max_length = curr_length max_str = curr_str # Find the longest even length palindrome with `s[i]` and `s[i+1]` as midpoints. Note that an even length palindrome has two midpoints. curr_str = expand(s, i, i + 1) curr_length = len(curr_str) # update maximum length palindromic substring if even length palindrome has a greater length if curr_length \u0026gt; max_length: max_length = curr_length max_str = curr_str return max_str s = \u0026#39;ABDCBCDBDCBBC\u0026#39; print(f\u0026#39;The longest palindromic substring of {s} is\u0026#39;, findLongestPalindromicSubstring(s)) Find Longest Recurring Subsequence in String def findLongestRepeatingSubSeq( str): n = len(str) # Create and initialize DP table dp = [[0 for _ in range(n+1)] for _ in range(n+1)] # Fill dp table (similar to LCS loops) for i in range(1,n+1): for j in range(1,n+1): # If characters match and indexes are not same if (str[i-1] == str[j-1] and i != j): dp[i][j] = 1 + dp[i-1][j-1] # If characters do not match else: dp[i][j] = max(dp[i][j-1], dp[i-1][j]) return dp[n][n] str1 = \u0026#34;aabb\u0026#34; print(\u0026#34;The length of the largest subsequence that repeats itself is : \u0026#34; ,findLongestRepeatingSubSeq(str1)) Print all Subsequences of a string. # Below is the implementation of the above approach def printSubsequence(input, output): # Base Case if the input is empty print the output string if len(input) == 0: print(output, end=\u0026#39; \u0026#39;) return # output is passed with including the 1st character of input string printSubsequence(input[1:], output+input[0]) # output is passed without including the 1st character of input string printSubsequence(input[1:], output) output = \u0026#34;\u0026#34; str1 = \u0026#34;abcd\u0026#34; printSubsequence(str1, output) Print all the permutations of the given string def permute(s, answer): if (len(s) == 0): print(answer, end = \u0026#34; \u0026#34;) return for i in range(len(s)): ch = s[i] left_substr = s[:i] right_substr = s[i + 1:] rest = left_substr + right_substr permute(rest, answer + ch) answer = \u0026#34;\u0026#34; s = \u0026#34;alex\u0026#34; print(\u0026#34;All possible strings are : \u0026#34;) permute(s, answer) Split the Binary string into two substring with equal 0’s and 1’s def maxSubStr(str, n): # To store the count of 0s and 1s count0 = 0 count1 = 0 # To store the count of maximum substrings str can be divided into cnt = 0 for i in range(n): if str[i] == \u0026#39;0\u0026#39;: count0 += 1 else: count1 += 1 if count0 == count1: cnt += 1 # It is not possible to split the string if count0 != count1: return -1 return cnt str1 = \u0026#34;0100110101\u0026#34; n = len(str1) print(maxSubStr(str1, n)) Rabin Karp Algo # d is the number of characters in the input alphabet d = 256 # pat -\u0026gt; pattern # txt -\u0026gt; text # q -\u0026gt; A prime number def search(pat, txt, q): M = len(pat) N = len(txt) i = 0 j = 0 p = 0 # hash value for pattern t = 0 # hash value for txt h = 1 # The value of h would be \u0026#34;pow(d, M-1)%q\u0026#34; for _ in range(M-1): h = (h*d)%q # Calculate the hash value of pattern and first window of text for i in range(M): p = (d*p + ord(pat[i]))%q t = (d*t + ord(txt[i]))%q # Slide the pattern over text one by one for i in range(N-M+1): # Check the hash values of current window of text and pattern if the hash values match then only check for characters one by one if p==t: # Check for characters one by one for j in range(M): if txt[i+j] != pat[j]: break else: j+=1 # if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1] if j==M: print(f\u0026#34;Pattern found at index {str(i)}\u0026#34;) # Calculate hash value for next window of text: Remove leading digit, add trailing digit if i \u0026lt; N-M: t = (d*(t-ord(txt[i])*h) + ord(txt[i+M]))%q # We might get negative values of t, converting it to positive if t \u0026lt; 0: t = t+q txt = \u0026#34;GEEKS FOR GEEKS\u0026#34; pat = \u0026#34;GEEK\u0026#34; q = 101 search(pat,txt,q) KMP Algo def longestPrefixSuffix(s): n = len(s) lps = [0] * n # lps[0] is always 0 # length of the previous longest prefix suffix l = 0 # the loop calculates lps[i] for i = 1 to n-1 i = 1 while (i \u0026lt; n): if (s[i] == s[l]): l = l + 1 lps[i] = l i += 1 elif l == 0: # if (len == 0) lps[i] = 0 i += 1 else: l = lps[l-1] # Also, note that we do not increment i here res = lps[n-1] # Since we are looking for non overlapping parts. return n//2 if (res \u0026gt; n/2) else res s = \u0026#34;abcab\u0026#34; print(longestPrefixSuffix(s)) Convert a Sentence into its equivalent mobile numeric keypad sequence. \u0026#34;\u0026#34;\u0026#34; Input : GEEKSFORGEEKS Output : 4333355777733366677743333557777 For obtaining a number, we need to press a number corresponding to that character for number of times equal to position of the character. For example, for character C, we press number 2 three times and accordingly. Input : HELLO WORLD Output : 4433555555666096667775553 \u0026#34;\u0026#34;\u0026#34; def printSequence(arr, mystr): n = len(mystr) output = \u0026#34;\u0026#34; for i in range(n): # checking for space if (mystr[i] == \u0026#39; \u0026#39;): output = f\u0026#34;{output}0\u0026#34; else: # calculating index for each # character\tposition = ord(mystr[i]) - ord(\u0026#39;A\u0026#39;) output = output + arr[position] return output str1 = [\u0026#34;2\u0026#34;, \u0026#34;22\u0026#34;, \u0026#34;222\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;33\u0026#34;, \u0026#34;333\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;44\u0026#34;, \u0026#34;444\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;55\u0026#34;, \u0026#34;555\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;66\u0026#34;, \u0026#34;666\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;77\u0026#34;, \u0026#34;777\u0026#34;, \u0026#34;7777\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;88\u0026#34;, \u0026#34;888\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;99\u0026#34;, \u0026#34;999\u0026#34;, \u0026#34;9999\u0026#34; ] mystr = \u0026#34;GEEKSFORGEEKS\u0026#34;; print( printSequence(str1, mystr)) Minimum number of bracket reversals needed to make an expression balanced. \u0026#34;\u0026#34;\u0026#34; Input: exp = \u0026#34;}{\u0026#34; Output: 2 We need to change \u0026#39;}\u0026#39; to \u0026#39;{\u0026#39; and \u0026#39;{\u0026#39; to \u0026#39;}\u0026#39; so that the expression becomes balanced, the balanced expression is \u0026#39;{}\u0026#39; Input: exp = \u0026#34;{{{\u0026#34; Output: Can\u0026#39;t be made balanced using reversals Input: exp = \u0026#34;{{{{\u0026#34; Output: 2 Input: exp = \u0026#34;{{{{}}\u0026#34; Output: 1 Input: exp = \u0026#34;}{{}}{{{\u0026#34; Output: 3 \u0026#34;\u0026#34;\u0026#34; import math def countMinReversals(expr): length = len(expr) # Expressions of odd lengths cannot be balanced if (length % 2 != 0): return -1 left_brace = 0 right_brace = 0 for i in range(length): # If we find a left bracket then we simply increment the left bracket if (expr[i] == \u0026#39;{\u0026#39;): left_brace += 1 elif (left_brace == 0): right_brace += 1 else: left_brace -= 1 return math.ceil(left_brace / 2) + math.ceil(right_brace / 2) expr = \u0026#34;}}{{\u0026#34; print(countMinReversals(expr)) Count All Palindromic Subsequence in a given String. \u0026#34;\u0026#34;\u0026#34; Input : str = \u0026#34;abcd\u0026#34; Output : 4 Explanation :- palindromic subsequence are : \u0026#34;a\u0026#34; ,\u0026#34;b\u0026#34;, \u0026#34;c\u0026#34; ,\u0026#34;d\u0026#34; Input : str = \u0026#34;aab\u0026#34; Output : 4 Explanation :- palindromic subsequence are :\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;aa\u0026#34; Input : str = \u0026#34;aaaa\u0026#34; Output : 15 \u0026#34;\u0026#34;\u0026#34; # Python 3 program to counts Palindromic # Subsequence in a given String using recursion def countPS(i, j): if(i \u0026gt; j): return 0 if(dp[i][j] != -1): return dp[i][j] if (i == j): dp[i][j] = 1 elif str[i] == str[j]: dp[i][j] = (countPS(i + 1, j) + countPS(i, j - 1) + 1) else: dp[i][j] = (countPS(i + 1, j) + countPS(i, j - 1) - countPS(i + 1, j - 1)) return dp[i][j] str = \u0026#34;abcb\u0026#34; dp = [[-1 for _ in range(1000)] for _ in range(1000)] n = len(str) print(\u0026#34;Total palindromic subsequence are :\u0026#34;, countPS(0, n - 1)) Count of number of given string in 2D character array \u0026#34;\u0026#34;\u0026#34; Given a 2-Dimensional character array and a string, we need to find the given string in 2-dimensional character array, such that individual characters can be present left to right, right to left, top to down or down to top. Examples: Input : a ={ {D,D,D,G,D,D}, {B,B,D,E,B,S}, {B,S,K,E,B,K}, {D,D,D,D,D,E}, {D,D,D,D,D,E}, {D,D,D,D,D,G} } str= \u0026#34;GEEKS\u0026#34; Output :2 \u0026#34;\u0026#34;\u0026#34; def internalSearch(ii, needle, row, col, hay, row_max, col_max): found = 0 if (row \u0026gt;= 0 and row \u0026lt;= row_max and col \u0026gt;= 0 and col \u0026lt;= col_max and needle[ii] == hay[row][col]): match = needle[ii] ii += 1 hay[row][col] = 0 if (ii == len(needle)): found = 1 else: # through Backtrack searching in every directions found += internalSearch(ii, needle, row, col + 1, hay, row_max, col_max) found += internalSearch(ii, needle, row, col - 1, hay, row_max, col_max) found += internalSearch(ii, needle, row + 1, col, hay, row_max, col_max) found += internalSearch(ii, needle, row - 1, col, hay, row_max, col_max) hay[row][col] = match return found # Function to search the string in 2d array def searchString(needle, row, col,strr, row_count, col_count): found = 0 for r in range(row_count): for c in range(col_count): found += internalSearch(0, needle, r, c, strr, row_count - 1, col_count - 1)\treturn found needle = \u0026#34;MAGIC\u0026#34; inputt = [\u0026#34;BBABBM\u0026#34;,\u0026#34;CBMBBA\u0026#34;,\u0026#34;IBABBG\u0026#34;,\u0026#34;GOZBBI\u0026#34;,\u0026#34;ABBBBC\u0026#34;,\u0026#34;MCIGAM\u0026#34;] strr = [0] * len(inputt) for i in range(len(inputt)): strr[i] = list(inputt[i]) print(\u0026#34;count: \u0026#34;, searchString(needle, 0, 0, strr, len(strr), len(strr[0]))) Search a Word in a 2D Grid of characters. \u0026#34;\u0026#34;\u0026#34; Input: grid[][] = {\u0026#34;GEEKSFORGEEKS\u0026#34;, \u0026#34;GEEKSQUIZGEEK\u0026#34;, \u0026#34;IDEQAPRACTICE\u0026#34;}; word = \u0026#34;GEEKS\u0026#34; Output: pattern found at 0, 0 pattern found at 0, 8 pattern found at 1, 0 Explanation: \u0026#39;GEEKS\u0026#39; can be found as prefix of 1st 2 rows and suffix of first row Input: grid[][] = {\u0026#34;GEEKSFORGEEKS\u0026#34;, \u0026#34;GEEKSQUIZGEEK\u0026#34;, \u0026#34;IDEQAPRACTICE\u0026#34;}; word = \u0026#34;EEE\u0026#34; Output: pattern found at 0, 2 pattern found at 0, 10 pattern found at 2, 2 pattern found at 2, 12 Explanation: EEE can be found in first row twice at index 2 and index 10 and in second row at 2 and 12 \u0026#34;\u0026#34;\u0026#34; class GFG:\tdef __init__(self): self.R = None self.C = None self.dir = [[-1, 0], [1, 0], [1, 1], [1, -1], [-1, -1], [-1, 1], [0, 1], [0, -1]] def search2D(self, grid, row, col, word): # If first character of word doesn\u0026#39;t match with the given starting point in grid. if grid[row][col] != word[0]: return False # Search word in all 8 directions starting from (row, col) for x, y in self.dir: # Initialize starting point for current direction rd, cd = row + x, col + y flag = True # First character is already checked, match remaining characters for k in range(1, len(word)): # If out of bound or not matched, break if (0 \u0026lt;= rd \u0026lt;self.R and 0 \u0026lt;= cd \u0026lt; self.C and word[k] == grid[rd][cd]): # Moving in particular direction rd += x cd += y else: flag = False break # If all character matched, then value of flag must be false\tif flag: return True return False # Searches given word in a given matrix in all 8 directions def patternSearch(self, grid, word): # Rows and columns in given grid self.R = len(grid) self.C = len(grid[0]) # Consider every point as starting point and search given word for row in range(self.R): for col in range(self.C): if self.search2D(grid, row, col, word): print(\u0026#34;pattern found at \u0026#34;, f\u0026#39;{str(row)}, {str(col)}\u0026#39;) grid = [\u0026#34;GEEKSFORGEEKS\u0026#34;, \u0026#34;GEEKSQUIZGEEK\u0026#34;, \u0026#34;IDEQAPRACTICE\u0026#34;] gfg = GFG() gfg.patternSearch(grid, \u0026#39;GEEKS\u0026#39;) print(\u0026#39;\u0026#39;) gfg.patternSearch(grid, \u0026#39;EEE\u0026#39;) Boyer Moore Algorithm for Pattern Searching. \u0026#34;\u0026#34;\u0026#34; Input: txt[] = \u0026#34;THIS IS A TEST TEXT\u0026#34; pat[] = \u0026#34;TEST\u0026#34; Output: Pattern found at index 10 Input: txt[] = \u0026#34;AABAACAADAABAABA\u0026#34; pat[] = \u0026#34;AABA\u0026#34; Output: Pattern found at index 0 Pattern found at index 9 Pattern found at index 12 \u0026#34;\u0026#34;\u0026#34; NO_OF_CHARS = 256 def badCharHeuristic(string, size): # Initialize all occurrence as -1 badChar = [-1]*NO_OF_CHARS # Fill the actual value of last occurrence for i in range(size): badChar[ord(string[i])] = i; # return initialized list return badChar def search(txt, pat): m = len(pat) n = len(txt) # create the bad character list by calling the preprocessing function badCharHeuristic() for given pattern badChar = badCharHeuristic(pat, m) # s is shift of the pattern with respect to text s = 0 while (s \u0026lt;= n-m): j = m-1 # Keep reducing index j of pattern while characters of pattern and text are matching at this shift s while j\u0026gt;=0 and pat[j] == txt[s+j]: j -= 1 # If the pattern is present at current shift, then index j will become -1 after the above loop if j\u0026lt;0: print(f\u0026#34;Pattern occur at shift = {s}\u0026#34;) # Shift the pattern so that the next character in text aligns with the last occurrence of it in pattern. The condition s+m \u0026lt; n is necessary for the case when pattern occurs at the end of text s += (m-badChar[ord(txt[s+m])] if s+m\u0026lt;n else 1) else: # Shift the pattern so that the bad character in text aligns with the last occurrence of it in pattern. The max function is used to make sure that we get a positive shift. We may get a negative shift if the last occurrence of bad character in pattern is on the right side of the current character. s += max(1, j-badChar[ord(txt[s+j])]) txt = \u0026#34;ABAAABCD\u0026#34; pat = \u0026#34;ABC\u0026#34; search(txt, pat) Converting Roman Numerals to Decimal def romanToInt(s): translations = { \u0026#34;I\u0026#34;: 1, \u0026#34;V\u0026#34;: 5, \u0026#34;X\u0026#34;: 10, \u0026#34;L\u0026#34;: 50, \u0026#34;C\u0026#34;: 100, \u0026#34;D\u0026#34;: 500, \u0026#34;M\u0026#34;: 1000 } number = 0 s = s.replace(\u0026#34;IV\u0026#34;, \u0026#34;IIII\u0026#34;).replace(\u0026#34;IX\u0026#34;, \u0026#34;VIIII\u0026#34;) s = s.replace(\u0026#34;XL\u0026#34;, \u0026#34;XXXX\u0026#34;).replace(\u0026#34;XC\u0026#34;, \u0026#34;LXXXX\u0026#34;) s = s.replace(\u0026#34;CD\u0026#34;, \u0026#34;CCCC\u0026#34;).replace(\u0026#34;CM\u0026#34;, \u0026#34;DCCCC\u0026#34;) for char in s: number += translations[char] print(number) romanToInt(\u0026#39;MCMIV\u0026#39;) Longest Common Prefix def LCP(X, Y): i = j = 0 while i \u0026lt; len(X) and j \u0026lt; len(Y): if X[i] != Y[j]: break i = i + 1 j = j + 1 return X[:i] # Function to find the longest common prefix (LCP) between a given set of strings def findLCP(words): prefix = words[0] for s in words: prefix = LCP(prefix, s) return prefix words = [\u0026#39;techie delight\u0026#39;, \u0026#39;tech\u0026#39;, \u0026#39;techie\u0026#39;, \u0026#39;technology\u0026#39;, \u0026#39;technical\u0026#39;] print(\u0026#39;The longest common prefix is\u0026#39;, findLCP(words)) Number of flips to make binary string alternate \u0026#34;\u0026#34;\u0026#34; Input : str = “001” Output : 1 Minimum number of flips required = 1 We can flip 1st bit from 0 to 1 Input : str = “0001010111” Output : 2 Minimum number of flips required = 2 We can flip 2nd bit from 0 to 1 and 9th bit from 1 to 0 to make alternate string “0101010101”. \u0026#34;\u0026#34;\u0026#34; def flip( ch): return \u0026#39;1\u0026#39; if (ch == \u0026#39;0\u0026#39;) else \u0026#39;0\u0026#39; # Utility method to get minimum flips when alternate string starts with expected char def getFlipWithStartingCharcter(str, expected): flipCount = 0 for i in range(len( str)): # if current character is not expected, increase flip count if (str[i] != expected): flipCount += 1 # flip expected character each time expected = flip(expected) return flipCount def minFlipToMakeStringAlternate(str):\treturn min(getFlipWithStartingCharcter(str, \u0026#39;0\u0026#39;), getFlipWithStartingCharcter(str, \u0026#39;1\u0026#39;)) str1 = \u0026#34;0001010111\u0026#34; print(minFlipToMakeStringAlternate(str1)) Find the first repeated word in string. from collections import Counter def firstRepeatedWord(sentence): lis = list(sentence.split(\u0026#34; \u0026#34;)) frequency = Counter(lis) for i in lis: if(frequency[i] \u0026gt; 1): return i sentence = \u0026#34;Vikram had been saying that he had been there\u0026#34; print(firstRepeatedWord(sentence)) Minimum number of swaps for bracket balancing. \u0026#34;\u0026#34;\u0026#34;Input : []][][ Output : 2 First swap: Position 3 and 4 [][]][ Second swap: Position 5 and 6 [][][] Input : [[][]] Output : 0 The string is already balanced. \u0026#34;\u0026#34;\u0026#34; def swapCount(s): swap = 0 imbalance = 0; for i in s: if i == \u0026#39;[\u0026#39;: imbalance -= 1 else: imbalance += 1 if imbalance \u0026gt; 0: swap += imbalance return swap s = \u0026#34;[]][][\u0026#34;; print(swapCount(s)) s = \u0026#34;[[][]]\u0026#34;; print(swapCount(s)) Find the longest common subsequence between two strings. \u0026#34;\u0026#34;\u0026#34; LCS for input Sequences “ABCDGH” and “AEDFHR” is “ADH” of length 3. LCS for input Sequences “AGGTAB” and “GXTXAYB” is “GTAB” of length 4. \u0026#34;\u0026#34;\u0026#34; def lcs(X, Y, m, n): L = [[0 for _ in range(n+1)] for _ in range(m+1)] # Following steps build L[m+1][n+1] in bottom up fashion. Note that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1] for i in range(m+1): for j in range(n+1): if i == 0 or j == 0: L[i][j] = 0 elif X[i-1] == Y[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j], L[i][j-1]) # Create a string variable to store the lcs string lcs = \u0026#34;\u0026#34; # Start from the right-most-bottom-most corner and one by one store characters in lcs[] i = m j = n while i \u0026gt; 0 and j \u0026gt; 0: # If current character in X[] and Y are same, then current character is part of LCS if X[i-1] == Y[j-1]: lcs += X[i-1] i -= 1 j -= 1 # If not same, then find the larger of two and go in the direction of larger value elif L[i-1][j] \u0026gt; L[i][j-1]: i -= 1 else: j -= 1 # We traversed the table in reverse order LCS is the reverse of what we got lcs = lcs[::-1] print(f\u0026#34;LCS of {X} and {Y} is {lcs}\u0026#34;) X = \u0026#34;AGGTAB\u0026#34; Y = \u0026#34;GXTXAYB\u0026#34; m = len(X) n = len(Y) lcs(X, Y, m, n) Program to generate all possible valid IP addresses from given string. \u0026#34;\u0026#34;\u0026#34; Input: 25525511135 Output: [“255.255.11.135”, “255.255.111.35”] Explanation: These are the only valid possible IP addresses. \u0026#34;\u0026#34;\u0026#34; def solve(s, i, j, level, temp, res): if (i == (j + 1) and level == 5): res.append(temp[1:]) # Digits of a number ranging 0-255 can lie only between 0-3 k = i while (k \u0026lt; i + 3 and k \u0026lt;= j): ad = s[i: k + 1] # Return if string starting with \u0026#39;0\u0026#39; or it is greater than 255. if ((s[i] == \u0026#39;0\u0026#39; and len(ad) \u0026gt; 1) or int(ad) \u0026gt; 255): return # Recursively call for another level. solve(s, k + 1, j, level + 1, f\u0026#39;{temp}.{ad}\u0026#39;, res) k += 1 s = \u0026#34;25525511135\u0026#34; n = len(s) ans = [] solve(s, 0, n - 1, 1, \u0026#34;\u0026#34;, ans) for s in ans: print(s) Write a program to find the smallest window that contains all characters of string itself. \u0026#34;\u0026#34;\u0026#34; Input: aabcbcdbca Output: dbca Explanation: Possible substrings= {aabcbcd, abcbcd, bcdbca, dbca....} Of the set of possible substrings \u0026#39;dbca\u0026#39; is the shortest substring having all the distinct characters of given string. Input: aaab Output: ab Explanation: Possible substrings={aaab, aab, ab} Of the set of possible substrings \u0026#39;ab\u0026#39; is the shortest substring having all the distinct characters of given string. \u0026#34;\u0026#34;\u0026#34; # Python program to find the smallest # window containing # all characters of a pattern from collections import defaultdict MAX_CHARS = 256 def findSubString(strr): n = len(strr) if n \u0026lt;= 1: return strr dist_count = len(set(list(strr))) curr_count = defaultdict(lambda: 0) count = 0 start = 0 min_len = n for j in range(min_len): curr_count[strr[j]] += 1 # If any distinct character matched, then increment count if curr_count[strr[j]] == 1: count += 1 # Try to minimize the window i.e., check if any character is occurring more no. of times than its occurrence in pattern, if yes then remove it from starting and also remove the useless characters. if count == dist_count: while curr_count[strr[start]] \u0026gt; 1: curr_count[strr[start]] -= 1 start += 1 # Update window size len_window = j - start + 1 if min_len \u0026gt; len_window: min_len = len_window start_index = start return str(strr[start_index: start_index + min_len]) print(f\u0026#39;Smallest window containing all distinct characters is: {findSubString(\u0026#34;aabcbcdbca\u0026#34;)}\u0026#39;) Minimum characters to be added at front to make string palindrome \u0026#34;\u0026#34;\u0026#34; Input : str = \u0026#34;ABC\u0026#34; Output : 2 We can make above string palindrome as \u0026#34;CBABC\u0026#34; by adding \u0026#39;B\u0026#39; and \u0026#39;C\u0026#39; at front. Input : str = \u0026#34;AACECAAAA\u0026#34;; Output : 2 We can make above string palindrome as AAAACECAAAA by adding two A\u0026#39;s at front of string. \u0026#34;\u0026#34;\u0026#34; def ispalindrome(s): l = len(s) i = 0 j = l - 1 while i \u0026lt;= j: if(s[i] != s[j]): return False i += 1 j -= 1 return True s = \u0026#34;BABABAA\u0026#34; cnt = 0 flag = 0 while s != \u0026#34;\u0026#34;: if(ispalindrome(s)): flag = 1 break else: cnt += 1 # erase the last element of the string s = s[:-1] # print the number of insertion at front if(flag): print(cnt) Find the smallest window in a string containing all characters of another string \u0026#34;\u0026#34;\u0026#34; nput: string = “this is a test string”, pattern = “tist” Output: Minimum window is “t stri” Explanation: “t stri” contains all the characters of pattern. Input: string = “geeksforgeeks”, pattern = “ork” Output: Minimum window is “ksfor” \u0026#34;\u0026#34;\u0026#34; def smallestWindow(s, p): n = len(s) if n \u0026lt; len(p): return -1 mp = [0]*256 # Starting index of ans start = 0 # Answer, Length of ans ans = n + 1 cnt = 0 # creating map for i in p: mp[ord(i)] += 1 if mp[ord(i)] == 1: cnt += 1 i = 0 # Traversing the window for j in range(n): mp[ord(s[j])] -= 1 if mp[ord(s[j])] == 0: cnt -= 1 while cnt == 0: if ans \u0026gt; j - i + 1: ans = j - i + 1 start = i # Sliding I # Calculation for removing I mp[ord(s[i])] += 1 if mp[ord(s[i])] \u0026gt; 0: cnt += 1 i += 1 if ans \u0026gt; n: return \u0026#34;-1\u0026#34; return s[start:start+ans] s = \u0026#34;ADOBECODEBANC\u0026#34; p = \u0026#34;ABC\u0026#34; result = smallestWindow(s, p) print(\u0026#34;Smallest window that contain all character :\u0026#34;, result) Recursively remove all adjacent duplicates def removeDuplicates(S): n = len(S) # We don\u0026#39;t need to do anything for empty or single character string. if (n \u0026lt; 2): return # j is used to store index is result string (or index of current distinct character) j = 0 # Traversing string for i in range(n): # If current character S[i] is different from S[j] if (S[j] != S[i]): j += 1 S[j] = S[i] # Putting string termination character. j += 1 S = S[:j] return S S1 = \u0026#34;geeksforgeeks\u0026#34; S1 = list(S1.rstrip()) S1 = removeDuplicates(S1) print(*S1, sep = \u0026#34;\u0026#34;) S2 = \u0026#34;aabcca\u0026#34; S2 = list(S2.rstrip()) S2 = removeDuplicates(S2) print(*S2, sep = \u0026#34;\u0026#34;) String matching where one string contains wildcard characters def match(first, second): # If we reach at the end of both strings, we are done if len(first) == 0 and len(second) == 0: return True # Make sure to eliminate consecutive \u0026#39;*\u0026#39; if len(first) \u0026gt; 1 and first[0] == \u0026#39;*\u0026#39;: i = 0 while i+1 \u0026lt; len(first) and first[i+1] == \u0026#39;*\u0026#39;: i += 1 first = first[i:] # Make sure that the characters after \u0026#39;*\u0026#39; are present # in second string. This function assumes that the first # string will not contain two consecutive \u0026#39;*\u0026#39; if len(first) \u0026gt; 1 and first[0] == \u0026#39;*\u0026#39; and len(second) == 0: return False # If the first string contains \u0026#39;?\u0026#39;, or current characters # of both strings match if (len(first) \u0026gt; 1 and first[0] == \u0026#39;?\u0026#39;) or (len(first) != 0 and len(second) != 0 and first[0] == second[0]): return match(first[1:], second[1:]) # If there is *, then there are two possibilities # a) We consider current character of second string # b) We ignore current character of second string. if len(first) != 0 and first[0] == \u0026#39;*\u0026#39;: return match(first[1:], second) or match(first, second[1:]) return False def test(first, second): if match(first, second): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) test(\u0026#34;g*ks\u0026#34;, \u0026#34;geeks\u0026#34;) # Yes test(\u0026#34;ge?ks*\u0026#34;, \u0026#34;geeksforgeeks\u0026#34;) # Yes test(\u0026#34;g*k\u0026#34;, \u0026#34;gee\u0026#34;) # No because \u0026#39;k\u0026#39; is not in second test(\u0026#34;*pqrs\u0026#34;, \u0026#34;pqrst\u0026#34;) # No because \u0026#39;t\u0026#39; is not in first test(\u0026#34;abc*bcd\u0026#34;, \u0026#34;abcdhghgbcd\u0026#34;) # Yes test(\u0026#34;abc*c?d\u0026#34;, \u0026#34;abcd\u0026#34;) # No because second must have 2 instances of \u0026#39;c\u0026#39; test(\u0026#34;*c*d\u0026#34;, \u0026#34;abcd\u0026#34;) # Yes test(\u0026#34;*?c*d\u0026#34;, \u0026#34;abcd\u0026#34;) # Yes test(\u0026#34;geeks**\u0026#34;, \u0026#34;geeks\u0026#34;) # Yes Function to find Number of customers who could not get a computer \u0026#34;\u0026#34;\u0026#34; Write a function “runCustomerSimulation” that takes following two inputs An integer ‘n’: total number of computers in a cafe and a string: A sequence of uppercase letters ‘seq’: Letters in the sequence occur in pairs. The first occurrence indicates the arrival of a customer; the second indicates the departure of that same customer. A customer will be serviced if there is an unoccupied computer. No letter will occur more than two times. Customers who leave without using a computer always depart before customers who are currently using the computers. There are at most 20 computers per cafe. For each set of input the function should output a number telling how many customers, if any walked away without using a computer. Return 0 if all the customers were able to use a computer. runCustomerSimulation (2, “ABBAJJKZKZ”) should return 0 runCustomerSimulation (3, “GACCBDDBAGEE”) should return 1 as ‘D’ was not able to get any computer runCustomerSimulation (3, “GACCBGDDBAEE”) should return 0 runCustomerSimulation (1, “ABCBCA”) should return 2 as ‘B’ and ‘C’ were not able to get any computer. runCustomerSimulation(1, “ABCBCADEED”) should return 3 as ‘B’, ‘C’ and ‘E’ were not able to get any computer. \u0026#34;\u0026#34;\u0026#34; MAX_CHAR = 26 # n is number of computers in cafe. # \u0026#39;seq\u0026#39; is given sequence of customer entry, exit events def runCustomerSimulation(n, seq): # seen[i] = 0, indicates that customer \u0026#39;i\u0026#39; is not in cafe # seen[1] = 1, indicates that customer \u0026#39;i\u0026#39; is in cafe but computer is not assigned yet. # seen[2] = 2, indicates that customer \u0026#39;i\u0026#39; is in cafe and has occupied a computer. seen = [0] * MAX_CHAR # Initialize result which is number of customers who could not get any computer. res = 0 occupied = 0 # To keep track of occupied # Traverse the input sequence for i in range(len(seq)): # Find index of current character in seen[0...25] ind = ord(seq[i]) - ord(\u0026#39;A\u0026#39;) # If first occurrence of \u0026#39;seq[i]\u0026#39; if seen[ind] == 0: # set the current character as seen seen[ind] = 1 # If number of occupied computers is less than n, then assign a computer to new customer if occupied \u0026lt; n: occupied+=1 # Set the current character as occupying a computer seen[ind] = 2 # Else this customer cannot get a computer, increment else: res+=1 # If this is second occurrence of \u0026#39;seq[i]\u0026#39; else: # Decrement occupied only if this customer was using a computer if seen[ind] == 2: occupied-=1 seen[ind] = 0 return res print (runCustomerSimulation(2, \u0026#34;ABBAJJKZKZ\u0026#34;)) print (runCustomerSimulation(3, \u0026#34;GACCBDDBAGEE\u0026#34;)) print (runCustomerSimulation(3, \u0026#34;GACCBGDDBAEE\u0026#34;)) print (runCustomerSimulation(1, \u0026#34;ABCBCA\u0026#34;)) print (runCustomerSimulation(1, \u0026#34;ABCBCADEED\u0026#34;)) Transform One String to Another using Minimum Number of Given Operation \u0026#34;\u0026#34;\u0026#34; Input: A = \u0026#34;ABD\u0026#34;, B = \u0026#34;BAD\u0026#34; Output: 1 Explanation: Pick B and insert it at front. Input: A = \u0026#34;EACBD\u0026#34;, B = \u0026#34;EABCD\u0026#34; Output: 3 Explanation: Pick B and insert at front, EACBD =\u0026gt; BEACD Pick A and insert at front, BEACD =\u0026gt; ABECD Pick E and insert at front, ABECD =\u0026gt; EABCD \u0026#34;\u0026#34;\u0026#34; # Function to find minimum number of operations required transform A to B def minOps(A, B): m = len(A) n = len(B) # This part checks whether conversion is possible or not if n != m: return -1 count = [0] * 256 for i in range(n):\t# count characters in A count[ord(B[i])] += 1 for i in range(n):\t# subtract count for every char in B count[ord(A[i])] -= 1 for i in range(256): # Check if all counts become 0 if count[i]: return -1 # This part calculates the number of operations required res = 0 i = n-1 j = n-1 while i \u0026gt;= 0: # if there is a mismatch, then keep incrementing result \u0026#39;res\u0026#39; until B[j] is not found in A[0..i] while i\u0026gt;= 0 and A[i] != B[j]: i -= 1 res += 1 # if A[i] and B[j] match if i \u0026gt;= 0: i -= 1 j -= 1 return res A = \u0026#34;EACBD\u0026#34; B = \u0026#34;EABCD\u0026#34; print(f\u0026#34;Minimum number of operations required is {str(minOps(A,B))}\u0026#34;) Check if two given strings are isomorphic to each other \u0026#34;\u0026#34;\u0026#34; Input: str1 = \u0026#34;aab\u0026#34;, str2 = \u0026#34;xxy\u0026#34; Output: True \u0026#39;a\u0026#39; is mapped to \u0026#39;x\u0026#39; and \u0026#39;b\u0026#39; is mapped to \u0026#39;y\u0026#39;. Input: str1 = \u0026#34;aab\u0026#34;, str2 = \u0026#34;xyz\u0026#34; Output: False One occurrence of \u0026#39;a\u0026#39; in str1 has \u0026#39;x\u0026#39; in str2 and other occurrence of \u0026#39;a\u0026#39; has \u0026#39;y\u0026#39;. \u0026#34;\u0026#34;\u0026#34; def areIsomorphic(str1, str2): #initializing a dictionary to store letters from str1 and str2 as key value pairs charCount = {} #initially setting c to \u0026#34;a\u0026#34; c = \u0026#34;a\u0026#34; #iterating over str1 and str2 for i in range(len(str1)): #if str1[i] is a key in charCount if str1[i] in charCount: c = charCount[str1[i]] if c != str2[i]: return False #if str2[i] is not a value in charCount elif str2[i] not in charCount.values(): charCount[str1[i]] = str2[i] else: return False return True str1 = \u0026#34;aac\u0026#34; str2 = \u0026#34;xxy\u0026#34; if (len(str1) == len(str2) and areIsomorphic(str1, str2)): print(\u0026#34;Is Isomorphic\u0026#34;) else: print(\u0026#34;Is Not Isomorphic\u0026#34;) Recursively print all sentences that can be formed from list of word lists \u0026#34;\u0026#34;\u0026#34; Input: {{\u0026#34;you\u0026#34;, \u0026#34;we\u0026#34;}, {\u0026#34;have\u0026#34;, \u0026#34;are\u0026#34;}, {\u0026#34;sleep\u0026#34;, \u0026#34;eat\u0026#34;, \u0026#34;drink\u0026#34;}} Output: you have sleep you have eat you have drink you are sleep you are eat you are drink we have sleep we have eat we have drink we are sleep we are eat we are drink \u0026#34;\u0026#34;\u0026#34; R = 3 C = 3 # A recursive function to print all possible sentences that can be formed from a list of word list def printUtil(arr, m, n, output): # Add current word to output array output[m] = arr[m][n] # If this is last word of current output sentence, then print the output sentence if m==R-1: for i in range(R): print (output[i],end= \u0026#34; \u0026#34;) print() return # Recur for next row for i in range(C): if arr[m+1][i] != \u0026#34;\u0026#34;: printUtil(arr, m+1, i, output) def printf(arr): # Create an array to store sentence output = [\u0026#34;\u0026#34;] * R # Consider all words for first row as starting points and print all sentences for i in range(C): if arr[0][i] != \u0026#34;\u0026#34;: printUtil(arr, 0, i, output) arr = [ [\u0026#34;you\u0026#34;, \u0026#34;we\u0026#34;,\u0026#34;\u0026#34;], [\u0026#34;have\u0026#34;, \u0026#34;are\u0026#34;,\u0026#34;\u0026#34;], [\u0026#34;sleep\u0026#34;, \u0026#34;eat\u0026#34;, \u0026#34;drink\u0026#34;]] printf(arr) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/string/","summary":"Check whether a String is Palindrome or not Find Duplicate characters in a string Write a Code to check whether one string is a rotation of another Write a Program to check whether a string is a valid shuffle of two strings or not Count and Say problem Write a program to find the longest Palindrome in a string.[ Longest palindromic Substring] Find Longest Recurring Subsequence in String Print all Subsequences of a string.","title":"DSA in Python - Strings"},{"content":" Find a value in a BST Deletion of a node in a BST Find min and max value in a BST Find inorder successor and inorder predecessor in a BST Check if a tree is a BST or not Populate Inorder successor of all nodes Find LCA of 2 nodes in a BST Construct BST from preorder traversal Convert Binary tree into BST Convert a normal BST into a Balanced BST Merge two BST Find Kth largest element and Kth smallest element in a BST Count pairs from 2 BST whose sum is equal to given value \u0026ldquo;X\u0026rdquo; Find the median of BST in O(n) time and O(1) space Count BST nodes that lie in a given range Replace every element with the least greater element on its right Given \u0026ldquo;n\u0026rdquo; appointments, find the conflicting appointments Preorder to Postorder Check whether BST contains Dead end Largest BST in a Binary Tree Flatten BST to sorted list Find a value in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Recursive function to insert a key into a BST def insert(root, key): # if the root is None, create a new node and return it if root is None: return Node(key) # if the given key is less than the root node, recur for the left subtree if key \u0026lt; root.data: root.left = insert(root.left, key) # if the given key is more than the root node, recur for the right subtree else: root.right = insert(root.right, key) return root # Recursive function to search in a given BST def search(root, key, parent): # if the key is not present in the key if root is None: print(\u0026#39;Key not found\u0026#39;) return # if the key is found if root.data == key: if parent is None: print(f\u0026#39;The node with key {key} is root node\u0026#39;) elif key \u0026lt; parent.data: print(\u0026#39;The given key is the left node of the node with key\u0026#39;, parent.data) else: print(\u0026#39;The given key is the right node of the node with key\u0026#39;, parent.data) return # if the given key is less than the root node, recur for the left subtree; # otherwise, recur for the right subtree if key \u0026lt; root.data: search(root.left, key, root) else: search(root.right, key, root) keys = [15, 10, 20, 8, 12, 16, 25] root = None for key in keys: root = insert(root, key) search(root, 25, None) Deletion of a node in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform inorder traversal on the BST def inorder(root): if root is None: return inorder(root.left) print(root.data, end=\u0026#39; \u0026#39;) inorder(root.right) # Function to find the maximum value node in the subtree rooted at `ptr` def findMaximumKey(ptr): while ptr.right: ptr = ptr.right return ptr # Recursive function to insert a key into a BST def insert(root, key): if root is None: return Node(key) # if the given key is less than the root node, recur for the left subtree if key \u0026lt; root.data: root.left = insert(root.left, key) # if the given key is more than the root node, recur for the right subtree else: root.right = insert(root.right, key) return root # Function to delete a node from a BST def deleteNode(root, key): if root is None: return root # if the given key is less than the root node, recur for the left subtree if key \u0026lt; root.data: root.left = deleteNode(root.left, key) # if the given key is more than the root node, recur for the right subtree elif key \u0026gt; root.data: root.right = deleteNode(root.right, key) # key found else: # Case 1: node to be deleted has no children (it is a leaf node) if root.left is None and root.right is None: # update root to None return None # Case 2: node to be deleted has two children elif root.left and root.right: # find its inorder predecessor node predecessor = findMaximumKey(root.left) # copy value of the predecessor to the current node root.data = predecessor.data # recursively delete the predecessor. Note that the # predecessor will have at most one child (left child) root.left = deleteNode(root.left, predecessor.data) # Case 3: node to be deleted has only one child else: # choose a child node child = root.left if root.left else root.right root = child return root keys = [15, 10, 20, 8, 12, 25] root = None for key in keys: root = insert(root, key) root = deleteNode(root, 12) inorder(root) Find min and max value in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform inorder traversal on the BST def inorder(root): if root is None: return inorder(root.left) print(root.data, end=\u0026#39; \u0026#39;) inorder(root.right) # Function to find the maximum value node in the subtree rooted at `ptr` def findMaximumKey(ptr): while ptr.right: ptr = ptr.right return ptr.data # Function to find the maximum value node in the subtree rooted at `ptr` def findMinimumKey(ptr): while ptr.left: ptr = ptr.left return ptr.data # Recursive function to insert a key into a BST def insert(root, key): if root is None: return Node(key) # if the given key is less than the root node, recur for the left subtree if key \u0026lt; root.data: root.left = insert(root.left, key) # if the given key is more than the root node, recur for the right subtree else: root.right = insert(root.right, key) return root keys = [15, 10, 20, 8, 12, 25] root = None for key in keys: root = insert(root, key) inorder(root) print() print(\u0026#34;Minimum: \u0026#34;,findMinimumKey(root)) print(\u0026#34;Maximum: \u0026#34;,findMaximumKey(root)) Find inorder successor and inorder predecessor in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) if key \u0026lt; root.data: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def findMinimum(root): while root.left: root = root.left return root def findMaximum(root): while root.right: root = root.right return root def findSuccessor(root, succ, key): if root is None: return succ # if a node with the desired value is found, the successor is the minimum value # node in its right subtree (if any) if root.data == key: if root.right: return findMinimum(root.right) # if the given key is less than the root node, recur for the left subtree elif key \u0026lt; root.data: # update successor to the current node before recursing in the left subtree succ = root return findSuccessor(root.left, succ, key) # if the given key is more than the root node, recur for the right subtree else: return findSuccessor(root.right, succ, key) return succ def findPredecessor(root, prec, key): if root is None: return prec # if a node with the desired value is found, the predecessor is the maximum value # node in its left subtree (if any) if root.data == key: if root.left: return findMaximum(root.left) # if the given key is less than the root node, recur for the left subtree elif key \u0026lt; root.data: return findPredecessor(root.left, prec, key) # if the given key is more than the root node, recur for the right subtree else: # update predecessor to the current node before recursing in the right subtree prec = root return findPredecessor(root.right, prec, key) return prec keys = [15, 10, 20, 8, 12, 16, 25] \u0026#39;\u0026#39;\u0026#39; Construct the following BST 15 / \\ / \\ 10 20 / \\ / \\ / \\ / \\ 8 12 16 25 \u0026#39;\u0026#39;\u0026#39; root = None for key in keys: root = insert(root, key) print(\u0026#34;SUCCESSOR\u0026#34;) # find inorder successor for each key for key in keys: succ = findSuccessor(root, None, key) if succ: print(f\u0026#39;The successor of node {key} is {succ.data}\u0026#39;) else: print(f\u0026#39;No Successor exists for node {key}\u0026#39;) print(\u0026#34;PREDECESSOR\u0026#34;) # find inorder predecessor for each key for key in keys: prec = findPredecessor(root, None, key) if prec: print(f\u0026#39;Predecessor of node {key} is {prec.data}\u0026#39;) else: print(\u0026#39;The predecessor doesn\\\u0026#39;t exist for node\u0026#39;, key) Check if a tree is a BST or not import sys class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) if key \u0026lt; root.data: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root # Function to perform inorder traversal on the given binary tree and # check if it is a BST or not. Here, `prev` is the previously processed node def isBST(root, prev): # base case: empty tree is a BST if root is None: return True # check if the left subtree is BST or not left = isBST(root.left, prev) # value of the current node should be more than that of the previous node if root.data \u0026lt;= prev.data: return False # update previous node data and check if the right subtree is BST or not prev.data = root.data return left and isBST(root.right, prev) # Function to determine whether a given binary tree is a BST def checkForBST(node): # pointer to store previously processed node in the inorder traversal prev = Node(-sys.maxsize) # check if nodes are processed in sorted order if isBST(node, prev): print(\u0026#39;The tree is a BST!\u0026#39;) else: print(\u0026#39;The tree is not a BST!\u0026#39;) def swap(root): left = root.left root.left = root.right root.right = left # keys = [15, 10, 20, 8, 12, 16, 25] keys=[8,3,1,6,7,10,14,4] root = None for key in keys: root = insert(root, key) # swap nodes swap(root) checkForBST(root) Populate Inorder successor of all nodes class Node: def __init__(self, data, left=None, right=None, next=None): self.data = data self.left = left self.right = right self.next = next # Function to set the next pointer of all nodes in a binary tree. # curr —\u0026gt; current node # prev —\u0026gt; previously processed node def setNextNode(curr, prev=None): if curr is None: return prev # recur for the left subtree prev = setNextNode(curr.left, prev) # set the previous node\u0026#39;s next pointer to the current node if prev: prev.next = curr # update the previous node to the current node prev = curr # recur for the right subtree return setNextNode(curr.right, prev) # Function to print inorder successor of all nodes of binary tree using the next pointer def printInorderSuccessors(root): # go to the leftmost node curr = root while curr.left: curr = curr.left # print inorder successor of all nodes while curr.next: print(f\u0026#39;The inorder successor of {curr.data} is {curr.next.data}\u0026#39;) curr = curr.next \u0026#39;\u0026#39;\u0026#39; Construct the following tree 1 / \\ / \\ 2 3 / / \\ / / \\ 4 5 6 / \\ / \\ 7 8 \u0026#39;\u0026#39;\u0026#39; root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) setNextNode(root) printInorderSuccessors(root) Find LCA of 2 nodes in a BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) # if the given key is less than the root node, recur for the left subtree if key \u0026lt; root.data: root.left = insert(root.left, key) # if the given key is more than the root node, recur for the right subtree else: root.right = insert(root.right, key) return root # Iterative function to search a given node in a BST def search(root, key): # traverse the tree and search for the key while root: # if the given key is less than the current node, go to the left # subtree; otherwise, go to the right subtree if key.data \u0026lt; root.data: root = root.left elif key.data \u0026gt; root.data: root = root.right # if the key is found, return true elif key == root: return True else: return False # we reach here if the key is not present in the BST return False # Recursive function to find the lowest common ancestor of given nodes # `x` and `y`, where both `x` and `y` are present in a BST def LCARecursive(root, x, y): if root is None: return None # if both `x` and `y` is smaller than the root, LCA exists in the left subtree if root.data \u0026gt; max(x.data, y.data): return LCARecursive(root.left, x, y) # if both `x` and `y` are greater than the root, LCA exists in the right subtree elif root.data \u0026lt; min(x.data, y.data): return LCARecursive(root.right, x, y) # if one key is greater (or equal) than the root and one key is smaller # (or equal) than the root, then the current node is LCA return root # Print lowest common ancestor of two nodes in a BST def LCA(root, x, y): # return if the tree is empty, or `x` or `y` is not present in the tree if not root or not search(root, x) or not search(root, y): return # `lca` stores the lowest common ancestor of `x` and `y` lca = LCARecursive(root, x, y) # if the lowest common ancestor exists, print it if lca: print(\u0026#39;LCA is\u0026#39;, lca.data) else: print(\u0026#39;LCA does not exist\u0026#39;) keys = [15, 10, 20, 8, 12, 16, 25] \u0026#39;\u0026#39;\u0026#39; Construct the following tree 15 / \\ / \\ 10 20 / \\ / \\ / \\ / \\ 8 12 16 25 \u0026#39;\u0026#39;\u0026#39; root = None for key in keys: root = insert(root, key) LCA(root, root.left.left, root.left.right) Construct BST from preorder traversal import sys class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right def inorder(root): if root is None: return inorder(root.left) print(root.key, end=\u0026#39; \u0026#39;) inorder(root.right) # Recursive function to build a BST from a preorder sequence. # start from the root node (the first element in a preorder sequence) # set the root node\u0026#39;s range as [-INFINITY, INFINITY] def buildBST(preorder, pIndex=0, min=-sys.maxsize, max=sys.maxsize): # Base case if pIndex == len(preorder): return None, pIndex # Return if the next element of preorder traversal is not in the valid range val = preorder[pIndex] if val \u0026lt; min or val \u0026gt; max: return None, pIndex # Construct the root node and increment `pIndex` root = Node(val) pIndex = pIndex + 1 # Since all elements in the left subtree of a BST must be less # than the root node\u0026#39;s value, set range as `[min, val-1]` and recur root.left, pIndex = buildBST(preorder, pIndex, min, val - 1) # Since all elements in the right subtree of a BST must be greater # than the root node\u0026#39;s value, set range as `[val+1…max]` and recur root.right, pIndex = buildBST(preorder, pIndex, val + 1, max) return root, pIndex \u0026#39;\u0026#39;\u0026#39; Construct the following BST 15 / \\ / \\ 10 20 / \\ / \\ / \\ / \\ 8 12 16 25 \u0026#39;\u0026#39;\u0026#39; preorder = [15, 10, 8, 12, 20, 16, 25] root = buildBST(preorder)[0] print(\u0026#39;Inorder traversal of BST is:\u0026#39;, end=\u0026#39; \u0026#39;) inorder(root) Convert Binary tree into BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform inorder traversal on the tree def inorder(root): if root is None: return inorder(root.left) print(root.data, end=\u0026#39; \u0026#39;) inorder(root.right) # Function to traverse the binary tree and store its keys in a set def extractKeys(root, keys): # base case if root is None: return extractKeys(root.left, keys) keys.append(root.data) extractKeys(root.right, keys) # Function to put keys back into a set in their correct order in a BST # by doing inorder traversal def convertToBST(root, it): if root is None: return convertToBST(root.left, it) root.data = next(it) convertToBST(root.right, it) # Function to convert a binary tree to BST by maintaining its original structure def convert(root): # traverse the binary tree and store its keys in a set keys = [] extractKeys(root, keys) # put back keys present in the set to their correct order in the BST it = iter(sorted(keys)) convertToBST(root, it) \u0026#39;\u0026#39;\u0026#39; Construct the following tree 8 / \\ / \\ 3 5 / \\ / \\ / \\ / \\ 10 2 4 6 \u0026#39;\u0026#39;\u0026#39; root = Node(8) root.left = Node(3) root.right = Node(5) root.left.left = Node(10) root.left.right = Node(2) root.right.left = Node(4) root.right.right = Node(6) convert(root) inorder(root) Convert a normal BST into a Balanced BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform the preorder traversal on a BST def preorder(root): if root is None: return print(root.data, end=\u0026#39; \u0026#39;) preorder(root.left) preorder(root.right) # Recursive function to push nodes of a given binary search tree into a # list in an inorder fashion def pushTreeNodes(root, nodes): if root is None: return pushTreeNodes(root.left, nodes) nodes.append(root) pushTreeNodes(root.right, nodes) # Recursive function to construct a height-balanced BST from # given nodes in sorted order def buildBalancedBST(nodes, start, end): if start \u0026gt; end: return None # find the middle index mid = (start + end) // 2 # The root node will be a node present at the mid-index root = nodes[mid] # recursively construct left and right subtree root.left = buildBalancedBST(nodes, start, mid - 1) root.right = buildBalancedBST(nodes, mid + 1, end) # return root node return root # Function to construct a height-balanced BST from an unbalanced BST def constructBalancedBST(root): # Push nodes of a given binary search tree into a list in sorted order nodes = [] pushTreeNodes(root, nodes) # Construct a height-balanced BST from sorted BST nodes return buildBalancedBST(nodes, 0, len(nodes) - 1) root = Node(20) root.left = Node(15) root.left.left = Node(10) root.left.left.left = Node(5) root.left.left.left.left = Node(2) root.left.left.left.right = Node(8) root = constructBalancedBST(root) print(\u0026#39;Preorder traversal of the constructed BST is \u0026#39;, end=\u0026#39;\u0026#39;) preorder(root) Merge two BST class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to push a BST node at the front of a doubly linked list def push(root, head): root.right = head if head: head.left = root head = root return head # Function to print and count the total number of nodes in a doubly-linked list def size(node): counter = 0 while node: node = node.right counter = counter + 1 return counter # Function to print preorder traversal of the BST def preorder(root): if root is None: return print(root.data, end=\u0026#39; \u0026#39;) preorder(root.left) preorder(root.right) # Recursive method to construct a balanced BST from a sorted doubly linked list def convertSortedDLLToBalancedBST(head, n): if n \u0026lt;= 0: return None, head # recursively construct the left subtree leftSubTree, head = convertSortedDLLToBalancedBST(head, n // 2) # `head` now points to the middle node of the sorted DDL # make the middle node of the sorted DDL as the root node of the BST root = head # update left child of the root node root.left = leftSubTree # update the head reference of the doubly linked list head = head.right # recursively construct the right subtree with the remaining nodes root.right, head = convertSortedDLLToBalancedBST(head, n - (n // 2 + 1)) # +1 for the root # return the root node return root, head # Recursive method to convert a BST into a doubly-linked list. It takes # the BST\u0026#39;s root node and the head node of the doubly linked list as an argument def convertBSTtoSortedDLL(root, head=None): if root is None: return head # recursively convert the right subtree head = convertBSTtoSortedDLL(root.right, head) # push the current node at the front of the doubly linked list head = push(root, head) # recursively convert the left subtree head = convertBSTtoSortedDLL(root.left, head) return head # Recursive method to merge two doubly-linked lists into a # single doubly linked list in sorted order def sortedMerge(first, second): # if the first list is empty, return the second list if first is None: return second # if the second list is empty, return the first list if second is None: return first # if the head node of the first list is smaller if first.data \u0026lt; second.data: first.right = sortedMerge(first.right, second) first.right.left = first return first # if the head node of the second list is smaller else: second.right = sortedMerge(first, second.right) second.right.left = second return second # Function to merge two balanced BSTs into a single balanced BST def merge(first, second): # merge both BSTs into a sorted doubly linked list head = sortedMerge(convertBSTtoSortedDLL(first), convertBSTtoSortedDLL(second)) # construct a balanced BST from a sorted doubly linked list root, head = convertSortedDLLToBalancedBST(head, size(head)) return root \u0026#39;\u0026#39;\u0026#39; Construct the first BST 20 / \\ 10 30 / \\ 25 100 \u0026#39;\u0026#39;\u0026#39; first = Node(20) first.left = Node(10) first.right = Node(30) first.right.left = Node(25) first.right.right = Node(100) \u0026#39;\u0026#39;\u0026#39; Construct the second BST 50 / \\ 5 70 \u0026#39;\u0026#39;\u0026#39; second = Node(50) second.left = Node(5) second.right = Node(70) # merge both BSTs root = merge(first, second) preorder(root) Find Kth largest element and Kth smallest element in a BST import sys class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) if key \u0026lt; root.data: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root # Function to find the k\u0026#39;th largest node in a BST. Here, `i` denotes the total number of nodes processed so far def kthLargest(root, i, k): if root is None: return None, i # search in the right subtree left, i = kthLargest(root.right, i, k) # if k\u0026#39;th largest is found in the left subtree, return it if left: return left, i i = i + 1 # if the current node is k\u0026#39;th largest, return its value if i == k: return root, i # otherwise, search in the left subtree return kthLargest(root.left, i, k) def findKthLargest(root, k): i = 0 # traverse the tree in an inorder fashion and return k\u0026#39;th node return kthLargest(root, i, k)[0] def kthSmallest(root, counter, k): if root is None: return None, counter # recur for the left subtree left, counter = kthSmallest(root.left, counter, k) # if k\u0026#39;th smallest node is found if left: return left, counter # if the root is k\u0026#39;th smallest node counter = counter + 1 if counter == k: return root, counter # recur for the right subtree only if k\u0026#39;th smallest node is not found # in the right subtree ret, counter = kthSmallest(root.right, counter, k) return ret, counter def findKthSmallest(root, k): counter = 0 # recursively find the k\u0026#39;th smallest node return kthSmallest(root, counter, k)[0] keys = [15, 10, 20, 8, 12, 16, 25] root = None for key in keys: root = insert(root, key) k = 2 print(f\u0026#34;{k}th LARGEST NODE\u0026#34;) result = findKthLargest(root, k) if result != sys.maxsize: print(result.data) else: print(\u0026#39;Invalid Input\u0026#39;) k = 4 print(f\u0026#34;{k}th SMALLEST NODE\u0026#34;) result = findKthSmallest(root, k) if result: print(result.data) else: print(f\u0026#39;{k}\\\u0026#39;th smallest node does not exist.\u0026#39;) Count pairs from 2 BST whose sum is equal to given value \u0026ldquo;X\u0026rdquo; class Node: def __init__(self,data): self.data = data self.left = None self.right = None root1,root2 = None,None # def to count pairs from two BSTs whose sum is equal to a given value x pairCount = 0 def traverseTree(root1, root2, sum): if root1 is None or root2 is None: return traverseTree(root1.left, root2, sum) traverseTree(root1.right, root2, sum) diff = sum - root1.data findPairs(root2, diff) def findPairs(root2 , diff): global pairCount if root2 is None: return if (diff \u0026gt; root2.data) : findPairs(root2.right, diff) else : findPairs(root2.left, diff) if (root2.data == diff): pairCount += 1 def countPairs(root1, root2, sum): global pairCount traverseTree(root1, root2, sum) return pairCount root1 = Node(5) root1.left = Node(3) root1.right = Node(7) root1.left.left = Node(2) root1.left.right = Node(4) root1.right.left = Node(6) root1.right.right = Node(8) # formation of BST 2 root2 = Node(10) root2.left = Node(6) root2.right = Node(15) root2.left.left = Node(3) root2.left.right = Node(8) root2.right.left = Node(11) root2.right.right = Node(18) x = 16 print(f\u0026#34;Pairs = {countPairs(root1, root2, x)}\u0026#34;) Find the median of BST in O(n) time and O(1) space _MIN=float(\u0026#39;-inf\u0026#39;) _MAX=float(\u0026#39;inf\u0026#39;) # Helper function that allocates a new node with the given data and None left and right pointers. class newNode: def __init__(self, data): self.data = data self.left = None self.right = None # A utility function to insert a new node with given key in BST def insert(node,key): if node is None: return newNode(key) # Otherwise, recur down the tree if (key \u0026lt; node.data): node.left = insert(node.left, key) elif (key \u0026gt; node.data): node.right = insert(node.right, key) # return the (unchanged) node pointer return node #Function to count nodes in a binary search tree using Morris Inorder traversal def counNodes(root): count = 0 if root is None: return count current = root while (current != None): if current.left is None: # Count node if its left is None count+=1 # Move to its right current = current.right else: # Find the inorder predecessor of current pre = current.left while pre.right not in [None, current]: pre = pre.right #Make current as right child of its inorder predecessor if pre.right is None: pre.right = current current = current.left else: pre.right = None # Increment count if the current node is to be visited count += 1 current = current.right return count def findMedian(root): if root is None: return 0 count = counNodes(root) currCount = 0 current = root while (current != None): if current.left is None: # count current node currCount += 1 # check if current node is the median # Odd case if (count % 2 != 0 and currCount == (count + 1)//2): return prev.data # Even case elif (count % 2 == 0 and currCount == (count//2)+1): return (prev.data + current.data)//2 # Update prev for even no. of nodes prev = current #Move to the right current = current.right else: # Find the inorder predecessor of current pre = current.left while pre.right not in [None, current]: pre = pre.right # Make current as right child of its inorder predecessor if pre.right is None: pre.right = current current = current.left else: pre.right = None prev = pre # Count current node currCount+= 1 # Check if the current node is the median if (count % 2 != 0 and currCount == (count + 1) // 2 ): return current.data elif (count%2 == 0 and currCount == (count // 2) + 1): return (prev.data+current.data)//2 # update prev node for the case of even # no. of nodes prev = current current = current.right \u0026#34;\u0026#34;\u0026#34; Constructed binary tree is 50 / \\ 30 70 / \\ / \\ 20 40 60 80 \u0026#34;\u0026#34;\u0026#34; root = newNode(50) insert(root, 30) insert(root, 20) insert(root, 40) insert(root, 70) insert(root, 60) insert(root, 80) print(\u0026#34;Median of BST is \u0026#34;,findMedian(root)) Count BST nodes that lie in a given range class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def insert(root, key): if root is None: return Node(key) if key \u0026lt; root.data: root.left = insert(root.left, key) else: root.right = insert(root.right, key) return root def countNodes(root, low, high): if root is None: return 0 # keep track of the total number of nodes in the tree rooted with `root`. # that lies within the current range [low, high] count = 0 # increment count if the current node lies within the current range if low \u0026lt;= root.data \u0026lt;= high: count += 1 # recur for the left subtree count += countNodes(root.left, low, high) # recur for the right subtree and return the total count return count + countNodes(root.right, low, high) low, high = 12, 20 keys = [15, 25, 20, 22, 30, 18, 10, 8, 9, 12, 6] root = None for key in keys: root = insert(root, key) print(\u0026#39;The total number of nodes is\u0026#39;, countNodes(root, low, high)) Replace every element with the least greater element on its right \u0026#34;\u0026#34;\u0026#34; Given an array of integers, replace every element with the least greater element on its right side in the array. If there are no greater elements on the right side, replace it with -1. Examples: Input: [8, 58, 71, 18, 31, 32, 63, 92, 43, 3, 91, 93, 25, 80, 28] Output: [18, 63, 80, 25, 32, 43, 80, 93, 80, 25, 93, -1, 28, -1, -1] \u0026#34;\u0026#34;\u0026#34; class Node: def __init__(self, d): self.data = d self.left = None self.right = None # A utility function to insert a new node with given data in BST and find its successor def insert(node, data): global succ # If the tree is empty, return a new node root = node if node is None: return Node(data) # If key is smaller than root\u0026#39;s key, go to left subtree and set successor as current node if (data \u0026lt; node.data): #print(\u0026#34;1\u0026#34;) succ = node root.left = insert(node.left, data) # Go to right subtree elif (data \u0026gt; node.data): root.right = insert(node.right, data) return root # Function to replace every element with the least greater element on its right def replace(arr, n): global succ root = None # Start from right to left for i in range(n - 1, -1, -1): succ = None # Insert current element into BST and find its inorder successor root = insert(root, arr[i]) # Replace element by its inorder successor in BST arr[i] = succ.data if succ else -1 return arr arr = [ 8, 58, 71, 18, 31, 32, 63, 92, 43, 3, 91, 93, 25, 80, 28 ] n = len(arr) succ = None arr = replace(arr, n) print(*arr) Given \u0026ldquo;n\u0026rdquo; appointments, find the conflicting appointments \u0026#34;\u0026#34;\u0026#34; Input: appointments[] = { {1, 5} {3, 7}, {2, 6}, {10, 15}, {5, 6}, {4, 100}} Output: Following are conflicting intervals [3,7] Conflicts with [1,5] [2,6] Conflicts with [1,5] [5,6] Conflicts with [3,7] [4,100] Conflicts with [1,5] \u0026#34;\u0026#34;\u0026#34; class Interval: def __init__(self): self.low = None self.high = None # Structure to represent a node in Interval Search Tree class ITNode: def __init__(self): self.max = None self.i = None self.left = None self.right = None def newNode(j): #print(j) temp = ITNode() temp.i = j temp.max = j[1] return temp # A utility function to check if given two intervals overlap def doOVerlap(i1, i2): if (i1[0] \u0026lt; i2[1] and i2[0] \u0026lt; i1[1]): return True return False # Function to create a new node def insert(node, data): global succ # If the tree is empty, return a new node root = node if node is None: return newNode(data) # If key is smaller than root\u0026#39;s key, go to left subtree and set successor as current node print(node) if (data[0] \u0026lt; node.i[0]): root.left = insert(node.left, data) # Go to right subtree else: root.right = insert(node.right, data) if root.max \u0026lt; data[1]: root.max = data[1] return root # The main function that searches a given interval i in a given Interval Tree. def overlapSearch(root, i): if root is None: return None # If given interval overlaps with root if (doOVerlap(root.i, i)): return root.i # If left child of root is present and max of left child is greater than or # equal to given interval, then i may overlap with an interval is left subtree if (root.left != None and root.left.max \u0026gt;= i[0]): return overlapSearch(root.left, i) # Else interval can only overlap with right subtree return overlapSearch(root.right, i) # This function prints all conflicting appointments in a given array of appointments. def printConflicting(appt, n): # Create an empty Interval Search Tree, add first appointment root = None root = insert(root, appt[0]) # Process rest of the intervals for i in range(1, n): # If current appointment conflicts with any of the existing intervals, print it res = overlapSearch(root, appt[i]) if (res != None): print(\u0026#34;[\u0026#34;, appt[i][0], \u0026#34;,\u0026#34;, appt[i][1], \u0026#34;] Conflicts with [\u0026#34;, res[0], \u0026#34;,\u0026#34;, res[1], \u0026#34;]\u0026#34;) # Insert this appointment root = insert(root, appt[i]) appt = [ [ 1, 5 ], [ 3, 7 ], [ 2, 6 ], [ 10, 15 ], [ 5, 6 ], [ 4, 100 ] ] n = len(appt) print(\u0026#34;Following are conflicting intervals\u0026#34;) printConflicting(appt, n) Preorder to Postorder # A class to store a binary tree node class Node: def __init__(self, key): self.key = key def postorder(root): if root is None: return postorder(root.left) postorder(root.right) print(root.key, end=\u0026#39; \u0026#39;) # Recursive function to build a BST from a preorder sequence. def constructBST(preorder, start, end): # base case if start \u0026gt; end: return None # Construct the root node of the subtree formed by keys of the # preorder sequence in range `[start, end]` node = Node(preorder[start]) # search the index of the first element in the current range of preorder # sequence larger than the root node\u0026#39;s value i = start while i \u0026lt;= end: if preorder[i] \u0026gt; node.key: break i = i + 1 # recursively construct the left subtree node.left = constructBST(preorder, start + 1, i - 1) # recursively construct the right subtree node.right = constructBST(preorder, i, end) # return current node return node \u0026#39;\u0026#39;\u0026#39; Construct the following BST 15 / \\ / \\ 10 20 / \\ / \\ / \\ / \\ 8 12 16 25 \u0026#39;\u0026#39;\u0026#39; preorder = [15, 10, 8, 12, 20, 16, 25] root = constructBST(preorder, 0, len(preorder) - 1) print(\u0026#39;Postorder traversal of BST is \u0026#39;, end=\u0026#39;\u0026#39;) postorder(root) Check whether BST contains Dead end \u0026#34;\u0026#34;\u0026#34; Given a Binary search Tree that contains positive integer values greater than 0. The task is to check whether the BST contains a dead end or not. Here Dead End means, we are not able to insert any element after that node. Examples: Input : 8 / \\ 5 9 / \\ 2 7 / 1 Output : Yes Explanation : Node \u0026#34;1\u0026#34; is the dead End because after that we cant insert any element. Input : 8 / \\ 7 10 / / \\ 2 9 13 Output : Yes Explanation : We can\u0026#39;t insert any element at node 9. \u0026#34;\u0026#34;\u0026#34; all_nodes = set() leaf_nodes = set() # A BST node class newNode: def __init__(self, data): self.data = data self.left = None self.right = None # A utility function to insert a new Node with given key in BST def insert(node, key): if node is None: return newNode(key) # Otherwise, recur down the tree if (key \u0026lt; node.data): node.left = insert(node.left, key) elif (key \u0026gt; node.data): node.right = insert(node.right, key) # return the (unchanged) Node pointer return node # Function to store all node of given binary search tree def storeNodes(root): global all_nodes global leaf_nodes if root is None: return # store all node of binary search tree all_nodes.add(root.data) # store leaf node in leaf_hash if root.left is None and root.right is None: leaf_nodes.add(root.data) return # recur call rest tree storeNodes(root. left) storeNodes(root.right) # Returns true if there is a dead end in tree, else false. def isDeadEnd(root): global all_nodes global leaf_nodes if root is None: return False # create two empty hash sets that store all BST elements and leaf nodes respectively. # insert 0 in \u0026#39;all_nodes\u0026#39; for handle case if bst contain value 1 all_nodes.add(0) # Call storeNodes function to store all BST Node storeNodes(root) return any(((x + 1) in all_nodes and (x - 1) in all_nodes) for x in leaf_nodes) root = None root = insert(root, 8) root = insert(root, 5) root = insert(root, 2) root = insert(root, 3) root = insert(root, 7) root = insert(root, 11) root = insert(root, 4) if(isDeadEnd(root) == True): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) Largest BST in a Binary Tree import sys sys.setrecursionlimit(1000000) from collections import deque IMIN = float(\u0026#39;-inf\u0026#39;) IMAX = float(\u0026#39;inf\u0026#39;) class newNode: def __init__(self, val): self.right = None self.data = val self.left = None def largestBst(root): if root is None: return IMAX,IMIN,0 if root.left is None and root.right is None: return root.data,root.data,1 left=largestBst(root.left) right=largestBst(root.right) ans=[0,0,0] if left[1]\u0026lt;root.data and right[0]\u0026gt;root.data: ans[0]=min(left[0],right[0],root.data) ans[1]=max(right[1],left[1],root.data) ans[2]=1+left[2]+right[2] return ans ans[0]=IMIN ans[1]=IMAX ans[2]=max(left[2],right[2]) return ans[2] \u0026#34;\u0026#34;\u0026#34; 50 / \\ 75 45 / 40 \u0026#34;\u0026#34;\u0026#34; root = newNode(50) root.left = newNode(75) root.right = newNode(45) root.left.left = newNode(40) print(\u0026#34;Size of the largest BST is\u0026#34;,largestBst(root)) Flatten BST to sorted list global prev class node : def __init__(self, data): self.data = data self.left = None self.right = None def printTree(parent): root = parent while root is not None: print(root.data,end=\u0026#39; \u0026#39;) root = root.right def inorder(root): global prev if root is None: return inorder(root.left) print(root.data,end=\u0026#39; \u0026#39;) inorder(root.right) # Function to flatten binary tree using level order traversal BFS def flatten(parent): global prev # Dummy node dummy = node(-1) # Pointer to previous element prev = dummy # Calling in-order traversal inorder(parent) prev.left = None prev.right = None # Delete dummy node return dummy.right root = node(5) root.left = node(3) root.right = node(7) root.left.left = node(2) root.left.right = node(4) root.right.left = node(6) root.right.right = node(8) printTree(flatten(root)) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/binary-search-tree/","summary":"Find a value in a BST Deletion of a node in a BST Find min and max value in a BST Find inorder successor and inorder predecessor in a BST Check if a tree is a BST or not Populate Inorder successor of all nodes Find LCA of 2 nodes in a BST Construct BST from preorder traversal Convert Binary tree into BST Convert a normal BST into a Balanced BST Merge two BST Find Kth largest element and Kth smallest element in a BST Count pairs from 2 BST whose sum is equal to given value \u0026ldquo;X\u0026rdquo; Find the median of BST in O(n) time and O(1) space Count BST nodes that lie in a given range Replace every element with the least greater element on its right Given \u0026ldquo;n\u0026rdquo; appointments, find the conflicting appointments Preorder to Postorder Check whether BST contains Dead end Largest BST in a Binary Tree Flatten BST to sorted list Find a value in a BST class Node: def __init__(self, data, left=None, right=None): self.","title":"DSA in Python - Binary Search Trees"},{"content":" Level order traversal AKA BFS Reverse Level Order traversal Height of a tree Diameter of a tree Mirror of a tree / Invert Binary Tree Inorder, Preorder and Postorder Tree Traversal (Recursive Method) Left View of a tree Right View of Tree Top View of a tree Bottom View of a tree Zig-Zag traversal of a binary tree Check if a tree is balanced or not Diagonal Traversal of a Binary tree Boundary traversal of a Binary tree Construct Binary Tree from String with Bracket Representation Convert Binary tree into Doubly Linked List Convert Binary tree into Sum tree Construct Binary tree from Inorder and preorder traversal Find minimum swaps required to convert a Binary tree into BST Check if Binary tree is Sum tree or not Check if all leaf nodes are at same level or not Check if a Binary Tree contains duplicate subtrees of size 2 or more Check if 2 trees are mirror or not Sum of Nodes on the Longest path from root to leaf node Check if given graph is tree or not Find Largest subtree sum in a tree Maximum Sum of nodes in Binary tree such that no two are adjacent Print all \u0026ldquo;K\u0026rdquo; Sum paths in a Binary tree Find Least Common Ancestor in a Binary tree Find distance between 2 nodes in a Binary tree Kth Ancestor of node in a Binary tree Find all Duplicate subtrees in a Binary tree Tree Isomorphism Problem Level order traversal AKA BFS class Node: def __init__(self, key): self.data = key self.left = None self.right = None def printLevelOrder(root): # Base Case if root is None: return # Create an empty queue for level order traversal queue = [] # Enqueue Root and initialize height queue.append(root) while(len(queue) \u0026gt; 0): # Print front of queue and remove it from queue print(queue[0].data) node = queue.pop(0) # Enqueue left child if node.left is not None: queue.append(node.left) # Enqueue right child if node.right is not None: queue.append(node.right) root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) print(\u0026#34;Level Order Traversal of binary tree is -\u0026#34;) printLevelOrder(root) Reverse Level Order traversal from collections import deque class Node: def __init__(self, data): self.data = data self.left = None self.right = None def reverseLevelOrder(root): q = deque() q.append(root) ans = deque() while q: node = q.popleft() if node is None: continue ans.appendleft(node.data) if node.right: q.append(node.right) if node.left: q.append(node.left) return ans root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) print (\u0026#34;Level Order traversal of binary tree is\u0026#34;, reverseLevelOrder(root)) Height of a tree \u0026#34;\u0026#34;\u0026#34; Given a binary tree, find height of it. Height of empty tree is -1, height of tree with one node is 0 \u0026#34;\u0026#34;\u0026#34; class Node: # Constructor to create a new node def __init__(self, data): self.data = data self.left = None self.right = None # Compute the \u0026#34;maxDepth\u0026#34; of a tree -- the number of nodes along the longest path from the root node down to the # farthest leaf node def maxDepth(node): if node is None: return 0 ; else : # Compute the depth of each subtree lDepth = maxDepth(node.left) rDepth = maxDepth(node.right) # Use the larger one if (lDepth \u0026gt; rDepth): return lDepth+1 else: return rDepth+1 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) print (\u0026#34;Height of tree is %d\u0026#34; %(maxDepth(root))) Diameter of a tree class Node: def __init__(self, data): self.data = data self.left = None self.right = None def height(node): # Base Case : Tree is empty if node is None: return 0 # If tree is not empty then height = 1 + max of left # height and right heights return 1 + max(height(node.left), height(node.right)) # Function to get the diameter of a binary tree def diameter(root): # Base Case when tree is empty if root is None: return 0 # Get the height of left and right sub-trees lheight = height(root.left) rheight = height(root.right) # Get the diameter of left and right sub-trees ldiameter = diameter(root.left) rdiameter = diameter(root.right) # Return max of the following tree: # 1) Diameter of left subtree # 2) Diameter of right subtree # 3) Height of left subtree + height of right subtree +1 return max(lheight + rheight + 1, max(ldiameter, rdiameter)) \u0026#34;\u0026#34;\u0026#34; Constructed binary tree is 1 / \\ 2 3 / \\ 4 5 \u0026#34;\u0026#34;\u0026#34; root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) print(diameter(root)) Mirror of a tree / Invert Binary Tree from collections import deque class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Function to perform preorder traversal on a given binary tree def preorder(root): if root is None: return print(root.data, end=\u0026#39; \u0026#39;) preorder(root.left) preorder(root.right) # Utility function to swap left subtree with right subtree def swap(root): if root is None: return temp = root.left root.left = root.right root.right = temp # Iterative function to invert a given binary tree using a queue def invertBinaryTree(root): # base case: if the tree is empty if root is None: return # maintain a queue and push the root node q = deque() q.append(root) # loop till queue is empty while q: # dequeue front node curr = q.popleft() # swap the left child with the right child swap(curr) # enqueue left child of the popped node if curr.left: q.append(curr.left) # enqueue right child of the popped node if curr.right: q.append(curr.right) \u0026#39;\u0026#39;\u0026#39; Construct the following tree 1 / \\ / \\ 2 3 / \\ / \\ 4 5 6 7 \u0026#39;\u0026#39;\u0026#39; root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) invertBinaryTree(root) preorder(root) Inorder, Preorder and Postorder Tree Traversal (Recursive Method) class Node: def __init__(self, data=None, left=None, right=None): self.data = data self.left = left self.right = right def preorder(root): if root is None: return print(root.data, end=\u0026#39; \u0026#39;) preorder(root.left) preorder(root.right) def inorder(root): if root is None: return inorder(root.left) print(root.data, end=\u0026#39; \u0026#39;) inorder(root.right) def postorder(root): if root is None: return postorder(root.left) postorder(root.right) print(root.data, end=\u0026#39; \u0026#39;) \u0026#39;\u0026#39;\u0026#39; Construct the following tree 1 / \\ / \\ 2 3 / / \\ / / \\ 4 5 6 / \\ / \\ 7 8 \u0026#39;\u0026#39;\u0026#39; root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) print(\u0026#34;Preorder: \u0026#34;,preorder(root)) print(\u0026#34;Inorder: \u0026#34;,inorder(root)) print(\u0026#34;PostOrder: \u0026#34;,postorder(root)) Left View of a tree class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right def leftView(root, level=1, last_level=0): # base case: empty tree if root is None: return last_level # if the current node is the first node of the current level if last_level \u0026lt; level: # print the node\u0026#39;s data print(root.key, end=\u0026#39; \u0026#39;) # update the last level to the current level last_level = level # recur for the left and right subtree by increasing the level by 1 last_level = leftView(root.left, level + 1, last_level) last_level = leftView(root.right, level + 1, last_level) return last_level root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) leftView(root) Right View of Tree class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right def RightView(root, level=1, lastLevel=0): if root is None: return lastLevel # if the current node is the last node of the current level if lastLevel \u0026lt; level: # print the node\u0026#39;s data print(root.key, end=\u0026#39; \u0026#39;) # update the last level to the current level lastLevel = level # recur for the right and left subtree by increasing level by 1 lastLevel = RightView(root.right, level + 1, lastLevel) lastLevel = RightView(root.left, level + 1, lastLevel) return lastLevel root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) RightView(root) Top View of a tree class Node: def __init__(self, key=None, left=None, right=None): self.key = key self.left = left self.right = right # Recursive function to perform preorder traversal on the tree and fill the dictionary. # Here, the node has `dist` horizontal distance from the tree\u0026#39;s root, and the level represents the node\u0026#39;s level. def printTop(root, dist, level, d): if root is None: return # if the current level is less than the maximum level seen so far for the same horizontal distance, or if # the horizontal distance is seen for the first time, update the dictionary if dist not in d or level \u0026lt; d[dist][1]: # update value and level for current distance d[dist] = (root.key, level) # recur for the left subtree by decreasing horizontal distance and increasing level by 1 printTop(root.left, dist - 1, level + 1, d) # recur for the right subtree by increasing both level and horizontal distance by 1 printTop(root.right, dist + 1, level + 1, d) def printTopView(root): # create a dictionary where # key —\u0026gt; relative horizontal distance of the node from the root node, and # value —\u0026gt; pair containing the node\u0026#39;s value and its level d = {} # perform preorder traversal on the tree and fill the dictionary printTop(root, 0, 0, d) # traverse the dictionary in sorted order of keys and print the top view for key in sorted(d.keys()): print(d.get(key)[0], end=\u0026#39; \u0026#39;) root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) printTopView(root) Bottom View of a tree class Node: def __init__(self, key=None, left=None, right=None): self.key = key self.left = left self.right = right # Recursive function to perform preorder traversal on the tree and fill the map. # Here, the node has `dist` horizontal distance from the tree\u0026#39;s root, and the `level` represents the node\u0026#39;s level. def printBottom(root, dist, level, d): # base case: empty tree if root is None: return # if the current level is more than or equal to the maximum level seen so far for the same horizontal distance # or horizontal distance is seen for the first time, update the dictionary if dist not in d or level \u0026gt;= d[dist][1]: # update value and level for the current distance d[dist] = (root.key, level) # recur for the left subtree by decreasing horizontal distance and increasing level by 1 printBottom(root.left, dist - 1, level + 1, d) # recur for the right subtree by increasing both level and horizontal distance by 1 printBottom(root.right, dist + 1, level + 1, d) # Function to print the bottom view of a given binary tree def printBottomView(root): # create a dictionary where # key —\u0026gt; relative horizontal distance of the node from the root node, and # value —\u0026gt; pair containing the node\u0026#39;s value and its level d = {} # perform preorder traversal on the tree and fill the dictionary printBottom(root, 0, 0, d) # traverse the dictionary in sorted order of their keys and print the bottom view for key in sorted(d.keys()): print(d.get(key)[0], end=\u0026#39; \u0026#39;) root = Node(1) root.left = Node(2) root.right = Node(3) root.left.right = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) printBottomView(root) Zig-Zag traversal of a binary tree from collections import deque class Node: def __init__(self, key=None, left=None, right=None): self.key = key self.left = left self.right = right # Traverse the tree in a preorder fashion and store nodes in a dictionary corresponding to their level def preorder(root, level, d): if root is None: return # insert the current node and its level into the dictionary # if the level is odd, insert at the back; otherwise, search at front if level % 2 == 1: d.setdefault(level, deque()).append(root.key) else: d.setdefault(level, deque()).appendleft(root.key) # recur for the left and right subtree by increasing the level by 1 preorder(root.left, level + 1, d) preorder(root.right, level + 1, d) # Recursive function to print spiral order traversal of a given binary tree def SpiralOrderTraversal(root): # create an empty dictionary to store nodes between given levels d = {} # traverse the tree and insert its nodes into the dictionary corresponding to their level preorder(root, 1, d) # iterate through the dictionary and print all nodes present at every level for i in range(1, len(d) + 1): print(f\u0026#39;Level {i}:\u0026#39;, list(d[i])) root = Node(15) root.left = Node(10) root.right = Node(20) root.left.left = Node(8) root.left.right = Node(12) root.right.left = Node(16) root.right.right = Node(25) root.left.left.left = Node(20) root.right.right.right = Node(30) SpiralOrderTraversal(root) Check if a tree is balanced or not \u0026#34;\u0026#34;\u0026#34; Given a binary tree, write an efficient algorithm to check if it is height-balanced or not. In a height-balanced tree, the absolute difference between the height of the left and right subtree for every node is 0 or 1. \u0026#34;\u0026#34;\u0026#34; class Node: def __init__(self, key, left=None, right=None): self.key = key self.left = left self.right = right # Recursive function to check if a given binary tree is height-balanced or not def isHeightBalanced(root, isBalanced=True): # base case: tree is empty or not balanced if root is None or not isBalanced: return 0, isBalanced # get the height of the left subtree left_height, isBalanced = isHeightBalanced(root.left, isBalanced) # get the height of the right subtree right_height, isBalanced = isHeightBalanced(root.right, isBalanced) # tree is unbalanced if the absolute difference between the height of # its left and right subtree is more than 1 if abs(left_height - right_height) \u0026gt; 1: isBalanced = False # return height of subtree rooted at the current node return max(left_height, right_height) + 1, isBalanced \u0026#39;\u0026#39;\u0026#39; Construct the following tree 1 / \\ / \\ 2 3 / \\ / 4 5 6 \u0026#39;\u0026#39;\u0026#39; root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) if isHeightBalanced(root)[1]: print(\u0026#39;Binary tree is balanced\u0026#39;) else: print(\u0026#39;Binary tree is not balanced\u0026#39;) Diagonal Traversal of a Binary tree class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Recursive function to perform preorder traversal on the tree and # fill the dictionary with diagonal elements def printDiagonal(node, diagonal, d): # base case: empty tree if node is None: return # insert the current node into the current diagonal d.setdefault(diagonal, []).append(node.data) # recur for the left subtree by increasing diagonal by 1 printDiagonal(node.left, diagonal + 1, d) # recur for the right subtree with the same diagonal printDiagonal(node.right, diagonal, d) # Function to print the diagonal elements of a given binary tree def printDiagonalElements(root): # create an empty dictionary to store the diagonal element in every slope d = {} # perform preorder traversal on the tree and fill the dictionary printDiagonal(root, 0, d) # traverse the dictionary and print diagonal elements for i in range(len(d)): print(d.get(i)) \u0026#39;\u0026#39;\u0026#39; Construct the following tree 1 / \\ / \\ 2 3 / / \\ / / \\ 4 5 6 / \\ / \\ 7 8 \u0026#39;\u0026#39;\u0026#39; root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.right.left = Node(5) root.right.right = Node(6) root.right.left.left = Node(7) root.right.left.right = Node(8) printDiagonalElements(root) Boundary traversal of a Binary tree class Node: def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right def isLeaf(self): return self.left is None and self.right is None # Recursive function to print the left boundary of the given binary tree # in a top-down fashion, except for the leaf nodes def printLeftBoundary(root): if root is None: return node = root while not node.isLeaf(): print(node.data, end=\u0026#39; \u0026#39;) # next process, the left child of `root` if it exists; otherwise, move to the right child node = node.left if node.left else node.right # Recursive function to print the right boundary of the given binary tree # in a bottom-up fashion, except for the leaf nodes def printRightBoundary(root): if root is None or root.isLeaf(): return # recur for the right child of `root` if it exists; otherwise, recur for the left child printRightBoundary(root.right if root.right else root.left) # To ensure bottom-up order, print the value of the nodes after recursion unfolds print(root.data, end=\u0026#39; \u0026#39;) # Recursive function to print the leaf nodes of the given binary tree in an inorder fashion def printLeafNodes(root): if root is None: return printLeafNodes(root.left) # print only leaf nodes if root.isLeaf(): print(root.data, end=\u0026#39; \u0026#39;) # recur for the right subtree printLeafNodes(root.right) # Function to perform the boundary traversal on a given tree def performBoundaryTraversal(root): if root is None: return # print the root node print(root.data, end=\u0026#39; \u0026#39;) # print the left boundary (except leaf nodes) printLeftBoundary(root.left) # print all leaf nodes if not root.isLeaf(): printLeafNodes(root) # print the right boundary (except leaf nodes) printRightBoundary(root.right) root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) root.left.left.left = Node(8) root.left.left.right = Node(9) root.left.right.right = Node(10) root.right.right.left = Node(11) root.left.left.right.left = Node(12) root.left.left.right.right = Node(13) root.right.right.left.left = Node(14) performBoundaryTraversal(root) Construct Binary Tree from String with Bracket Representation class newNode: def __init__(self, data): self.data = data self.left = self.right = None def preOrder(node): if node is None: return print(node.data, end=\u0026#34; \u0026#34;) preOrder(node.left) preOrder(node.right) # function to return the index of close parenthesis def findIndex(Str, si, ei): if (si \u0026gt; ei): return -1 s = [] for i in range(si, ei + 1): # if open parenthesis, push it if (Str[i] == \u0026#39;(\u0026#39;): s.append(Str[i]) elif (Str[i] == \u0026#39;)\u0026#39;): if (s[-1] == \u0026#39;(\u0026#39;): s.pop(-1) # if stack is empty, this is # the required index if len(s) == 0: return i # if not found return -1 return -1 # function to conStruct tree from String def treeFromString(Str, si, ei): # Base case if (si \u0026gt; ei): return None # new root root = newNode(ord(Str[si]) - ord(\u0026#39;0\u0026#39;)) index = -1 # if next char is \u0026#39;(\u0026#39; find the # index of its complement \u0026#39;)\u0026#39; if (si + 1 \u0026lt;= ei and Str[si + 1] == \u0026#39;(\u0026#39;): index = findIndex(Str, si + 1, ei) # if index found if (index != -1): # call for left subtree root.left = treeFromString(Str, si + 2, index - 1) # call for right subtree root.right = treeFromString(Str, index + 2, ei - 1) return root Str = \u0026#34;4(2(3)(1))(6(5))\u0026#34; root = treeFromString(Str, 0, len(Str) - 1) preOrder(root) Convert Binary tree into Doubly Linked List class Node(object): def __init__(self, item): self.data = item self.left = None self.right = None def BTToDLLUtil(root): \u0026#34;\u0026#34;\u0026#34;This is a utility function to convert the binary tree to doubly linked list. Most of the core task is done by this function.\u0026#34;\u0026#34;\u0026#34; if root is None: return root # Convert left subtree and link to root if root.left: # Convert the left subtree left = BTToDLLUtil(root.left) # Find inorder predecessor, After this loop, left will point to the # inorder predecessor of root while left.right: left = left.right # Make root as next of predecessor left.right = root # Make predecessor as previous of root root.left = left # Convert the right subtree and link to root if root.right: # Convert the right subtree right = BTToDLLUtil(root.right) # Find inorder successor, After this loop, right will point to the inorder successor of root while right.left: right = right.left # Make root as previous of successor right.left = root # Make successor as next of root root.right = right return root def BTToDLL(root): if root is None: return root # Convert to doubly linked list using BLLToDLLUtil root = BTToDLLUtil(root) # We need pointer to left most node which is head of the constructed Doubly Linked list while root.left: root = root.left return root def print_list(head): if head is None: return while head: print(head.data, end = \u0026#34; \u0026#34;) head = head.right root = Node(10) root.left = Node(12) root.right = Node(15) root.left.left = Node(25) root.left.right = Node(30) root.right.left = Node(36) head = BTToDLL(root) print_list(head) Convert Binary tree into Sum tree # Given a Binary Tree where each node has positive and negative values. Convert this to a tree where each node contains the sum of the left and right sub trees in the original tree. The values of leaf nodes are changed to 0. class node: def __init__(self, data): self.left = None self.right = None self.data = data # Convert a given tree to a tree where every node contains sum of values of # nodes in left and right subtrees in the original tree def toSumTree(Node) : if Node is None: return 0 # Store the old value old_val = Node.data # Recursively call for left and right subtrees and store the sum as new value of this node Node.data = toSumTree(Node.left) + toSumTree(Node.right) # Return the sum of values of nodes in left and right subtrees and old_value of this node return Node.data + old_val # A utility function to print inorder traversal of a Binary Tree def printInorder(Node): if Node is None: return printInorder(Node.left) print(Node.data, end = \u0026#34; \u0026#34;) printInorder(Node.right) # Utility function to create a new Binary Tree node def newNode(data) : temp = node(0) temp.data = data temp.left = None temp.right = None return temp root = newNode(10) root.left = newNode(-2) root.right = newNode(6) root.left.left = newNode(8) root.left.right = newNode(-4) root.right.left = newNode(7) root.right.right = newNode(5) toSumTree(root) print(\u0026#34;Inorder Traversal of the resultant tree is: \u0026#34;) printInorder(root) Construct Binary tree from Inorder and preorder traversal # A class to store a binary tree node class Node: # Constructor def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = right # Recursive function to perform inorder traversal on a given binary tree def inorderTraversal(root): if root is None: return inorderTraversal(root.left) print(root.data, end=\u0026#39; \u0026#39;) inorderTraversal(root.right) # Recursive function to perform postorder traversal on a given binary tree def preorderTraversal(root): if root is None: return print(root.data, end=\u0026#39; \u0026#39;) preorderTraversal(root.left) preorderTraversal(root.right) # Recursive function to construct a binary tree from a given inorder and preorder sequence def construct(start, end, preorder, pIndex, d): # base case if start \u0026gt; end: return None, pIndex # The next element in `preorder[]` will be the root node of subtree # formed by sequence represented by `inorder[start, end]` root = Node(preorder[pIndex]) pIndex = pIndex + 1 # get the index of the root node in inorder to determine the # left and right subtree boundary index = d[root.data] # recursively construct the left subtree root.left, pIndex = construct(start, index - 1, preorder, pIndex, d) # recursively construct the right subtree root.right, pIndex = construct(index + 1, end, preorder, pIndex, d) # return current node return root, pIndex # Construct a binary tree from inorder and preorder traversals. # This function assumes that the input is valid i.e., given inorder and preorder sequence forms a binary tree def constructTree(inorder, preorder): # create a dictionary to efficiently find the index of any element in a given inorder sequence d = {} for i, e in enumerate(inorder): d[e] = i # `pIndex` stores the index of the next unprocessed node in a preorder sequence; # start with the root node (present at 0th index) pIndex = 0 return construct(0, len(inorder) - 1, preorder, pIndex, d)[0] \u0026#39;\u0026#39;\u0026#39; Construct the following tree 1 / \\ / \\ 2 3 / / \\ / / \\ 4 5 6 / \\ / \\ 7 8 \u0026#39;\u0026#39;\u0026#39; inorder = [4, 2, 1, 7, 5, 8, 3, 6] preorder = [1, 2, 4, 3, 5, 7, 8, 6] root = constructTree(inorder, preorder) print(\u0026#39;The inorder traversal is \u0026#39;, end=\u0026#39;\u0026#39;) inorderTraversal(root) print(\u0026#39;\\nThe preorder traversal is \u0026#39;, end=\u0026#39;\u0026#39;) preorderTraversal(root) Find minimum swaps required to convert a Binary tree into BST \u0026#34;\u0026#34;\u0026#34; The idea is to use the fact that inorder traversal of Binary Search Tree is in increasing order of their value. So, find the inorder traversal of the Binary Tree and store it in the array and try to sort the array. The minimum number of swap required to get the array sorted will be the answer. \u0026#34;\u0026#34;\u0026#34; def inorder(a, n, index): global v # If index is greater or equal to vector size if (index \u0026gt;= n): return inorder(a, n, 2 * index + 1) # Push elements in vector v.append(a[index]) inorder(a, n, 2 * index + 2) def minSwaps(): global v t = [[0, 0] for _ in range(len(v))] ans = -2 for i in range(len(v)): t[i][0], t[i][1] = v[i], i t, i = sorted(t), 0 while i \u0026lt; len(t): if (i == t[i][1]): i += 1 continue else: # Swapping of elements t[i][0], t[t[i][1]][0] = t[t[i][1]][0], t[i][0] t[i][1], t[t[i][1]][1] = t[t[i][1]][1], t[i][1] # Second is not equal to i if (i == t[i][1]): i -= 1 i += 1 ans += 1 return ans v = [] a = [5, 6, 7, 8, 9, 10, 11] n = len(a) inorder(a, n, 0) print(minSwaps()) Check if Binary tree is Sum tree or not class node: def __init__(self, x): self.data = x self.left = None self.right = None def isLeaf(node): if node is None: return 0 if node.left is None and node.right is None: return 1 return 0 # returns data if SumTree property holds for the given tree else return -1 def isSumTree(node): if node is None: return 0 ls = isSumTree(node.left) #To stop for further traversal of tree if found not sumTree if(ls == -1): return -1 rs = isSumTree(node.right) #To stop for further traversal of tree if found not sumTree if(rs == -1): return -1 return ls + rs + node.data if (isLeaf(node) or ls + rs == node.data) else -1 root = node(26) root.left = node(10) root.right = node(3) root.left.left = node(4) root.left.right = node(6) root.right.right = node(3) if(isSumTree(root)): print(\u0026#34;The given tree is a SumTree \u0026#34;) else: print(\u0026#34;The given tree is not a SumTree \u0026#34;) Check if all leaf nodes are at same level or not class Node: def __init__(self, data): self.data = data self.left = None self.right = None # Recursive function which check whether all leaves are at same level def checkUtil(root, level): if root is None: return True # If a tree node is encountered if root.left is None and root.right is None: # When a leaf node is found first time if check.leafLevel == 0 : check.leafLevel = level # Set first leaf found return True # If this is not first leaf node, compare its level with first leaf\u0026#39;s level return level == check.leafLevel # If this is not first leaf node, compare its level with first leaf\u0026#39;s level return (checkUtil(root.left, level+1)and checkUtil(root.right, level+1)) def check(root): level = 0 check.leafLevel = 0 return (checkUtil(root, level)) root = Node(12) root.left = Node(5) root.left.left = Node(3) root.left.right = Node(9) root.left.left.left = Node(1) root.left.right.left = Node(2) if(check(root)): print(\u0026#34;Leaves are at same level\u0026#34;) else: print(\u0026#34;Leaves are not at same level\u0026#34;) Check if a Binary Tree contains duplicate subtrees of size 2 or more # Helper function that allocates a new node with the given data and None left and right pointers. class newNode: def __init__(self, data): self.data = data self.left = self.right = None def inorder(node, m): if (not node): return \u0026#34;\u0026#34; Str = \u0026#34;(\u0026#34; Str += inorder(node.left, m) Str += str(node.data) Str += inorder(node.right, m) Str += \u0026#34;)\u0026#34; # Subtree already present (Note that we use unordered_map instead of unordered_set because we want to print multiple duplicates only once, consider example of 4 in above subtree, it should be printed only once. if (Str in m and m[Str] == 1): print(node.data, end = \u0026#34; \u0026#34;) if Str in m: m[Str] += 1 else: m[Str] = 1 return Str # Wrapper over inorder() def printAllDups(root): m = {} inorder(root, m) root = None root = newNode(1) root.left = newNode(2) root.right = newNode(3) root.left.left = newNode(4) root.right.left = newNode(2) root.right.left.left = newNode(4) root.right.right = newNode(4) printAllDups(root) Check if 2 trees are mirror or not def checkMirrorTree(M, N, u1, v1, u2, v2): mp = {} # Traverse first tree nodes for i in range(N): if u1[i] in mp: mp[u1[i]].append(v1[i]) else: mp[u1[i]] = [] # Traverse second tree nodes for i in range(N): if u2[i] in mp and len(mp[u2[i]]) \u0026gt; 0: if(mp[u2[i]][-1] != v2[i]): return 0 mp[u2[i]].pop() return 1 M, N = 7, 6 #Tree 1 u1 = [ 1, 1, 1, 10, 10, 10 ] v1 = [ 10, 7, 3, 4, 5, 6 ] #Tree 2 u2 = [ 1, 1, 1, 10, 10, 10 ] v2 = [ 3, 7, 10, 6, 5, 4 ] if(checkMirrorTree(M, N, u1, v1, u2, v2)): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) Sum of Nodes on the Longest path from root to leaf node \u0026#34;\u0026#34;\u0026#34; Input : Binary tree: 4 / \\ 2 5 / \\ / \\ 7 1 2 3 / 6 Output : 13 4 / \\ 2 5 / \\ / \\ 7 1 2 3 / 6 The highlighted nodes (4, 2, 1, 6) above are part of the longest root to leaf path having sum = (4 + 2 + 1 + 6) = 13 \u0026#34;\u0026#34;\u0026#34; class getNode: def __init__(self, data): self.data = data self.left = self.right = None # function to find the Sum of nodes on the longest path from root to leaf node def SumOfLongRootToLeafPath(root, Sum, Len, maxLen, maxSum): # if true, then we have traversed a root to leaf path if (not root): # update maximum Length and maximum Sum according to the given conditions if (maxLen[0] \u0026lt; Len): maxLen[0] = Len maxSum[0] = Sum elif (maxLen[0]== Len and maxSum[0] \u0026lt; Sum): maxSum[0] = Sum return # recur for left subtree SumOfLongRootToLeafPath(root.left, Sum + root.data, Len + 1, maxLen, maxSum) # recur for right subtree SumOfLongRootToLeafPath(root.right, Sum + root.data, Len + 1, maxLen, maxSum) # utility function to find the Sum of nodes on the longest path from root to leaf node def SumOfLongRootToLeafPathUtil(root): # if tree is NULL, then Sum is 0 if (not root): return 0 maxSum = [-999999999999] maxLen = [0] # finding the maximum Sum \u0026#39;maxSum\u0026#39; for the maximum Length root to leaf path SumOfLongRootToLeafPath(root, 0, 0, maxLen, maxSum) return maxSum[0] root = getNode(4) root.left = getNode(2) root.right = getNode(5) root.left.left = getNode(7) root.left.right = getNode(1) root.right.left = getNode(2) root.right.right = getNode(3) root.left.right.left = getNode(6) print(\u0026#34;Sum = \u0026#34;, SumOfLongRootToLeafPathUtil(root)) Check if given graph is tree or not from collections import defaultdict class Graph(): def __init__(self, V): self.V = V self.graph = defaultdict(list) def addEdge(self, v, w): self.graph[v].append(w) self.graph[w].append(v) # A recursive function that uses visited[] and parent to detect cycle in subgraph reachable from vertex v. def isCyclicUtil(self, v, visited, parent): # Mark current node as visited visited[v] = True # Recur for all the vertices adjacent for this vertex for i in self.graph[v]: # If an adjacent is not visited, then recur for that adjacent if visited[i] == False: if self.isCyclicUtil(i, visited, v) == True: return True # If an adjacent is visited and not parent of current vertex, then there is a cycle. elif i != parent: return True return False # Returns true if the graph is a tree, else false. def isTree(self): # Mark all the vertices as not visited and not part of recursion stack visited = [False] * self.V # The call to isCyclicUtil serves multiple purposes. It returns true if graph reachable from vertex 0 is cyclic. # It also marks all vertices reachable from 0. if self.isCyclicUtil(0, visited, -1) == True: return False return all(visited[i] != False for i in range(self.V)) # Driver program to test above functions g1 = Graph(5) g1.addEdge(1, 0) g1.addEdge(0, 2) g1.addEdge(0, 3) g1.addEdge(3, 4) print (\u0026#34;Graph is a Tree\u0026#34; if g1.isTree() == True else \u0026#34;Graph is a not a Tree\u0026#34;) g2 = Graph(5) g2.addEdge(1, 0) g2.addEdge(0, 2) g2.addEdge(2, 1) g2.addEdge(0, 3) g2.addEdge(3, 4) print (\u0026#34;Graph is a Tree\u0026#34; if g2.isTree() == True else \u0026#34;Graph is a not a Tree\u0026#34;) Find Largest subtree sum in a tree # Function to create new tree node. class newNode: def __init__(self, key): self.key = key self.left = self.right = None # Helper function to find largest subtree sum recursively. def findLargestSubtreeSumUtil(root, ans): if (root == None): return 0 # Subtree sum rooted at current node. currSum = (root.key + findLargestSubtreeSumUtil(root.left, ans) + findLargestSubtreeSumUtil(root.right, ans)) # Update answer if current subtree sum is greater than answer so far. ans[0] = max(ans[0], currSum) # Return current subtree sum to its parent node. return currSum # Function to find largest subtree sum. def findLargestSubtreeSum(root): if (root == None): return 0 ans = [float(\u0026#39;-inf\u0026#39;)] findLargestSubtreeSumUtil(root, ans) return ans[0] # Constructed Tree # 1 # / \\ # / \\ # -2 3 # /\\ /\\ # / \\ / \\ # 4 5 -6 2 root = newNode(1) root.left = newNode(-2) root.right = newNode(3) root.left.left = newNode(4) root.left.right = newNode(5) root.right.left = newNode(-6) root.right.right = newNode(2) print(findLargestSubtreeSum(root)) Maximum Sum of nodes in Binary tree such that no two are adjacent \u0026#34;\u0026#34;\u0026#34; Given a binary tree with a value associated with each node, we need to choose a subset of these nodes such that the sum of selected nodes is maximum under a constraint that no two chosen nodes in the subset should be directly connected, that is, if we have taken a node in our sum then we can’t take any of its children in consideration and vice versa. \u0026#34;\u0026#34;\u0026#34; class newNode: def __init__(self, key): self.data = key self.left = None self.right = None def maxSumHelper(root) : if (root == None): sum = [0, 0] return sum sum1 = maxSumHelper(root.left) sum2 = maxSumHelper(root.right) sum = [0, 0] # This node is included (Left and right children are not included) sum[0] = sum1[1] + sum2[1] + root.data # This node is excluded (Either left or right child is included) sum[1] = (max(sum1[0], sum1[1]) + max(sum2[0], sum2[1])) return sum def maxSum(root) : res = maxSumHelper(root) return max(res[0], res[1]) root = newNode(10) root.left = newNode(1) root.left.left = newNode(2) root.left.left.left = newNode(1) root.left.right = newNode(3) root.left.right.left = newNode(4) root.left.right.right = newNode(5) print(maxSum(root)) Print all \u0026ldquo;K\u0026rdquo; Sum paths in a Binary tree \u0026#34;\u0026#34;\u0026#34; A binary tree and a number k are given. Print every path in the tree with sum of the nodes in the path as k. A path can start from any node and end at any node and must be downward only, i.e. they need not be root node and leaf node; and negative numbers can also be there in the tree. \u0026#34;\u0026#34;\u0026#34; def printVector(v, i): for j in range(i, len(v)): print(v[j], end = \u0026#34; \u0026#34;) print() class newNode: def __init__(self, key): self.data = key self.left = None self.right = None # This function prints all paths that have sum k def printKPathUtil(root, path, k): if (not root) : return # add current node to the path path.append(root.data) # check if there\u0026#39;s any k sum path in the left sub-tree. printKPathUtil(root.left, path, k) # check if there\u0026#39;s any k sum path in the right sub-tree. printKPathUtil(root.right, path, k) # check if there\u0026#39;s any k sum path that terminates at this node # Traverse the entire path as there can be negative elements too f = 0 for j in range(len(path) - 1, -1, -1): f += path[j] # If path sum is k, prthe path if (f == k) : printVector(path, j) # Remove the current element from the path path.pop(-1) # A wrapper over printKPathUtil() def printKPath(root, k): path =[] printKPathUtil(root, path, k) root = newNode(1) root.left = newNode(3) root.left.left = newNode(2) root.left.right = newNode(1) root.left.right.left = newNode(1) root.right = newNode(-1) root.right.left = newNode(4) root.right.left.left = newNode(1) root.right.left.right = newNode(2) root.right.right = newNode(5) root.right.right.right = newNode(2) k = 5 printKPath(root, k) Find Least Common Ancestor in a Binary tree class Node: def __init__(self, key): self.key = key self.left = None self.right = None # This function returns pointer to LCA of two given values n1 and n2 # This function assumes that n1 and n2 are present in Binary Tree def findLCA(root, n1, n2): if root is None: return None # If either n1 or n2 matches with root\u0026#39;s key, report the presence by returning root (Note that if a key is # ancestor of other, then the ancestor key becomes LCA if root.key == n1 or root.key == n2: return root # Look for keys in left and right subtrees left_lca = findLCA(root.left, n1, n2) right_lca = findLCA(root.right, n1, n2) # If both of the above calls return Non-NULL, then one key is present in once subtree and other is present in other, # So this node is the LCA if left_lca and right_lca: return root # Otherwise check if left subtree or right subtree is LCA return left_lca if left_lca is not None else right_lca root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) print (\u0026#34;LCA(4,5) = \u0026#34;, findLCA(root, 4, 5).key) print (\u0026#34;LCA(4,6) = \u0026#34;, findLCA(root, 4, 6).key) print (\u0026#34;LCA(3,4) = \u0026#34;, findLCA(root, 3, 4).key) print (\u0026#34;LCA(2,4) = \u0026#34;, findLCA(root, 2, 4).key) Find distance between 2 nodes in a Binary tree \u0026#34;\u0026#34;\u0026#34; A python program to find distance between n1 and n2 in binary tree \u0026#34;\u0026#34;\u0026#34; class Node: def __init__(self, data): self.data = data self.left = self.right = None # This function returns pointer to LCA of two given values n1 and n2. def find_least_common_ancestor(root, n1, n2): if root is None: return root # If either n1 or n2 matches with root\u0026#39;s key, report the presence by returning root if root.data == n1 or root.data == n2: return root # Look for keys in left and right subtrees left = find_least_common_ancestor(root.left, n1, n2) right = find_least_common_ancestor(root.right, n1, n2) if left and right: return root # Otherwise check if left subtree or right subtree is Least Common Ancestor if left: return left else: return right # function to find distance of any node from root def find_distance_from_ancestor_node(root, data): # case when we reach a beyond leaf node or when tree is empty if root is None: return -1 # Node is found then return 0 if root.data == data: return 0 left = find_distance_from_ancestor_node(root.left, data) right = find_distance_from_ancestor_node(root.right, data) distance = max(left, right) return distance+1 if distance \u0026gt;= 0 else -1 # function to find distance between two nodes in a binary tree def find_distance_between_two_nodes(root: Node, n1: int, n2: int): lca = find_least_common_ancestor(root, n1, n2) return find_distance_from_ancestor_node(lca, n1) + find_distance_from_ancestor_node(lca, n2) if lca else -1 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) root.right.left.right = Node(8) print(\u0026#34;Dist(4,5) = \u0026#34;, find_distance_between_two_nodes(root, 4, 5)) print(\u0026#34;Dist(4,6) = \u0026#34;, find_distance_between_two_nodes(root, 4, 6)) print(\u0026#34;Dist(3,4) = \u0026#34;, find_distance_between_two_nodes(root, 3, 4)) print(\u0026#34;Dist(2,4) = \u0026#34;, find_distance_between_two_nodes(root, 2, 4)) print(\u0026#34;Dist(8,5) = \u0026#34;, find_distance_between_two_nodes(root, 8, 5)) Kth Ancestor of node in a Binary tree \u0026#34;\u0026#34;\u0026#34; Given a binary tree in which nodes are numbered from 1 to n. Given a node and a positive integer K. We have to print the Kth ancestor of the given node in the binary tree. If there does not exist any such ancestor then print -1. \u0026#34;\u0026#34;\u0026#34; class newNode: def __init__(self, data): self.data = data self.left = None self.right = None # recursive function to calculate Kth ancestor def kthAncestorDFS(root, node, k): if (not root): return None if (root.data == node or (kthAncestorDFS(root.left, node, k)) or (kthAncestorDFS(root.right, node, k))): if (k[0] \u0026gt; 0): k[0] -= 1 elif (k[0] == 0): # print the kth ancestor print(\u0026#34;Kth ancestor is:\u0026#34;, root.data) # return None to stop further backtracking return None # return current node to previous call return root root = newNode(1) root.left = newNode(2) root.right = newNode(3) root.left.left = newNode(4) root.left.right = newNode(5) k = [2] node = 5 # print kth ancestor of given node parent = kthAncestorDFS(root,node,k) # check if parent is not None, it means there is no Kth ancestor of the node if (parent): print(\u0026#34;-1\u0026#34;) Find all Duplicate subtrees in a Binary tree # Helper function that allocates a new node with the given data and None left and right pointers. class newNode: def __init__(self, data): self.data = data self.left = self.right = None def inorder(node, m): if (not node): return \u0026#34;\u0026#34; Str = \u0026#34;(\u0026#34; Str += inorder(node.left, m) Str += str(node.data) Str += inorder(node.right, m) Str += \u0026#34;)\u0026#34; # Subtree already present (Note that we use unordered_map instead of unordered_set because we want to print # multiple duplicates only once, consider example of 4 in above subtree, it should be printed only once. if (Str in m and m[Str] == 1): print(node.data, end = \u0026#34; \u0026#34;) if Str in m: m[Str] += 1 else: m[Str] = 1 return Str # Wrapper over inorder() def printAllDups(root): m = {} inorder(root, m) root = None root = newNode(1) root.left = newNode(2) root.right = newNode(3) root.left.left = newNode(4) root.right.left = newNode(2) root.right.left.left = newNode(4) root.right.right = newNode(4) printAllDups(root) Tree Isomorphism Problem \u0026#34;\u0026#34;\u0026#34; Write a function to detect if two trees are isomorphic. Two trees are called isomorphic if one of them can be obtained from other by a series of flips, i.e. by swapping left and right children of a number of nodes. Any number of nodes at any level can have their children swapped. Two empty trees are isomorphic. \u0026#34;\u0026#34;\u0026#34; class Node: def __init__(self, data): self.data = data self.left = None self.right = None # Check if the binary tree is isomorphic or not def isIsomorphic(n1, n2): # Both roots are None, trees isomorphic by definition if n1 is None and n2 is None: return True # Exactly one of the n1 and n2 is None, trees are not isomorphic if n1 is None or n2 is None: return False if n1.data != n2.data : return False # There are two possible cases for n1 and n2 to be isomorphic # Case 1: The subtrees rooted at these nodes have NOT been \u0026#34;Flipped\u0026#34;. # Both of these subtrees have to be isomorphic, hence the \u0026amp;\u0026amp; # Case 2: The subtrees rooted at these nodes have been \u0026#34;Flipped\u0026#34; return ((isIsomorphic(n1.left, n2.left)and isIsomorphic(n1.right, n2.right)) or (isIsomorphic(n1.left, n2.right) and isIsomorphic(n1.right, n2.left)) ) n1 = Node(1) n1.left = Node(2) n1.right = Node(3) n1.left.left = Node(4) n1.left.right = Node(5) n1.right.left = Node(6) n1.left.right.left = Node(7) n1.left.right.right = Node(8) n2 = Node(1) n2.left = Node(3) n2.right = Node(2) n2.right.left = Node(4) n2.right.right = Node(5) n2.left.right = Node(6) n2.right.right.left = Node(8) n2.right.right.right = Node(7) print (\u0026#34;Yes\u0026#34; if (isIsomorphic(n1, n2) == True) else \u0026#34;No\u0026#34;) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/binary-tree/","summary":"Level order traversal AKA BFS Reverse Level Order traversal Height of a tree Diameter of a tree Mirror of a tree / Invert Binary Tree Inorder, Preorder and Postorder Tree Traversal (Recursive Method) Left View of a tree Right View of Tree Top View of a tree Bottom View of a tree Zig-Zag traversal of a binary tree Check if a tree is balanced or not Diagonal Traversal of a Binary tree Boundary traversal of a Binary tree Construct Binary Tree from String with Bracket Representation Convert Binary tree into Doubly Linked List Convert Binary tree into Sum tree Construct Binary tree from Inorder and preorder traversal Find minimum swaps required to convert a Binary tree into BST Check if Binary tree is Sum tree or not Check if all leaf nodes are at same level or not Check if a Binary Tree contains duplicate subtrees of size 2 or more Check if 2 trees are mirror or not Sum of Nodes on the Longest path from root to leaf node Check if given graph is tree or not Find Largest subtree sum in a tree Maximum Sum of nodes in Binary tree such that no two are adjacent Print all \u0026ldquo;K\u0026rdquo; Sum paths in a Binary tree Find Least Common Ancestor in a Binary tree Find distance between 2 nodes in a Binary tree Kth Ancestor of node in a Binary tree Find all Duplicate subtrees in a Binary tree Tree Isomorphism Problem Level order traversal AKA BFS class Node: def __init__(self, key): self.","title":"DSA in Python - Binary Trees"},{"content":" Construct a trie from scratch Find shortest unique prefix for every word in a given list Word Break Problem | (Trie solution) Given a sequence of words, print all anagrams together Print unique rows in a given boolean matrix Construct a trie from scratch class TrieNode: def __init__(self): self.children = [None]*26 # isEndOfWord is True if node represent the end of the word self.isEndOfWord = False class Trie: def __init__(self): self.root = self.getNode() def getNode(self): # Returns new trie node (initialized to NULLs) return TrieNode() def _charToIndex(self,ch): # private helper function. # Converts key current character into index use only \u0026#39;a\u0026#39; through \u0026#39;z\u0026#39; and lower case return ord(ch)-ord(\u0026#39;a\u0026#39;) def insert(self,key): # If not present, inserts key into trie # If the key is prefix of trie node, just marks leaf node pCrawl = self.root length = len(key) for level in range(length): index = self._charToIndex(key[level]) # if current character is not present if not pCrawl.children[index]: pCrawl.children[index] = self.getNode() pCrawl = pCrawl.children[index] # mark last node as leaf pCrawl.isEndOfWord = True def search(self, key): # Search key in the trie # Returns true if key presents in trie, else false pCrawl = self.root length = len(key) for level in range(length): index = self._charToIndex(key[level]) if not pCrawl.children[index]: return False pCrawl = pCrawl.children[index] return pCrawl.isEndOfWord def constructTrie(): # Input keys (use only \u0026#39;a\u0026#39; through \u0026#39;z\u0026#39; and lower case) keys = [\u0026#34;the\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;there\u0026#34;,\u0026#34;answer\u0026#34;,\u0026#34;any\u0026#34;, \u0026#34;by\u0026#34;,\u0026#34;their\u0026#34;, \u0026#34;these\u0026#34;] output = [\u0026#34;Not present in trie\u0026#34;, \u0026#34;Present in trie\u0026#34;] # Trie object t = Trie() # Construct trie for key in keys: t.insert(key) # Search for different keys print(\u0026#34;the-\u0026gt;\u0026#34;,output[t.search(\u0026#34;the\u0026#34;)]) print(\u0026#34;these-\u0026gt;\u0026#34;,output[t.search(\u0026#34;these\u0026#34;)]) print(\u0026#34;their-\u0026gt;\u0026#34;,output[t.search(\u0026#34;their\u0026#34;)]) print(\u0026#34;thaw-\u0026gt;\u0026#34;,output[t.search(\u0026#34;thaw\u0026#34;)]) if __name__ == \u0026#39;__main__\u0026#39;: constructTrie() Find shortest unique prefix for every word in a given list \u0026#34;\u0026#34;\u0026#34; Input: [AND, BONFIRE, BOOL, CASE, CATCH, CHAR] Output: [A, BON, BOO, CAS, CAT, CH] Explanation: A can uniquely identify AND BON can uniquely identify BONFIRE BOO can uniquely identify BOOL CAS can uniquely identify CASE CAT can uniquely identify CATCH CH can uniquely identify CHAR \u0026#34;\u0026#34;\u0026#34; # A class to store a Trie node class TrieNode: def __init__(self): # each node stores a dictionary to its child nodes self.child = {} # keep track of the total number of times the current node is visited # while inserting data in Trie self.freq = 0 # Function to insert a given string into a Trie def insert(root, word): # start from the root node curr = root for c in word: # create a new node if the path doesn\u0026#39;t exist curr.child.setdefault(c, TrieNode()) # increment frequency curr.child[c].freq += 1 # go to the next node curr = curr.child[c] # Function to recursively traverse the Trie in a preorder fashion and # print the shortest unique prefix for each word in the Trie def printShortestPrefix(root, word_so_far): if root is None: return # print `word_so_far` if the current Trie node is visited only once if root.freq == 1: print(word_so_far) return # recur for all child nodes for k, v in root.child.items(): printShortestPrefix(v, word_so_far + k) # Find the shortest unique prefix for every word in a given array def findShortestPrefix(words): # construct a Trie from the given items root = TrieNode() for s in words: insert(root, s) # Recursively traverse the Trie in a preorder fashion to list all prefixes printShortestPrefix(root, \u0026#39;\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: words = [\u0026#39;AND\u0026#39;, \u0026#39;BONFIRE\u0026#39;, \u0026#39;BOOL\u0026#39;, \u0026#39;CASE\u0026#39;, \u0026#39;CATCH\u0026#39;, \u0026#39;CHAR\u0026#39;] findShortestPrefix(words) Word Break Problem | (Trie solution) # Currently, Trie supports lowercase English characters. So, the character size is 26. CHAR_SIZE = 26 # A class to store a Trie node class Node: next = [None] * CHAR_SIZE exist = False # true when the node is a leaf node # Iterative function to insert a string into a Trie def insertTrie(head, s): # start from the root node node = head # do for each character in the string for c in s: index = ord(c) - ord(\u0026#39;a\u0026#39;) # create a new node if the path doesn\u0026#39;t exist if node.next[index] is None: node.next[index] = Node() # go to the next node node = node.next[index] # mark the last node as a leaf node.exist = True # Function to determine if a string can be segmented into space-separated # sequence of one or more dictionary words def wordBreak(head, s): # get the length of the string n = len(s) # `good[i]` is true if the first `i` characters of `s` can be segmented good = [None] * (n + 1) good[0] = True # base case for i in range(n): if good[i]: node = head for j in range(i, n): if node is None: break index = ord(s[j]) - ord(\u0026#39;a\u0026#39;) node = node.next[index] # we can make [0, i] using our known decomposition # and [i+1, j] using this string in a Trie if node and node.exist: good[j + 1] = True # `good[n]` would be true if all characters of `s` can be segmented return good[n] if __name__ == \u0026#39;__main__\u0026#39;: # List of strings to represent a dictionary words = [\u0026#39;self\u0026#39;, \u0026#39;th\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;famous\u0026#39;, \u0026#39;word\u0026#39;, \u0026#39;break\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;br\u0026#39;, \u0026#39;bre\u0026#39;, \u0026#39;brea\u0026#39;, \u0026#39;ak\u0026#39;, \u0026#39;prob\u0026#39;, \u0026#39;lem\u0026#39;] # given string s = \u0026#39;wordbreakproblem\u0026#39; # create a Trie to store the dictionary t = Node() for word in words: insertTrie(t, word) # check if the string can be segmented or not if wordBreak(t, s): print(\u0026#39;The string can be segmented\u0026#39;) else: print(\u0026#39;The string can\\\u0026#39;t be segmented\u0026#39;) Given a sequence of words, print all anagrams together class TrieNode: def __init__(self): # each node stores a dictionary to its child nodes self.child = {} # stores anagrams in the leaf node self.words = [] # Function to insert a string into a Trie def insert(root, word, originalWord): # start from the root node curr = root for c in word: # create a new node if the path doesn\u0026#39;t exist curr.child.setdefault(c, TrieNode()) # go to the next node curr = curr.child[c] # anagrams will end up at the same leaf node curr.words.append(originalWord) # A recursive function that traverses a Trie in preorder fashion and # prints all anagrams together def printAnagrams(root): # base case if root is None: return # print the current word if len(root.words) \u0026gt; 1: print(root.words) # recur for all child nodes for child in root.child.values(): printAnagrams(child) # Function to group anagrams from a given list of words def groupAnagrams(words): # construct an empty trie root = TrieNode() # do for each word for word in words: # Sort the characters of the current word and insert it into the Trie. # Note that the original word gets stored on the leaf insert(root, \u0026#39;\u0026#39;.join(sorted(word)), word) # print all anagrams together printAnagrams(root) words = [\u0026#39;auctioned\u0026#39;, \u0026#39;actors\u0026#39;, \u0026#39;altered\u0026#39;, \u0026#39;streaming\u0026#39;, \u0026#39;related\u0026#39;, \u0026#39;education\u0026#39;, \u0026#39;aspired\u0026#39;, \u0026#39;costar\u0026#39;, \u0026#39;despair\u0026#39;, \u0026#39;mastering\u0026#39;, \u0026#39;act\u0026#39;,\u0026#39;cat\u0026#39;,\u0026#39;tac\u0026#39; ] groupAnagrams(words) Print unique rows in a given boolean matrix # Given a binary matrix of M X N of integers, you need to return only unique rows of binary array ROW = 4 COL = 5 def findUniqueRows(M): # Traverse through the matrix for i in range(ROW): flag = 0 # Check if there is similar column is already printed, i.e if i and jth column match. for j in range(i): flag = 1 for k in range(COL): if (M[i][k] != M[j][k]): flag = 0 if (flag == 1): break # If no row is similar if (flag == 0): # Print the row for j in range(COL): print(M[i][j], end = \u0026#34; \u0026#34;) print() M = [ [ 0, 1, 0, 0, 1 ], [ 1, 0, 1, 1, 0 ], [ 0, 1, 0, 0, 1 ], [ 1, 0, 1, 0, 0 ] ] findUniqueRows(M) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/trie/","summary":"Construct a trie from scratch Find shortest unique prefix for every word in a given list Word Break Problem | (Trie solution) Given a sequence of words, print all anagrams together Print unique rows in a given boolean matrix Construct a trie from scratch class TrieNode: def __init__(self): self.children = [None]*26 # isEndOfWord is True if node represent the end of the word self.isEndOfWord = False class Trie: def __init__(self): self.","title":"DSA in Python - Trie"},{"content":" Reverse the array Find the maximum and minimum element in an array Find the \u0026ldquo;Kth\u0026rdquo; max and min element of an array Given an array which consists of only 0, 1 and 2. Sort the array without using any sorting algo Move all the negative elements to one side of the array Find the Union and Intersection of the two sorted arrays Write a program to cyclically rotate an array by one Find Largest sum contiguous Subarray [V. IMP] / Kadne\u0026rsquo;s Algorithm Minimise the maximum difference between heights Minimum no. of Jumps to reach end of an array Find duplicate in an array of N+1 Integers Merge 2 sorted arrays without using Extra space Merge Intervals Next Permutation Count Inversion Best time to buy and Sell stock Find all pairs on integer array whose sum is equal to given number Find common elements In 3 sorted arrays Rearrange the array in alternating positive and negative items with O(1) extra space Find if there is any subarray with sum equal to 0 Find factorial of a large number Find maximum product subarray Find longest consecutive subsequence Given an array of size n and a number k, find all elements that appear more than \u0026quot; n/k \u0026quot; times Maximum profit by buying and selling a share atmost twice Find whether an array is a subset of another array Find the triplet that sum to a given value Trapping Rain water problem Chocolate Distribution problem Smallest Subarray with sum greater than a given value Three way partitioning of an array around a given value Minimum swaps required bring elements less equal K together Minimum no. of operations required to make an array palindrome Median of 2 sorted arrays of different size Reverse the array def reverseArray(A: list): start, end= 0, len(A)-1 while start\u0026lt;end: A[start], A[end]= A[end], A[start] start+=1 end-=1 A=[1,54,21,51,2,353,2,1,99,121,5,5] reverseArray(A) print(\u0026#34;After reversing:\u0026#34;, A) Find the maximum and minimum element in an array def getMinMax(arr: list, n: int): min = 0 max = 0 # If there is only one element then return it as min and max both if n == 1: max = arr[0] min = arr[0] return min, max # If there are more than one elements, then initialize min # and max if arr[0] \u0026gt; arr[1]: max = arr[0] min = arr[1] else: max = arr[1] min = arr[0] for i in range(2, n): if arr[i] \u0026gt; max: max = arr[i] elif arr[i] \u0026lt; min: min = arr[i] return min, max # Driver Code if __name__ == \u0026#34;__main__\u0026#34;: arr = [1000, 11, 445, 1, 330, 3000] arr_size = 6 min, max = getMinMax(arr, arr_size) print(\u0026#34;Minimum element is\u0026#34;, min) print(\u0026#34;Maximum element is\u0026#34;, max) Find the \u0026ldquo;Kth\u0026rdquo; max and min element of an array import sys # function to calculate number of elements less than equal to mid def count(nums, mid): cnt = 0 for i in range(len(nums)): if nums[i] \u0026lt;= mid: cnt += 1 return cnt def kthSmallest(nums, k): low = sys.maxsize high = -sys.maxsize # calculate minimum and maximum the array. for i in range(len(nums)): low = min(low, nums[i]) high = max(high, nums[i]) # Our answer range lies between minimum and maximum element # of the array on which Binary Search is Applied while low \u0026lt; high: mid = low + (high - low) // 2 # if the count of number of elements in the array less than equal # to mid is less than k then increase the number. Otherwise decrement # the number and try to find a better answer. if count(nums, mid) \u0026lt; k: low = mid + 1 else: high = mid return low nums = [1, 4, 5, 3, 19, 3] k = 3 print(\u0026#34;K\u0026#39;th smallest element is\u0026#34;, kthSmallest(nums, k)) Given an array which consists of only 0, 1 and 2. Sort the array without using any sorting algo def sort012(arr): n=len(arr) low=0 high=n-1 mid=0 while mid\u0026lt;=high: if arr[mid]==0: arr[mid] , arr[low] = arr[low] , arr[mid] mid+=1 low+=1 elif arr[mid]==1: mid+=1 else: arr[mid] , arr[high] = arr[high] , arr[mid] high-=1 A=[0,0,0,2,2,2,1,1,1,0,2,1,1,2,0] sort012(A) print(\u0026#34;After sorting:\u0026#34;, A) Move all the negative elements to one side of the array def RearrangePosNeg(arr): n = len(arr) for i in range(1, n): key = arr[i] # if current element is positive do nothing if (key \u0026gt; 0): continue # if current element is negative, shift positive elements of arr[0..i-1], to one position to their right j = i - 1 while (j \u0026gt;= 0 and arr[j] \u0026gt; 0): arr[j + 1] = arr[j] j = j - 1 # Put negative element at its # right position arr[j + 1] = key # Driver Code if __name__ == \u0026#34;__main__\u0026#34;: arr = [-12, 11, -13, -5, 6, -7, 5, -3, -6] RearrangePosNeg(arr) print(arr) Find the Union and Intersection of the two sorted arrays def printUnion(arr1, arr2, n1, n2): hs = set() # Insert the elements of arr1[] to set hs for i in range(0, n1): hs.add(arr1[i]) # Insert the elements of arr2[] to set hs for i in range(0, n2): hs.add(arr2[i]) for i in hs: print(i, end=\u0026#34; \u0026#34;) print(\u0026#34;Union Count\u0026#34;, len(hs)) def printIntersection(arr1, arr2, n1, n2): hs = set() # Insert the elements of arr1[] to set S for i in range(0, n1): hs.add(arr1[i]) intersectCount=0 for i in range(0, n2): # If element is present in set then # push it to vector V if arr2[i] in hs: print(arr2[i], end=\u0026#34; \u0026#34;) intersectCount+=1 print(\u0026#34;Intersection Count\u0026#34;, intersectCount) # Driver Program arr1 = [7, 1, 5, 2, 3, 6] arr2 = [3, 8, 6, 20, 7] n1 = len(arr1) n2 = len(arr2) # Function call printUnion(arr1, arr2, n1, n2) printIntersection(arr1, arr2, n1, n2) Write a program to cyclically rotate an array by one def rotate(arr): n = len(arr) i = 0 j = n - 1 while i != j: arr[i], arr[j] = arr[j], arr[i] i = i + 1 # Driver function arr= [1, 2, 3, 4, 5] rotate(arr) print(arr) Find Largest sum contiguous Subarray [V. IMP] / Kadne\u0026rsquo;s Algorithm def maxSubArraySum(a): size=len(a) max_so_far =a[0] curr_max = a[0] for i in range(1,size): curr_max = max(a[i], curr_max + a[i]) max_so_far = max(max_so_far,curr_max) return max_so_far a = [-2, -3, 4, -1, -2, 1, 5, -3] print (\u0026#34;Maximum contiguous sum is\u0026#34; , maxSubArraySum(a)) Minimise the maximum difference between heights \u0026#34;\u0026#34;\u0026#34; Given heights of n towers and a value k. We need to either increase or decrease the height of every tower by k (only once) where k \u0026gt; 0. The task is to minimize the difference between the heights of the longest and the shortest tower after modifications and output this difference. Input : arr[] = {1, 5, 15, 10} k = 3 Output : Maximum difference is 8 arr[] = {4, 8, 12, 7} \u0026#34;\u0026#34;\u0026#34; def getMinDiff(arr, k): arr.sort() n=len(arr) ans = arr[n - 1] - arr[0] # Maximum possible height difference tempmin = arr[0] tempmax = arr[n - 1] for i in range(1, n): tempmin = min(arr[0] + k, arr[i] - k) # Minimum element when we add k to whole array Maximum element when we tempmax = max(arr[i - 1] + k, arr[n - 1] - k) # subtract k from whole array ans = min(ans, tempmax - tempmin) return ans # Driver Code Starts k = 6 # total towers arr = [7, 4, 8, 8, 8, 9] # height of each array print(\u0026#34;Maximum difference of height between all towers (minimized as much as possible) is\u0026#34;, getMinDiff(arr, k)) Minimum no. of Jumps to reach end of an array \u0026#34;\u0026#34;\u0026#34; Given an array of integers where each element represents the max number of steps that can be made forward from that element. Write a function to return the minimum number of jumps to reach the end of the array (starting from the first element). If an element is 0, then we cannot move through that element. If we can\u0026#39;t reach the end, return -1. Input: arr[] = {1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9} Output: 3 (1-\u0026gt; 3 -\u0026gt; 8 -\u0026gt; 9) \u0026#34;\u0026#34;\u0026#34; # Returns minimum number of jumps to reach arr[n-1] from arr[0] def minJumps(arr, n): # The number of jumps needed to reach the starting index is 0 if (n \u0026lt;= 1): return 0 # Return -1 if not possible to jump if (arr[0] == 0): return -1 # initialization # stores all time the maximal reachable index in the array maxReach = arr[0] # stores the amount of steps we can still take step = arr[0] # stores the amount of jumps necessary to reach that maximal reachable position jump = 1 # Start traversing array for i in range(1, n): # Check if we have reached the end of the array if (i == n-1): return jump # updating maxReach maxReach = max(maxReach, i + arr[i]) # we use a step to get to the current index step -= 1; # If no further steps left if (step == 0): # we must have used a jump jump += 1 # Check if the current index / position or lesser index # is the maximum reach point from the previous indexes if(i \u0026gt;= maxReach): return -1 # re-initialize the steps to the amount # of steps to reach maxReach from position i. step = maxReach - i; return -1 arr = [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9] size = len(arr) print(\u0026#34;Minimum number of jumps to reach end is: \u0026#34;, minJumps(arr, size)) Find duplicate in an array of N+1 Integers \u0026#34;\u0026#34;\u0026#34; Given a limited range array of size n containing elements between 1 and n-1 with one element repeating, find the duplicate number in it without using any extra space. NOTE : ARRAY IS LIMITED RANGE \u0026#34;\u0026#34;\u0026#34; def findDuplicate(nums): actual_sum = sum(nums) expected_sum = len(nums) * (len(nums) - 1) // 2 return actual_sum - expected_sum A=[3,1,2,4,2] print(findDuplicate(A)) Merge 2 sorted arrays without using Extra space def merge(X, Y): m = len(X) n = len(Y) # Consider each element `X[i]` of list `X[]` and ignore the element if it is # already in the correct order; otherwise, swap it with the next smaller # element, which happens to be the first element of `Y[]`. for i in range(m): # compare the current element of `X[]` with the first element of `Y[]` if X[i] \u0026gt; Y[0]: # swap `X[i] with `Y[0]` X[i],Y[0]=Y[0], X[i] first = Y[0] # move `Y[0]` to its correct position to maintain the sorted # order of `Y[]`. Note: `Y[1…n-1]` is already sorted k = 1 while k \u0026lt; n and Y[k] \u0026lt; first: Y[k - 1] = Y[k] k = k + 1 Y[k - 1] = first X = [1, 4, 7, 8, 10] Y = [2, 3, 9] merge(X, Y) print(\u0026#34;X:\u0026#34;, X) print(\u0026#34;Y:\u0026#34;, Y) Merge Intervals def mergeIntervals(arr): # Sorting based on the increasing order # of the start intervals arr.sort(key=lambda x: x[0]) # Stores index of last element in output array (modified arr[]) index = 0 # Traverse all input Intervals starting from second interval for i in range(1, len(arr)): # If this is not first Interval and overlaps with the previous one, Merge previous and current Intervals if (arr[index][1] \u0026gt;= arr[i][0]): arr[index][1] = max(arr[index][1], arr[i][1]) else: index = index + 1 arr[index] = arr[i] print(\u0026#34;The Merged Intervals are :\u0026#34;, end=\u0026#34; \u0026#34;) for i in range(index+1): print(arr[i], end=\u0026#34; \u0026#34;) arr = [[6, 8], [1, 3], [2, 4], [4, 7]] mergeIntervals(arr) Next Permutation \u0026#34;\u0026#34;\u0026#34; If all digits sorted in descending order, then output is always \u0026#34;Not Possible\u0026#34;. For example, 4321. If all digits are sorted in ascending order, then we need to swap last two digits. For example, 1234. For other cases, we need to process the number from rightmost side (why? because we need to find the smallest of all greater numbers) \u0026#34;\u0026#34;\u0026#34; def nextPermutation(arr): N=len(arr) ind = 0 l = [] l += arr for i in range(N-2, -1, -1): if l[i]\u0026lt;l[i+1]: ind = i break for i in range(N-1, ind, -1): if l[i]\u0026gt;l[ind]: l[i], l[ind] = l[ind], l[i] ind += 1 break for i in range((N-ind)//2): l[i+ind], l[N-i-1] = l[N-i-1], l[i+ind] return \u0026#34;\u0026#34;.join(l) print(nextPermutation(\u0026#34;218765\u0026#34;)) Count Inversion def mergeSort(arr, n): # A temp_arr is created to store sorted array in merge function temp_arr = [0]*n return _mergeSort(arr, temp_arr, 0, n-1) # This Function will use MergeSort to count inversions def _mergeSort(arr, temp_arr, left, right): inv_count = 0 # We will make a recursive call if and only if we have more than one elements if left \u0026lt; right: # mid is calculated to divide the array into two subarrays Floor division is must in case of python mid = (left + right)//2 # It will calculate inversion counts in the left subarray inv_count += _mergeSort(arr, temp_arr, left, mid) # It will calculate inversion counts in right subarray inv_count += _mergeSort(arr, temp_arr,mid + 1, right) # It will merge two subarrays in a sorted subarray inv_count += merge(arr, temp_arr, left, mid, right) return inv_count # This function will merge two subarrays # in a single sorted subarray def merge(arr, temp_arr, left, mid, right): i = left # Starting index of left subarray j = mid + 1 # Starting index of right subarray k = left # Starting index of to be sorted subarray inv_count = 0 # Conditions are checked to make sure that i and j don\u0026#39;t exceed their subarray limits. while i \u0026lt;= mid and j \u0026lt;= right: # There will be no inversion if arr[i] \u0026lt;= arr[j] if arr[i] \u0026lt;= arr[j]: temp_arr[k] = arr[i] k += 1 i += 1 else: # Inversion will occur. temp_arr[k] = arr[j] inv_count += (mid-i + 1) k += 1 j += 1 # Copy the remaining elements of left subarray into temporary array while i \u0026lt;= mid: temp_arr[k] = arr[i] k += 1 i += 1 # Copy the remaining elements of right subarray into temporary array while j \u0026lt;= right: temp_arr[k] = arr[j] k += 1 j += 1 # Copy the sorted subarray into Original array for loop_var in range(left, right + 1): arr[loop_var] = temp_arr[loop_var] return inv_count arr = [1, 20, 6, 4, 5] n = len(arr) result = mergeSort(arr, n) print(\u0026#34;Number of inversions are\u0026#34;, result) Best time to buy and Sell stock \u0026#34;\u0026#34;\u0026#34; Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. \u0026#34;\u0026#34;\u0026#34; def maxProfit(prices): max_profit = 0 min_buy = float(\u0026#39;inf\u0026#39;) for price in prices: min_buy=min(min_buy, price) max_profit=max(max_profit, price-min_buy) return max_profit print(maxProfit([7,1,5,3,6,4])) Find all pairs on integer array whose sum is equal to given number \u0026#34;\u0026#34;\u0026#34; An extended version of the two sum problem \u0026#34;\u0026#34;\u0026#34; # Returns number of pairs in arr[0..n-1] with sum equal to \u0026#39;sum\u0026#39; def getPairsCount(arr, n, sum): unordered_map = {} count = 0 for i in range(n): if sum - arr[i] in unordered_map: count += unordered_map[sum - arr[i]] if arr[i] in unordered_map: unordered_map[arr[i]] += 1 else: unordered_map[arr[i]] = 1 return count # Driver code arr = [1, 5, 7, -1, 5] n = len(arr) sum = 6 print(\u0026#39;Count of pairs is\u0026#39;, getPairsCount(arr, n, sum)) Find common elements In 3 sorted arrays \u0026#34;\u0026#34;\u0026#34; Given three arrays sorted in non-decreasing order, print all common elements in these arrays. \u0026#34;\u0026#34;\u0026#34; # Python function to print common elements in three sorted arrays def findCommon(ar1, ar2, ar3, n1, n2, n3): # Initialize starting indexes for ar1[], ar2[] and ar3[] i, j, k = 0, 0, 0 # Iterate through three arrays while all arrays have elements while (i \u0026lt; n1 and j \u0026lt; n2 and k \u0026lt; n3): # If x = y and y = z, print any of them and move ahead # in all arrays if (ar1[i] == ar2[j] and ar2[j] == ar3[k]): print (ar1[i]) i += 1 j += 1 k += 1 # x \u0026lt; y elif ar1[i] \u0026lt; ar2[j]: i += 1 # y \u0026lt; z elif ar2[j] \u0026lt; ar3[k]: j += 1 # We reach here when x \u0026gt; y and z \u0026lt; y, i.e., z is smallest else: k += 1 # Driver program to check above function ar1 = [1, 5, 10, 20, 40, 80] ar2 = [6, 7, 20, 80, 100] ar3 = [3, 4, 15, 20, 30, 70, 80, 120] n1 = len(ar1) n2 = len(ar2) n3 = len(ar3) print (\u0026#34;Common elements are\u0026#34;) findCommon(ar1, ar2, ar3, n1, n2, n3) Rearrange the array in alternating positive and negative items with O(1) extra space def rearrange(arr, n): i = 0 j = n - 1 # shift all negative values to the end while (i \u0026lt; j): while (i \u0026lt;= n - 1 and arr[i] \u0026gt; 0): i += 1 while (j \u0026gt;= 0 and arr[j] \u0026lt; 0): j -= 1 if (i \u0026lt; j): temp = arr[i] arr[i] = arr[j] arr[j] = temp # i has index of leftmost # negativ ement if (i == 0 or i == n): return 0 # start with first positive element at index 0 array in alternating positive \u0026amp; negative items k = 0 while (k \u0026lt; n and i \u0026lt; n): # swap next positive element at even position from next negative element. arr[k], arr[i]= arr[i], arr[k] i = i + 1 k = k + 2 arr = [2, 3,-4, -1, 6, -9 ] n = len(arr) rearrange(arr, n) print(\u0026#34;Rearranged array is\u0026#34;, arr) Find if there is any subarray with sum equal to 0 \u0026#34;\u0026#34;\u0026#34; Given an array of positive and negative numbers, find if there is a subarray (of size at-least one) with 0 sum. \u0026#34;\u0026#34;\u0026#34; #Function to check whether there is a subarray present with 0-sum or not. def subArrayExists(arr): n=len(arr) #using set to store the prefix sum which has appeared already. s = set() sum = 0 #iterating over the array. for i in range(n): #storing prefix sum. sum += arr[i] #if prefix sum is 0 or if it is already present in set then it is #repeated which means there is a subarray whose summation was 0, so we return true. if sum == 0 or sum in s: return True #storing every prefix sum obtained in set. s.add(sum) #returning false if we don\u0026#39;t get any subarray with 0 sum. return False print(subArrayExists([4, 2, -3, 1, 6])) Find factorial of a large number def range_prod(low,high): if low+1 \u0026lt; high: mid = (high+low)//2 return range_prod(low,mid) * range_prod(mid+1,high) if low == high: return low return low*high def factorial(n): if n \u0026lt; 2: return 1 return range_prod(1,n) print(factorial(12)) Find maximum product subarray def maxProduct(arr): n=len(arr) # Variables to store maximum and minimum product till ith index. minVal = arr[0] maxVal = arr[0] maxProduct = arr[0] for i in range(1, n): # When multiplied by -ve number, maxVal becomes minVal and minVal becomes maxVal. if (arr[i] \u0026lt; 0): minVal, maxVal = maxVal, minVal # maxVal and minVal stores the product of subarray ending at arr[i]. maxVal = max(arr[i], maxVal * arr[i]) minVal = min(arr[i], minVal * arr[i]) # Max Product of array. maxProduct = max(maxProduct, maxVal) return maxProduct print(maxProduct([6, -3, -10, 0, 2])) Find longest consecutive subsequence \u0026#34;\u0026#34;\u0026#34; Given an array of integers, find the length of the longest sub-sequence such that elements in the subsequence are consecutive integers, the consecutive numbers can be in any order. \u0026#34;\u0026#34;\u0026#34; def findLongestConseqSubseq(arr): n=len(arr) #using a Set to store elements. s = set() ans=0 #inserting all the array elements in Set. for ele in arr: s.add(ele) #checking each possible sequence from the start. for i in range(n): #if current element is starting element of a sequence then only we try to find out the length of sequence. if (arr[i]-1) not in s: j=arr[i] #then we keep checking whether the next consecutive elements are present in Set and #we keep incrementing the counter. while(j in s): j+=1 #storing the maximum count. ans=max(ans, j-arr[i]) #returning the length of longest subsequence. return ans print(findLongestConseqSubseq([1, 9, 3, 10, 4, 20, 2])) Given an array of size n and a number k, find all elements that appear more than \u0026quot; n/k \u0026quot; times \u0026#34;\u0026#34;\u0026#34; Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. \u0026#34;\u0026#34;\u0026#34; def majorityElement(nums): if not nums: return [] count1, count2, candidate1, candidate2 = 0, 0, None, None for x in nums: if candidate1 == x: count1 += 1 elif candidate2 == x: count2 += 1 elif count1 == 0: candidate1 = x count1 = 1 elif count2 == 0: candidate2 = x count2 = 1 else: count1 -= 1 count2 -= 1 res = [] for c in [candidate1, candidate2]: if nums.count(c) \u0026gt; len(nums) // 3: res.append(c) return res print(majorityElement([3,2,3])) Maximum profit by buying and selling a share atmost twice \u0026#34;\u0026#34;\u0026#34; Input: prices = [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3. \u0026#34;\u0026#34;\u0026#34; def maxProfit(prices): b1, b2= -float(\u0026#39;inf\u0026#39;), -float(\u0026#39;inf\u0026#39;) s1, s2 = 0, 0 for price in prices: s2 = max(s2, b2 + price) b2 = max(b2, s1 - price) s1 = max(s1, b1 + price) b1 = max(b1, -price) return s2 print(maxProfit([3,3,5,0,0,3,1,4])) Find whether an array is a subset of another array def isSubset( a1, a2): n,m =len(a1), len(a2) s = set() for i in range(n) : s.add(a1[i]) p = len(s) for i in range(m) : s.add(a2[i]) if (len(s) == p) : return \u0026#34;Yes\u0026#34; return \u0026#34;No\u0026#34; a=[11, 1, 13, 21, 3, 7] b=[11, 3, 7, 1] print(isSubset(a, b)) Find the triplet that sum to a given value def findTriplets(arr, X): n=len(arr) found = False for i in range(0, n-2): for j in range(i+1, n-1): for k in range(j+1, n): if (arr[i] + arr[j] + arr[k] == X): print(arr[i], arr[j], arr[k]) found = True # If no triplet with 0 sum found in array if (found == False): print(\u0026#34;Three Sum not exist \u0026#34;) arr = [0, -1, 2, -3, 1] sum= 3 findTriplets(arr, sum) Trapping Rain water problem def trap(heights): # maintain two pointers left and right, pointing to the leftmost and # rightmost index of the input list (left, right) = (0, len(heights) - 1) water = 0 maxLeft = heights[left] maxRight = heights[right] while left \u0026lt; right: if heights[left] \u0026lt;= heights[right]: left = left + 1 maxLeft = max(maxLeft, heights[left]) water += (maxLeft - heights[left]) else: right = right - 1 maxRight = max(maxRight, heights[right]) water += (maxRight - heights[right]) return water heights = [7, 0, 4, 2, 5, 0, 6, 4, 0, 5] print(\u0026#34;The maximum amount of water that can be trapped is\u0026#34;, trap(heights)) Chocolate Distribution problem \u0026#34;\u0026#34;\u0026#34; Input : arr[] = {7, 3, 2, 4, 9, 12, 56} , m = 3 Output: Minimum Difference is 2 Explanation: We have seven packets of chocolates and we need to pick three packets for 3 students. If we pick 2, 3 and 4, we get the minimum difference between maximum and minimum packet sizes. \u0026#34;\u0026#34;\u0026#34; # arr[0..n-1] represents sizes of packets # m is number of students. # Returns minimum difference between maximum # and minimum values of distribution. def findMinDiff(arr, m): n=len(arr) if (m==0 or n==0): return 0 arr.sort() # Number of students cannot be more than number of packets if (n \u0026lt; m): return -1 # Largest number of chocolates min_diff = arr[n-1] - arr[0] # Find the subarray of size m such that difference between last (maximum in case of sorted) and #first (minimum in case of sorted) elements of subarray is minimum. for i in range(len(arr) - m + 1): min_diff = min(min_diff , arr[i + m - 1] - arr[i]) return min_diff arr = [12, 4, 7, 9, 2, 23, 25, 41, 30, 40, 28, 42, 30, 44, 48, 43, 50] m = 7 # Number of students print(\u0026#34;Minimum difference is\u0026#34;, findMinDiff(arr, m)) Smallest Subarray with sum greater than a given value \u0026#34;\u0026#34;\u0026#34; Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. \u0026#34;\u0026#34;\u0026#34; def minSubArrayLen(nums, target): i, j, pres, res = 0 , 0 , 0, len(nums) + 1 while j \u0026lt; len(nums): pres += nums[j]; j += 1 while pres \u0026gt;= target: res = min(res, j - i) pres -= nums[i] i+= 1 return res if res != len(nums) + 1 else 0 sum=7 print(minSubArrayLen([2,3,1,2,4,3], sum)) Three way partitioning of an array around a given value def threeWayPartition(arr, lowVal, highVal): n = len(arr) # Initialize ext available positions for smaller (than range) and greater elements start = 0 end = n - 1 i = 0 # Traverse elements from left while i \u0026lt;= end: # If current element is smaller than range, put it on next available smaller position. if arr[i] \u0026lt; lowVal: arr[i], arr[start] = arr[start], arr[i] i += 1 start += 1 # If current element is greater than range, put it on next available greater position. elif arr[i] \u0026gt; highVal: arr[i], arr[end] = arr[end], arr[i] end -= 1 else: i += 1 arr = [1, 14, 5, 20, 4, 2, 54, 20, 87, 98, 3, 1, 32] \u0026#34;\u0026#34;\u0026#34; 1) All elements smaller than lowVal come first. 2) All elements in range lowVal to highVal come next. 3) All elements greater than highVal appear in the end. \u0026#34;\u0026#34;\u0026#34; threeWayPartition(arr, 10, 20) print(arr) Minimum swaps required bring elements less equal K together \u0026#34;\u0026#34;\u0026#34; Find the minimum number of swaps required to bring all the numbers less than or equal to k together, i.e. make them a contiguous subarray. \u0026#34;\u0026#34;\u0026#34; def minSwap(arr, k) : n=len(arr) # Find count of elements which are less than equals to k count = 0 for i in range(0, n) : if (arr[i] \u0026lt;= k) : count = count + 1 # Find unwanted elements in current window of size \u0026#39;count\u0026#39; bad = 0 for i in range(0, count) : if (arr[i] \u0026gt; k) : bad = bad + 1 # Initialize answer with \u0026#39;bad\u0026#39; value of current window ans = bad j = count for i in range(0, n) : if(j == n) : break # Decrement count of previous window if (arr[i] \u0026gt; k) : bad = bad - 1 # Increment count of current window if (arr[j] \u0026gt; k) : bad = bad + 1 # Update ans if count of \u0026#39;bad\u0026#39; is less in current window ans = min(ans, bad) j = j + 1 return ans arr = [2, 1, 5, 6, 3] k = 3 print (minSwap(arr, k)) arr1 = [2, 7, 9, 5, 8, 7, 4] k = 5 print (minSwap(arr1, k)) Minimum no. of operations required to make an array palindrome \u0026#34;\u0026#34;\u0026#34; Input: [6, 1, 3, 7] Output: 1 Explanation: [6, 1, 3, 7] —\u0026gt; Merge 6 and 1 —\u0026gt; [7, 3, 7] \u0026#34;\u0026#34;\u0026#34; def findMin(arr): # stores the minimum number of merge operations needed count = 0 # `i` and `j` initially points to endpoints of the array i = 0 j = len(arr) - 1 # loop till the search space is exhausted while i \u0026lt; j: if arr[i] \u0026lt; arr[j]: # merge item at i\u0026#39;th index with the item at (i+1)\u0026#39;th index arr[i + 1] += arr[i] i = i + 1 count = count + 1 elif arr[i] \u0026gt; arr[j]: # merge item at (j-1)\u0026#39;th index with the item at j\u0026#39;th index arr[j - 1] += arr[j] j = j - 1 count = count + 1 # otherwise, ignore both the elements else: i = i + 1 j = j - 1 return count arr = [6, 1, 4, 3, 1, 7] min = findMin(arr) print(\u0026#34;The minimum number of operations required:\u0026#34;, min) Median of 2 sorted arrays of different size def Solution(arr1, arr2): arr = arr1 + arr2 arr.sort() n = len(arr) # If length of array is even if n % 2 == 0: return (arr[n // 2] + arr[n // 2 - 1]) / 2 # If length of array is odd else: return arr[n//2] arr1 = [ -5, 3, 6, 12, 15] arr2 = [ -12, -10, -6, -3, 4, 10 ] print(\u0026#34;Median = \u0026#34;, Solution(arr1, arr2)) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/arrays/","summary":"Reverse the array Find the maximum and minimum element in an array Find the \u0026ldquo;Kth\u0026rdquo; max and min element of an array Given an array which consists of only 0, 1 and 2. Sort the array without using any sorting algo Move all the negative elements to one side of the array Find the Union and Intersection of the two sorted arrays Write a program to cyclically rotate an array by one Find Largest sum contiguous Subarray [V.","title":"DSA in Python - Arrays"},{"content":" Rat in a maze Problem Printing all solutions in N-Queen Problem Word Break Problem using Backtracking Remove Invalid Parentheses Sudoku Solver m-Colouring Problem Print all palindromic partitions of a string Subset Sum Problem The Knight’s tour problem Tug of War Find shortest safe route in a path with landmines Combinational Sum Find Maximum number possible by doing at-most K swaps Print all permutations of a string Find if there is a path of more than k length from a source Longest Possible Route in a Matrix with Hurdles Print all possible paths from top left to bottom right of a mXn matrix Partition of a set intoK subsets with equal sum Find the K-th Permutation Sequence of first N natural numbers Rat in a maze Problem \u0026#34;\u0026#34;\u0026#34; N = 4 m[][] = {{1, 0, 0, 0}, {1, 1, 0, 1}, {1, 1, 0, 0}, {0, 1, 1, 1}} Output: DDRDRR DRDDRR Explanation: The rat can reach the destination at (3, 3) from (0, 0) by two paths - DRDDRR and DDRDRR, when printed in sorted order we get DDRDRR DRDDRR. \u0026#34;\u0026#34;\u0026#34; def setup(): global v v = [[0 for i in range(100)] for j in range(100)] global ans ans = [] def path(arr, x, y, pth, n): if x==n-1 and y==n-1: global ans ans.append(pth) return global v if arr[x][y]==0 or v[x][y]==1: return v[x][y]=1 if x\u0026gt;0: path(arr, x-1, y, pth+\u0026#39;U\u0026#39;, n) if y\u0026gt;0: path(arr, x, y-1, pth+\u0026#39;L\u0026#39;, n) if x\u0026lt;n-1: path(arr, x+1, y, pth+\u0026#39;D\u0026#39;, n) if y\u0026lt;n-1: path(arr, x, y+1, pth+\u0026#39;R\u0026#39;, n) v[x][y]=0 def findPath(m, n): global ans ans= [] if m[0][0] == 0 or m[n-1][n-1]==0 : return ans setup() path(m, 0, 0, \u0026#34;\u0026#34;, n) ans.sort() return ans m = [ [ 1, 0, 0, 0, 0 ], [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 0, 1 ], [ 0, 0, 0, 0, 1 ],[ 0, 0, 0, 0, 1 ] ] n = len(m) print(findPath(m, n)) Printing all solutions in N-Queen Problem def isSafe(mat, r, c): # return false if two queens share the same column for i in range(r): if mat[i][c] == \u0026#39;Q\u0026#39;: return False # return false if two queens share the same `` diagonal (i, j) = (r, c) while i \u0026gt;= 0 and j \u0026gt;= 0: if mat[i][j] == \u0026#39;Q\u0026#39;: return False i = i - 1 j = j - 1 # return false if two queens share the same `/` diagonal (i, j) = (r, c) while i \u0026gt;= 0 and j \u0026lt; len(mat): if mat[i][j] == \u0026#39;Q\u0026#39;: return False i = i - 1 j = j + 1 return True def printSolution(mat): for r in mat: print(str(r).replace(\u0026#39;,\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#39;)) print() def nQueen(mat, r): # if `N` queens are placed successfully, print the solution if r == len(mat): printSolution(mat) return # place queen at every square in the current row `r` # and recur for each valid movement for i in range(len(mat)): # if no two queens threaten each other if isSafe(mat, r, i): # place queen on the current square mat[r][i] = \u0026#39;Q\u0026#39; # recur for the next row nQueen(mat, r + 1) # backtrack and remove the queen from the current square mat[r][i] = \u0026#39;–\u0026#39; # `N × N` chessboard N = 8 # `mat[][]` keeps track of the position of queens in # the current configuration mat = [[\u0026#39;–\u0026#39; for x in range(N)] for y in range(N)] nQueen(mat, 0) Word Break Problem using Backtracking # A recursive program to print all possible partitions of a given string into dictionary words # A utility function to check whether a word is present in dictionary or not. An array of strings is used for dictionary. Using array of strings for dictionary is definitely not a good idea. We have used for simplicity of the program def dictionaryContains(word): dictionary = {\u0026#34;mobile\u0026#34;, \u0026#34;samsung\u0026#34;, \u0026#34;sam\u0026#34;, \u0026#34;sung\u0026#34;, \u0026#34;man\u0026#34;, \u0026#34;mango\u0026#34;, \u0026#34;icecream\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;go\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;love\u0026#34;, \u0026#34;ice\u0026#34;, \u0026#34;cream\u0026#34;} return word in dictionary # Prints all possible word breaks of given string def wordBreak(string): # Last argument is prefix wordBreakUtil(string, len(string), \u0026#34;\u0026#34;) # Result store the current prefix with spaces # between words def wordBreakUtil(string, n, result): # Process all prefixes one by one for i in range(1, n + 1): # Extract substring from 0 to i in prefix prefix = string[:i] # If dictionary contains this prefix, then # we check for remaining string. Otherwise # we ignore this prefix (there is no else for # this if) and try next if dictionaryContains(prefix): # If no more elements are there, print it if i == n: # Add this element to previous prefix result += prefix print(result) return wordBreakUtil(string[i:], n - i, result+prefix+\u0026#34; \u0026#34;) print(\u0026#34;First Test:\u0026#34;) wordBreak(\u0026#34;iloveicecreamandmango\u0026#34;) print(\u0026#34;\\nSecond Test:\u0026#34;) wordBreak(\u0026#34;ilovesamsungmobile\u0026#34;) Remove Invalid Parentheses from collections import deque def isValidString(string): left = 0 right = 0 index = 0 while index \u0026lt; len(string): if string[index] == \u0026#39;(\u0026#39;: left += 1 elif string[index] == \u0026#39;)\u0026#39;: if left \u0026gt; 0: left -= 1 else: right += 1 if right \u0026gt; left: return False index += 1 return left == right def removeInvalidParentheses(string): visited = set() result = [] q = deque() valid = False visited.add(string) q.append(string) # BFS. while len(q) \u0026gt; 0: possibleAnswer = q.popleft() # Check whether \u0026#39;possibleAnswer\u0026#39; is valid or not. if isValidString(possibleAnswer): result.append(possibleAnswer) valid = True # If true, then the solution exists at current level. No need to move at next state. if valid == True: continue # Generate all possible next state of Strings from current String. for i in range(len(possibleAnswer)): if possibleAnswer[i] == \u0026#39;(\u0026#39; or possibleAnswer[i] == \u0026#39;)\u0026#39;: temp = possibleAnswer[0 : i] + possibleAnswer[i + 1 : len(possibleAnswer)] if temp not in visited: q.append(temp) visited.add(temp) return sorted(result) print(removeInvalidParentheses(\u0026#39;)(()))\u0026#39;)) print(removeInvalidParentheses(\u0026#39;(((a))) ((a))()\u0026#39;)) Sudoku Solver # N is the size of the 2D matrix N*N N = 9 # A utility function to print grid def printing(arr): for i in range(N): for j in range(N): print(arr[i][j], end = \u0026#34; \u0026#34;) print() # Checks whether it will be legal to assign num to the given row, col def isSafe(grid, row, col, num): # Check if we find the same num in the similar row , we return false for x in range(9): if grid[row][x] == num: return False # Check if we find the same num in the similar column , we return false for x in range(9): if grid[x][col] == num: return False # Check if we find the same num in the particular 3*3 matrix, we return false startRow = row - row % 3 startCol = col - col % 3 for i in range(3): for j in range(3): if grid[i + startRow][j + startCol] == num: return False return True # Takes a partially filled-in grid and attempts to assign values to all unassigned locations in # such a way to meet the requirements for Sudoku solution (non-duplication across rows, columns, and boxes) def solveSudoku(grid, row, col): # Check if we have reached the 8th row and 9th column (0 indexed matrix) , we are # returning true to avoid further backtracking if (row == N - 1 and col == N): return True # Check if column value becomes 9 , we move to next row and column start from 0 if col == N: row += 1 col = 0 # Check if the current position of the grid already contains value \u0026gt;0, we iterate for next column if grid[row][col] \u0026gt; 0: return solveSudoku(grid, row, col + 1) for num in range(1, N + 1, 1): # Check if it is safe to place the num (1-9) in the given row ,col -\u0026gt;we # move to next column if isSafe(grid, row, col, num): # Assigning the num in the current (row,col) position of the grid and assuming our assigned # num in the position is correct grid[row][col] = num # Checking for next possibility with next column if solveSudoku(grid, row, col + 1): return True # Removing the assigned num , since our assumption was wrong , and we go for next assumption with #diff num value grid[row][col] = 0 return False # 0 means unassigned cells grid = [[3, 0, 6, 5, 0, 8, 4, 0, 0], [5, 2, 0, 0, 0, 0, 0, 0, 0], [0, 8, 7, 0, 0, 0, 0, 3, 1], [0, 0, 3, 0, 1, 0, 0, 8, 0], [9, 0, 0, 8, 6, 3, 0, 0, 5], [0, 5, 0, 0, 9, 0, 6, 0, 0], [1, 3, 0, 0, 0, 0, 2, 5, 0], [0, 0, 0, 0, 0, 0, 0, 7, 4], [0, 0, 5, 2, 0, 6, 3, 0, 0]] if (solveSudoku(grid, 0, 0)): printing(grid) else: print(\u0026#34;no solution exists \u0026#34;) m-Colouring Problem \u0026#34;\u0026#34;\u0026#34; An array color[V] that should have numbers from 1 to m. color[i] should represent the color assigned to the ith vertex. The code should also return false if the graph cannot be colored with m colors. \u0026#34;\u0026#34;\u0026#34; from queue import Queue class node(object): color = 1 edges = set() def canPaint(nodes, n, m): # Create a visited array of n nodes, initialized to zero visited = [0 for _ in range(n+1)] # maxColors used till now are 1 as all nodes are painted color 1 maxColors = 1 # Do a full BFS traversal from all unvisited starting points for _ in range(1, n + 1): if visited[_]: continue # If the starting point is unvisited, mark it visited and push it in queue visited[_] = 1 q = Queue() q.put(_) # BFS Travel starts here while not q.empty(): top = q.get() # Checking all adjacent nodes to \u0026#34;top\u0026#34; edge in our queue for _ in nodes[top].edges: # IMPORTANT: If the color of the adjacent node is same, increase it by 1 if nodes[top].color == nodes[_].color: nodes[_].color += 1 # If number of colors used shoots m, return 0 maxColors = max(maxColors, max( nodes[top].color, nodes[_].color)) if maxColors \u0026gt; m: print(maxColors) return 0 # If the adjacent node is not visited, mark it visited and push it in queue if not visited[_]: visited[_] = 1 q.put(_) return 1 n = 4 graph = [ [ 0, 1, 1, 1 ], [ 1, 0, 1, 0 ], [ 1, 1, 0, 1 ], [ 1, 0, 1, 0 ] ] # Number of colors m = 3 # Create a vector of n+1 nodes of type \u0026#34;node\u0026#34; The zeroth position is just dummy (1 to n to be used) nodes = [] for _ in range(n+1): nodes.append(node()) # Add edges to each node as per given input for _ in range(n): for __ in range(n): if graph[_][__]: # Connect the undirected graph nodes[_].edges.add(_) nodes[__].edges.add(__) # Display final answer print(canPaint(nodes, n, m)) Print all palindromic partitions of a string def isPalindrome(string: str, low: int, high: int): while low \u0026lt; high: if string[low] != string[high]: return False low += 1 high -= 1 return True # Recursive function to find all palindromic partitions of str[start..n-1] # allPart --\u0026gt; A vector of vector of strings. # Every vector inside it stores a partition # currPart --\u0026gt; A vector of strings to store current partition def allPalPartUtil(allPart: list, currPart: list, start: int, n: int, string: str): # If \u0026#39;start\u0026#39; has reached len if start \u0026gt;= n: # In Python list are passed by reference that is why it is needed to copy first and then append x = currPart.copy() allPart.append(x) return # Pick all possible ending points for substrings for i in range(start, n): # If substring str[start..i] is palindrome if isPalindrome(string, start, i): # Add the substring to result currPart.append(string[start:i + 1]) # Recur for remaining substring allPalPartUtil(allPart, currPart, i + 1, n, string) # Remove substring str[start..i] from current partition currPart.pop() # Function to print all possible palindromic partitions of str. # It mainly creates vectors and calls allPalPartUtil() def allPalPartitions(string: str): n = len(string) # To Store all palindromic partitions allPart = [] # To store current palindromic partition currPart = [] # Call recursive function to generate all partitions and store in allPart allPalPartUtil(allPart, currPart, 0, n, string) # Print all partitions generated by above call for i in range(len(allPart)): for j in range(len(allPart[i])): print(allPart[i][j], end = \u0026#34; \u0026#34;) print() string = \u0026#34;nitin\u0026#34; allPalPartitions(string) Subset Sum Problem \u0026#34;\u0026#34;\u0026#34; Input : arr[] = {4, 1, 10, 12, 5, 2}, sum = 9 Output : TRUE {4, 5} is a subset with sum 9. Input : arr[] = {1, 8, 2, 5}, sum = 4 Output : FALSE There exists no subset with sum 4. \u0026#34;\u0026#34;\u0026#34; def isPossible(elements, target): dp = [False]*(target+1) # initializing with 1 as sum 0 is always possible dp[0] = True # loop to go through every element of the elements array for ele in elements: # to change the value o all possible sum values to True for j in range(target, ele - 1, -1): if dp[j - ele]: dp[j] = True # If target is possible return True else False return dp[target] # Driver code arr = [6, 2, 5] target = 7 if isPossible(arr, target): print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) The Knight’s tour problem # Chessboard Size n = 6 def isSafe(x, y, board): \u0026#39;\u0026#39;\u0026#39; A utility function to check if i,j are valid indexes for N*N chessboard \u0026#39;\u0026#39;\u0026#39; if(x \u0026gt;= 0 and y \u0026gt;= 0 and x \u0026lt; n and y \u0026lt; n and board[x][y] == -1): return True return False def printSolution(n, board): \u0026#39;\u0026#39;\u0026#39; A utility function to print Chessboard matrix \u0026#39;\u0026#39;\u0026#39; for i in range(n): for j in range(n): print(board[i][j], end=\u0026#39; \u0026#39;) print() def solveKT(n): \u0026#39;\u0026#39;\u0026#39; This function solves the Knight Tour problem using Backtracking. This function mainly uses solveKTUtil() to solve the problem. It returns false if no complete tour is possible, otherwise return true and prints the tour. Please note that there may be more than one solutions, this function prints one of the feasible solutions. \u0026#39;\u0026#39;\u0026#39; # Initialization of Board matrix board = [[-1 for i in range(n)]for i in range(n)] # move_x and move_y define next move of Knight. # move_x is for next value of x coordinate # move_y is for next value of y coordinate move_x = [2, 1, -1, -2, -2, -1, 1, 2] move_y = [1, 2, 2, 1, -1, -2, -2, -1] # Since the Knight is initially at the first block board[0][0] = 0 # Step counter for knight\u0026#39;s position pos = 1 # Checking if solution exists or not if(not solveKTUtil(n, board, 0, 0, move_x, move_y, pos)): print(\u0026#34;Solution does not exist\u0026#34;) else: printSolution(n, board) def solveKTUtil(n, board, curr_x, curr_y, move_x, move_y, pos): \u0026#39;\u0026#39;\u0026#39; A recursive utility function to solve Knight Tour problem \u0026#39;\u0026#39;\u0026#39; if(pos == n**2): return True # Try all next moves from the current coordinate x, y for i in range(8): new_x = curr_x + move_x[i] new_y = curr_y + move_y[i] if(isSafe(new_x, new_y, board)): board[new_x][new_y] = pos if(solveKTUtil(n, board, new_x, new_y, move_x, move_y, pos+1)): return True # Backtracking board[new_x][new_y] = -1 return False solveKT(n) Tug of War # function that tries every possible solution by calling itself recursively def TOWUtil(arr, n, curr_elements, no_of_selected_elements, soln, min_diff, Sum, curr_sum, curr_position): # checks whether the it is going out of bound if (curr_position == n): return # checks that the numbers of elements left are not less than the number of elements required to form the solution if ((int(n / 2) - no_of_selected_elements) \u0026gt;(n - curr_position)): return # consider the cases when current element is not included in the solution TOWUtil(arr, n, curr_elements, no_of_selected_elements, soln, min_diff, Sum, curr_sum, curr_position + 1) # add the current element to the solution no_of_selected_elements += 1 curr_sum = curr_sum + arr[curr_position] curr_elements[curr_position] = True # checks if a solution is formed if (no_of_selected_elements == int(n / 2)): # checks if the solution formed is better than the best solution so far if (abs(int(Sum / 2) - curr_sum) \u0026lt; min_diff[0]): min_diff[0] = abs(int(Sum / 2) - curr_sum) for i in range(n): soln[i] = curr_elements[i] else: # consider the cases where current element is included in the solution TOWUtil(arr, n, curr_elements, no_of_selected_elements, soln, min_diff, Sum, curr_sum, curr_position + 1) # removes current element before returning # to the caller of this function curr_elements[curr_position] = False # main function that generate an arr def tugOfWar(arr, n): # the boolean array that contains the inclusion and exclusion of an element # in current set. The number excluded automatically form the other set curr_elements = [None] * n # The inclusion/exclusion array for final solution soln = [None] * n min_diff = [999999999999] Sum = 0 for i in range(n): Sum += arr[i] curr_elements[i] = soln[i] = False # Find the solution using recursive function TOWUtil() TOWUtil(arr, n, curr_elements, 0, soln, min_diff, Sum, 0, 0) # Print the solution print(\u0026#34;The first subset is: \u0026#34;) for i in range(n): if (soln[i] == True): print(arr[i], end = \u0026#34; \u0026#34;) print() print(\u0026#34;The second subset is: \u0026#34;) for i in range(n): if (soln[i] == False): print(arr[i], end = \u0026#34; \u0026#34;) arr = [23, 45, -34, 12, 0, 98, -99, 4, 189, -1, 4] n = len(arr) tugOfWar(arr, n) Find shortest safe route in a path with landmines # Python3 program to find shortest safe Route # in the matrix with landmines import sys R = 12 C = 10 # These arrays are used to get row and column # numbers of 4 neighbours of a given cell rowNum = [ -1, 0, 0, 1 ] colNum = [ 0, -1, 1, 0 ] min_dist = sys.maxsize # A function to check if a given cell (x, y) # can be visited or not def isSafe(mat, visited, x, y): if (mat[x][y] == 0 or visited[x][y]): return False return True # A function to check if a given cell (x, y) is # a valid cell or not def isValid(x, y): if (x \u0026lt; R and y \u0026lt; C and x \u0026gt;= 0 and y \u0026gt;= 0): return True return False # A function to mark all adjacent cells of # landmines as unsafe. Landmines are shown with # number 0 def markUnsafeCells(mat): for i in range(R): for j in range(C): # If a landmines is found if (mat[i][j] == 0): # Mark all adjacent cells for k in range(4): if (isValid(i + rowNum[k], j + colNum[k])): mat[i + rowNum[k]][j + colNum[k]] = -1 # Mark all found adjacent cells as unsafe for i in range(R): for j in range(C): if (mat[i][j] == -1): mat[i][j] = 0 print(mat) \u0026#34;\u0026#34;\u0026#34; for i in range(R): for j in range(C): print(mat[i][j], end=\u0026#39;\u0026#39;) print() \u0026#34;\u0026#34;\u0026#34; # Function to find shortest safe Route in the matrix with landmines # mat[][] - binary input matrix with safe cells marked as 1 # visited[][] - store info about cells already visited in current route # (i, j) are coordinates of the current cell # min_dist --\u0026gt; stores minimum cost of shortest path so far # dist --\u0026gt; stores current path cost def findShortestPathUtil(mat, visited, i, j, dist): global min_dist # If destination is reached if (j == C - 1): # Update shortest path found so far min_dist = min(dist, min_dist) return # If current path cost exceeds minimum so far if (dist \u0026gt; min_dist): return # include (i, j) in current path visited[i][j] = True # Recurse for all safe adjacent neighbours for k in range(4): if (isValid(i + rowNum[k], j + colNum[k]) and isSafe(mat, visited, i + rowNum[k], j + colNum[k])): findShortestPathUtil(mat, visited, i + rowNum[k], j + colNum[k], dist + 1) # Backtrack visited[i][j] = False # A wrapper function over findshortestPathUtil() def findShortestPath(mat): global min_dist # Stores minimum cost of shortest path so far min_dist = sys.maxsize # Create a boolean matrix to store info about # cells already visited in current route visited = [[False for i in range(C)] for j in range(R)] # Mark adjacent cells of landmines as unsafe markUnsafeCells(mat) # Start from first column and take minimum for i in range(R): # If path is safe from current cell if (mat[i][0] == 1): # Find shortest route from (i, 0) to any # cell of last column (x, C - 1) where # 0 \u0026lt;= x \u0026lt; R findShortestPathUtil(mat, visited, i, 0, 0) # If min distance is already found if (min_dist == C - 1): break # If destination can be reached if (min_dist != sys.maxsize): print(\u0026#34;Length of shortest safe route is\u0026#34;, min_dist) else: # If the destination is not reachable print(\u0026#34;Destination not reachable from given source\u0026#34;) mat = [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 0, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 0, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 ], [ 1, 0, 1, 1, 1, 1, 1, 1, 0, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 0, 1, 1, 1, 1, 0, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 1, 0, 1, 1, 1, 1, 1, 1 ] ] # Find shortest path findShortestPath(mat) Combinational Sum \u0026#34;\u0026#34;\u0026#34;Find all combinations that sum to a given value. Input : arr[] = 2, 4, 6, 8 x = 8 Output : [2, 2, 2, 2] [2, 2, 4] [2, 6] [4, 4] [8] \u0026#34;\u0026#34;\u0026#34; def combinationSum(arr, sum): ans = [] temp = [] # first do hashing nothing but set{} since set does not always sort removing the duplicates # using Set and Sorting the List arr = sorted(list(set(arr))) findNumbers(ans, arr, temp, sum, 0) return ans def findNumbers(ans, arr, temp, sum, index): if(sum == 0): # Adding deep copy of list to ans ans.append(list(temp)) return # Iterate from index to len(arr) - 1 for i in range(index, len(arr)): # checking that sum does not become negative if(sum - arr[i]) \u0026gt;= 0: # adding element which can contribute to # sum temp.append(arr[i]) findNumbers(ans, arr, temp, sum-arr[i], i) # removing element from list (backtracking) temp.remove(arr[i]) arr = [2, 4, 6, 8] sum = 8 ans = combinationSum(arr, sum) # If result is empty, then if len(ans) \u0026lt;= 0: print(\u0026#34;empty\u0026#34;) # print all combinations stored in ans for i in range(len(ans)): print(\u0026#34;(\u0026#34;, end=\u0026#39; \u0026#39;) for j in range(len(ans[i])): print(str(ans[i][j])+\u0026#34; \u0026#34;, end=\u0026#39; \u0026#39;) print(\u0026#34;)\u0026#34;, end=\u0026#39; \u0026#39;) Find Maximum number possible by doing at-most K swaps \u0026#34;\u0026#34;\u0026#34; Given a positive integer, find the maximum integer possible by doing at-most K swap operations on its digits. Examples: Input: M = 254, K = 1 Output: 524 Swap 5 with 2 so number becomes 524 \u0026#34;\u0026#34;\u0026#34; # function to find maximum integer possible by doing at-most K swap operations on its digits def findMaximumNum(string, k, maxm, ctr): # return if no swaps left if k == 0: return n = len(string) # Consider every digit after the cur position mx = string[ctr] for i in range(ctr+1,n): # Find maximum digit greater than at ctr among rest if int(string[i]) \u0026gt; int(mx): mx=string[i] # If maxm is not equal to str[ctr], decrement k if(mx!=string[ctr]): k=k-1 # search this maximum among the rest from behind first swap the last maximum digit if it occurs more then 1 time # example str= 1293498 and k=1 then max string is 9293418 instead of 9213498 for i in range(ctr,n): # If digit equals maxm swap the digit with current digit and recurse for the rest if(string[i]==mx): # swap str[ctr] with str[j] string[ctr], string[i] = string[i], string[ctr] new_str = \u0026#34;\u0026#34;.join(string) # If current num is more than maximum so far if int(new_str) \u0026gt; int(maxm[0]): maxm[0] = new_str # recurse of the other k - 1 swaps findMaximumNum(string, k , maxm, ctr+1) # backtrack string[ctr], string[i] = string[i], string[ctr] string = \u0026#34;129814999\u0026#34; k = 4 maxm = [string] string = [char for char in string] findMaximumNum(string, k, maxm, 0) print(maxm[0]) Print all permutations of a string def permute(s, answer): if (len(s) == 0): print(answer, end = \u0026#34; \u0026#34;) return for i in range(len(s)): ch = s[i] left_substr = s[0:i] right_substr = s[i + 1:] rest = left_substr + right_substr permute(rest, answer + ch) answer=\u0026#34;\u0026#34; s = \u0026#34;alex\u0026#34; print(\u0026#34;All possible strings are : \u0026#34;) permute(s, answer) Find if there is a path of more than k length from a source # Program to find if there is a simple path with weight more than k # This class represents a dipathted graph using adjacency list representation class Graph: # Allocates memory for adjacency list def __init__(self, V): self.V = V self.adj = [[] for i in range(V)] # Returns true if graph has path more than k length def pathMoreThanK(self,src, k): # Create a path array with nothing included in path path = [False]*self.V # Add source vertex to path path[src] = 1 return self.pathMoreThanKUtil(src, k, path) # Prints shortest paths from src to all other vertices def pathMoreThanKUtil(self,src, k, path): # If k is 0 or negative, return true if (k \u0026lt;= 0): return True # Get all adjacent vertices of source vertex src and recursively explore all paths from src. i = 0 while i != len(self.adj[src]): # Get adjacent vertex and weight of edge v = self.adj[src][i][0] w = self.adj[src][i][1] i += 1 # If vertex v is already there in path, then there is a cycle (we ignore this edge) if (path[v] == True): continue # If weight of is more than k, return true if (w \u0026gt;= k): return True # Else add this vertex to path path[v] = True # If this adjacent can provide a path longer than k, return true. if (self.pathMoreThanKUtil(v, k-w, path)): return True # Backtrack path[v] = False # If no adjacent could produce longer path, return false return False # Utility function to an edge (u, v) of weight w def addEdge(self,u, v, w): self.adj[u].append([v, w]) self.adj[v].append([u, w]) # create the graph given in above figure V = 9 g = Graph(V) # making above shown graph g.addEdge(0, 1, 4) g.addEdge(0, 7, 8) g.addEdge(1, 2, 8) g.addEdge(1, 7, 11) g.addEdge(2, 3, 7) g.addEdge(2, 8, 2) g.addEdge(2, 5, 4) g.addEdge(3, 4, 9) g.addEdge(3, 5, 14) g.addEdge(4, 5, 10) g.addEdge(5, 6, 2) g.addEdge(6, 7, 1) g.addEdge(6, 8, 6) g.addEdge(7, 8, 7) #calling in the function src = 0 k = 62 print(\u0026#34;Yes\u0026#34;) if g.pathMoreThanK(src, k) else print(\u0026#34;No\u0026#34;) k = 60 print(\u0026#34;Yes\u0026#34;) if g.pathMoreThanK(src, k) else print(\u0026#34;No\u0026#34;) Longest Possible Route in a Matrix with Hurdles # Python program to find Longest Possible Route in a matrix with hurdles import sys R,C = 3,10 # A Pair to store status of a cell. found is set to True of destination is reachable and value stores # distance of longest path class Pair: def __init__(self, found, value): self.found = found self.value = value # Function to find Longest Possible Route in the matrix with hurdles. If the destination is not reachable # the function returns false with cost sys.maxsize. (i, j) is source cell and (x, y) is destination cell. def findLongestPathUtil(mat, i, j, x, y, visited): # if (i, j) itself is destination, return True if (i == x and j == y): p = Pair( True, 0 ) return p # if not a valid cell, return false if (i \u0026lt; 0 or i \u0026gt;= R or j \u0026lt; 0 or j \u0026gt;= C or mat[i][j] == 0 or visited[i][j]) : p = Pair( False, sys.maxsize ) return p # include (i, j) in current path i.e. set visited(i, j) to True visited[i][j] = True # res stores longest path from current cell (i, j) to destination cell (x, y) res = -sys.maxsize -1 # go left from current cell sol = findLongestPathUtil(mat, i, j - 1, x, y, visited) # if destination can be reached on going left from current cell, update res if (sol.found): res = max(res, sol.value) # go right from current cell sol = findLongestPathUtil(mat, i, j + 1, x, y, visited) # if destination can be reached on going right from current cell, update res if (sol.found): res = max(res, sol.value) # go up from current cell sol = findLongestPathUtil(mat, i - 1, j, x, y, visited) # if destination can be reached on going up from current cell, update res if (sol.found): res = max(res, sol.value) # go down from current cell sol = findLongestPathUtil(mat, i + 1, j, x, y, visited) # if destination can be reached on going down from current cell, update res if (sol.found): res = max(res, sol.value) # Backtrack visited[i][j] = False # if destination can be reached from current cell, return True if (res != -sys.maxsize -1): p = Pair( True, 1 + res ) return p # if destination can\u0026#39;t be reached from current cell, return false else: p = Pair( False, sys.maxsize ) return p # A wrapper function over findLongestPathUtil() def findLongestPath(mat, i, j, x,y): # create a boolean matrix to store info about cells already visited in current route initialize visited to false visited = [[False for i in range(C)]for j in range(R)] # find longest route from (i, j) to (x, y) and print its maximum cost p = findLongestPathUtil(mat, i, j, x, y, visited) if (p.found): print(\u0026#34;Length of longest possible route is \u0026#34;,str(p.value)) # If the destination is not reachable else: print(\u0026#34;Destination not reachable from given source\u0026#34;) # input matrix with hurdles shown with number 0 mat = [ [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ], [ 1, 1, 0, 1, 1, 0, 1, 1, 0, 1 ], [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ] # find longest path with source (0, 0) and destination (1, 7) findLongestPath(mat, 0, 0, 1, 7) Print all possible paths from top left to bottom right of a mXn matrix \u0026#34;\u0026#34;\u0026#34; The problem is to print all the possible paths from top left to bottom right of a mXn matrix with the constraints that from each cell you can either move only to right or down. Examples : Input : 1 2 3 4 5 6 Output : 1 4 5 6 1 2 5 6 1 2 3 6 Input : 1 2 3 4 Output : 1 2 4 1 3 4 \u0026#34;\u0026#34;\u0026#34; def printAllPaths(M, m, n): mapping = {} if not mapping.get((m,n)): if m == 1 and n == 1: return [M[m-1][n-1]] else: res = [] if n \u0026gt; 1: a = printAllPaths(M, m, n-1) for i in a: if not isinstance(i, list): i = [i] res.append(i+[M[m-1][n-1]]) if m \u0026gt; 1: b =printAllPaths(M, m-1, n) for i in b: if not isinstance(i, list): i = [i] res.append(i+[M[m-1][n-1]]) mapping[(m,n)] = res return mapping.get((m,n)) M = [[1, 2, 3], [4, 5, 6], [7,8,9]] m, n = len(M), len(M[0]) res = printAllPaths(M, m, n) for i in res: print(i) Partition of a set intoK subsets with equal sum \u0026#34;\u0026#34;\u0026#34; Input : arr = [2, 1, 4, 5, 6], K = 3 Output : Yes we can divide above array into 3 parts with equal sum as [[2, 4], [1, 5], [6]] Input : arr = [2, 1, 5, 5, 6], K = 3 Output : No It is not possible to divide above array into 3 parts with equal sum \u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34;* array - given input array subsetSum array - sum to store each subset of the array taken -boolean array to check whether element is taken into sum partition or not K - number of partitions needed N - total number of element in array curIdx - current subsetSum index limitIdx - lastIdx from where array element should be taken \u0026#34;\u0026#34;\u0026#34; def isKPartitionPossibleRec(arr, subsetSum, taken, subset, K, N, curIdx, limitIdx): if subsetSum[curIdx] == subset: \u0026#34;\u0026#34;\u0026#34; current index (K - 2) represents (K - 1) subsets of equal sum last partition will already remain with sum \u0026#39;subset\u0026#39; \u0026#34;\u0026#34;\u0026#34; if (curIdx == K - 2): return True # recursive call for next subsetition return isKPartitionPossibleRec(arr, subsetSum, taken, subset, K, N, curIdx + 1 , N - 1) # start from limitIdx and include elements into current partition for i in range(limitIdx, -1, -1): # if already taken, continue if (taken[i]): continue tmp = subsetSum[curIdx] + arr[i] # if temp is less than subset, then only include the element and call recursively if (tmp \u0026lt;= subset): # mark the element and include into current partition sum taken[i] = True subsetSum[curIdx] += arr[i] nxt = isKPartitionPossibleRec(arr, subsetSum, taken, subset, K, N, curIdx, i - 1) # after recursive call unmark the element and remove from subsetition sum taken[i] = False subsetSum[curIdx] -= arr[i] if (nxt): return True return False # Method returns True if arr can be partitioned into K subsets with equal sum def isKPartitionPossible(arr, N, K): # If K is 1, then complete array will be our answer if (K == 1): return True # If total number of partitions are more than N, then division is not possible if (N \u0026lt; K): return False # if array sum is not divisible by K then we can\u0026#39;t divide array into K partitions sum = 0 for i in range(N): sum += arr[i] if (sum % K != 0): return False # the sum of each subset should be subset (= sum / K) subset = sum // K subsetSum = [0] * K taken = [0] * N # Initialize sum of each subset from 0 for i in range(K): subsetSum[i] = 0 # mark all elements as not taken for i in range(N): taken[i] = False # initialize first subset sum as last element of array and mark that as taken subsetSum[0] = arr[N - 1] taken[N - 1] = True # call recursive method to check K-substitution condition return isKPartitionPossibleRec(arr, subsetSum, taken, subset, K, N, 0, N - 1) arr = [2, 1, 4, 5, 3, 3 ] N = len(arr) K = 3 if (isKPartitionPossible(arr, N, K)): print(\u0026#34;Partitions into equal sum is possible.\\n\u0026#34;) else: print(\u0026#34;Partitions into equal sum is not possible.\\n\u0026#34;) Find the K-th Permutation Sequence of first N natural numbers \u0026#34;\u0026#34;\u0026#34; Input: N = 3, K = 4 Output: 231 Explanation: The ordered list of permutation sequence from integer 1 to 3 is : 123, 132, 213, 231, 312, 321. So, the 4th permutation sequence is “231”. Input: N = 2, K = 1 Output: 12 Explanation: For n = 2, only 2 permutations are possible 12 21. So, the 1st permutation sequence is “12”. \u0026#34;\u0026#34;\u0026#34; # Function to find the index of number at first position of kth sequence of set of size n def findFirstNumIndex(k, n): if (n == 1): return 0, k n -= 1 first_num_index = 0 # n_actual_fact = n! n_partial_fact = n while (k \u0026gt;= n_partial_fact and n \u0026gt; 1): n_partial_fact = n_partial_fact * (n - 1) n -= 1 # First position of the kth sequence will be occupied by the number present at index = k / (n-1)! first_num_index = k // n_partial_fact k = k % n_partial_fact return first_num_index, k # Function to find the kth permutation of n numbers def findKthPermutation(n, k): # Store final answer ans = \u0026#34;\u0026#34; s = set() # Insert all natural number upto n in set for i in range(1, n + 1): s.add(i) # Subtract 1 to get 0 based indexing k = k - 1 for i in range(n): # Mark the first position itr = list(s) index, k = findFirstNumIndex(k, n - i) # itr now points to the number at index in set s ans += str(itr[index]) # remove current number from the set itr.pop(index) s = set(itr) return ans n = 3 k = 4 kth_perm_seq = findKthPermutation(n, k) print(kth_perm_seq) ","permalink":"https://atharvashah.netlify.app/blog/dsapython/backtracking/","summary":"Rat in a maze Problem Printing all solutions in N-Queen Problem Word Break Problem using Backtracking Remove Invalid Parentheses Sudoku Solver m-Colouring Problem Print all palindromic partitions of a string Subset Sum Problem The Knight’s tour problem Tug of War Find shortest safe route in a path with landmines Combinational Sum Find Maximum number possible by doing at-most K swaps Print all permutations of a string Find if there is a path of more than k length from a source Longest Possible Route in a Matrix with Hurdles Print all possible paths from top left to bottom right of a mXn matrix Partition of a set intoK subsets with equal sum Find the K-th Permutation Sequence of first N natural numbers Rat in a maze Problem \u0026#34;\u0026#34;\u0026#34; N = 4 m[][] = {{1, 0, 0, 0}, {1, 1, 0, 1}, {1, 1, 0, 0}, {0, 1, 1, 1}} Output: DDRDRR DRDDRR Explanation: The rat can reach the destination at (3, 3) from (0, 0) by two paths - DRDDRR and DDRDRR, when printed in sorted order we get DDRDRR DRDDRR.","title":"DSA in Python - Backtracking"},{"content":" █ █ █ █ ╚ █ █ █ █ █ ═ █ ╔ █ ╔ ║ ╝ █ ═ █ ═ █ ═ █ ═ █ █ █ █ █ ╚ ╗ █ █ █ █ ═ ╗ ║ ║ ║ ╝ █ █ █ █ █ ╚ █ █ █ █ █ ═ █ ╔ █ ╔ █ ═ █ ═ █ ═ █ ═ █ ═ █ ═ █ ═ █ █ █ █ █ ═ ╗ █ ╔ █ ╔ ╝ ╗ ╝ ╗ ╝ █ █ █ ╚ █ █ █ █ █ ╚ █ ╔ ║ ║ █ ═ █ ═ █ ═ █ ═ █ ═ █ ═ █ ═ █ █ █ █ █ ═ ╗ █ █ █ ╔ ╝ ╗ ║ ║ ╝ █ █ █ █ ╚ █ █ █ █ █ ╚ ╗ ║ ║ ║ █ ═ █ ═ █ ═ █ ═ █ █ █ █ █ ═ █ █ █ █ ╔ ╝ ╗ ║ ║ ║ ╝ █ ╚ █ ═ █ ═ █ █ █ █ █ ╚ █ █ █ █ █ ═ █ ╔ ║ ║ ║ ╝ █ ═ █ ═ ╗ ╝ █ █ █ █ █ ╚ █ █ █ █ █ ═ █ █ ╔ ║ ║ ╝ ╗ █ █ ╚ ╗ █ █ ╚ █ █ ═ █ █ ╔ ╝ █ █ ╔ ╝ █ █ █ █ █ ╚ █ █ █ █ █ ═ ╗ ║ ║ ║ ║ ╝ █ █ █ █ █ ╚ █ █ █ █ █ ═ █ ╔ █ ╔ █ ═ █ ═ █ ═ █ ═ █ ═ █ ═ █ ═ █ ═ ╗ ╝ █ ═ █ ═ █ ═ ╗ ╝ ╗ ╝ My journey in the tech industry began early on as my fascination with the way computers work and the endless possibilities they offer led to teaching myself how to code and eventually turning my passion into a career. As a self-proclaimed \u0026ldquo;code cruncher,\u0026rdquo; I possess a deep understanding of the programming language Python and enjoy exploring the many libraries and frameworks available. I also have experience with a variety of data analysis tools and enjoy using them to uncover insights and patterns in large sets of data.\nI am an avid reader and am always on the lookout for the latest books. My reading preferences include Sci-Fi, High Fantasy, Fiction, Thrillers, and Supernatural. I am also a fan of graphic novels and mangas. I believe that staying informed and educated is crucial in this constantly evolving industry.\nNot just a tech nerd, I also have other interests and hobbies such as being a cinephile and a music aficionado. I enjoy watching films from all over the world, and love to discuss and debate the merits of different films and directors. I have a particular soft spot for classic, neo-noir, psychological thrillers and horror films. I enjoy traveling and exploring new places, and as a programmer, I fall into the Venn Diagram of a \u0026ldquo;gamer\u0026rdquo; and \u0026ldquo;nerd.\u0026rdquo; I enjoy playing video games and have a particular fondness for RPGs and strategy games. I also enjoy playing board games and card games with my friends.\nMy taste in music is diverse, and I enjoy listening to everything from classic rock to hip-hop and electronic music. I love discovering new artists and attending live music events. I believe that music is a powerful tool that can evoke emotions and create memories.\nI have had the opportunity to work in a few different roles in the tech industry, and have developed a variety of skills including working as a software developer, a data analyst and a consultant. Each role has taught me something new, and I am always looking for new challenges and opportunities to learn.\nI am a strong believer in the power of technology to make positive change in the world and am passionate about using my skills and knowledge to help others and make a difference. I have volunteered for various non-profit organizations and have participated in hackathons to develop solutions for social and environmental issues.\nOverall, I am a dedicated, hard-working and curious person. I am always eager to learn new things and take on new challenges. I believe that the world of technology is constantly evolving and there is always more to discover. I am excited to see where my journey in this field will take me next.\nWanna Hang? Grab All My Social Links\n","permalink":"https://atharvashah.netlify.app/about/","summary":"Get to know me better","title":""},{"content":"At This website, accessible from https://atharvashah.netlify.app/, one of our main priorities is the privacy of our visitors. This Privacy Policy document contains types of information that is collected and recorded by This website and how we use it.\nIf you have additional questions or require more information about our Privacy Policy, do not hesitate to contact us.\nThis Privacy Policy applies only to our online activities and is valid for visitors to our website with regards to the information that they shared and/or collect in This website. This policy is not applicable to any information collected offline or via channels other than this website. Our Privacy Policy was created with the help of the TermsFeed Free Privacy Policy Generator.\nConsent By using our website, you hereby consent to our Privacy Policy and agree to its terms.\nInformation we collect The personal information that you are asked to provide, and the reasons why you are asked to provide it, will be made clear to you at the point we ask you to provide your personal information.\nIf you contact us directly, we may receive additional information about you such as your name, email address, phone number, the contents of the message and/or attachments you may send us, and any other information you may choose to provide.\nWhen you sign up for a newsletter, we may ask for your contact information, including items such as name, company name, address, email address, and telephone number.\nHow we use your information We use the information we collect in various ways, including to:\nProvide, operate, and maintain our website Improve, personalize, and expand our website Understand and analyze how you use our website Develop new products, services, features, and functionality Communicate with you, either directly or through one of our partners, including for customer service, to provide you with updates and other information relating to the website, and for marketing and promotional purposes Send you emails Find and prevent fraud Log Files This website follows a standard procedure of using log files. These files log visitors when they visit websites. All hosting companies do this and a part of hosting services\u0026rsquo; analytics. The information collected by log files include internet protocol (IP) addresses, browser type, Internet Service Provider (ISP), date and time stamp, referring/exit pages, and possibly the number of clicks. These are not linked to any information that is personally identifiable. The purpose of the information is for analyzing trends, administering the site, tracking users\u0026rsquo; movement on the website, and gathering demographic information.\nCookies and Web Beacons Like any other website, This website uses \u0026lsquo;cookies\u0026rsquo;. These cookies are used to store information including visitors\u0026rsquo; preferences, and the pages on the website that the visitor accessed or visited. The information is used to optimize the users\u0026rsquo; experience by customizing our web page content based on visitors\u0026rsquo; browser type and/or other information.\nAdvertising Partners Privacy Policies You may consult this list to find the Privacy Policy for each of the advertising partners of This website.\nThird-party ad servers or ad networks uses technologies like cookies, JavaScript, or Web Beacons that are used in their respective advertisements and links that appear on This website, which are sent directly to users\u0026rsquo; browser. They automatically receive your IP address when this occurs. These technologies are used to measure the effectiveness of their advertising campaigns and/or to personalize the advertising content that you see on websites that you visit.\nNote that This website has no access to or control over these cookies that are used by third-party advertisers.\nThird Party Privacy Policies This website\u0026rsquo;s Privacy Policy does not apply to other advertisers or websites. Thus, we are advising you to consult the respective Privacy Policies of these third-party ad servers for more detailed information. It may include their practices and instructions about how to opt-out of certain options.\nYou can choose to disable cookies through your individual browser options. To know more detailed information about cookie management with specific web browsers, it can be found at the browsers\u0026rsquo; respective websites.\nCCPA Privacy Rights (Do Not Sell My Personal Information) Under the CCPA, among other rights, California consumers have the right to:\nRequest that a business that collects a consumer\u0026rsquo;s personal data disclose the categories and specific pieces of personal data that a business has collected about consumers.\nRequest that a business delete any personal data about the consumer that a business has collected.\nRequest that a business that sells a consumer\u0026rsquo;s personal data, not sell the consumer\u0026rsquo;s personal data.\nIf you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us.\nGDPR Data Protection Rights We would like to make sure you are fully aware of all of your data protection rights. Every user is entitled to the following:\nThe right to access – You have the right to request copies of your personal data. We may charge you a small fee for this service.\nThe right to rectification – You have the right to request that we correct any information you believe is inaccurate. You also have the right to request that we complete the information you believe is incomplete.\nThe right to erasure – You have the right to request that we erase your personal data, under certain conditions.\nThe right to restrict processing – You have the right to request that we restrict the processing of your personal data, under certain conditions.\nThe right to object to processing – You have the right to object to our processing of your personal data, under certain conditions.\nThe right to data portability – You have the right to request that we transfer the data that we have collected to another organization, or directly to you, under certain conditions.\nIf you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us.\nChildren\u0026rsquo;s Information Another part of our priority is adding protection for children while using the internet. We encourage parents and guardians to observe, participate in, and/or monitor and guide their online activity.\nThis website does not knowingly collect any Personal Identifiable Information from children under the age of 13. If you think that your child provided this kind of information on our website, we strongly encourage you to contact us immediately and we will do our best efforts to promptly remove such information from our records.\n","permalink":"https://atharvashah.netlify.app/privacy-policy/","summary":"Privacy Policy","title":""}]